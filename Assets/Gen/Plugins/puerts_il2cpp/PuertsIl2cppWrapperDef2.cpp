// Auto Gen

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "PuertsValueType.h"
#if defined(__EMSCRIPTEN__)
#include "pesapi_webgl.h"
using namespace pesapi::webglimpl;
#endif

namespace puerts
{


// System.TimeSpan get_BaseUtcOffset() declare in System.TimeZoneInfo
bool w_S_i8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i8_ (*FuncToCall)(void*,const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan GetUtcOffset(System.DateTimeOffset) declare in System.TimeZoneInfo
bool w_S_i8_tS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_tS_S_u8_i2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};

    typedef struct S_i8_ (*FuncToCall)(void*,struct S_S_u8_i2_ p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan Add(System.TimeSpan) declare in System.TimeSpan
bool w_S_i8_tS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_tS_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};

    typedef struct S_i8_ (*FuncToCall)(void*,struct S_i8_ p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan GetUtcOffset(System.DateTime) declare in System.TimeZoneInfo
bool w_S_i8_tS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_tS_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef struct S_i8_ (*FuncToCall)(void*,struct S_u8_ p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan GetTimeSpan(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_i8_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i8_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Rd.RdId Mix(Int64) declare in JetBrains.Rd.RdId
bool w_S_i8_ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_ti8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef struct S_i8_ (*FuncToCall)(void*,int64_t p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan Renewal(System.Runtime.Remoting.Lifetime.ILease) declare in System.Runtime.Remoting.Lifetime.ClientSponsor
bool w_S_i8_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i8_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan Multiply(Double) declare in System.TimeSpan
bool w_S_i8_tr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_tr8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_i8_ (*FuncToCall)(void*,double p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Rd.RdId Mix(System.String) declare in JetBrains.Rd.RdId
bool w_S_i8_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i8_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// FileData ReadFileData(System.IO.BinaryReader) declare in Codice.CM.Common.Serialization.PacketFileReader
bool w_S_i8i2u8bo_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i2u8bo_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i8i2u8bo_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_i8i2u8bo_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// FileData ReadFileData() declare in Codice.CM.Common.Serialization.PacketFileReader
bool w_S_i8i2u8bo_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i2u8bo_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i8i2u8bo_ (*FuncToCall)(void*,const void* method);
    struct S_i8i2u8bo_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// FileData Read(System.Guid) declare in Codice.CM.Common.Serialization.ExternalStorageDataReader
bool w_S_i8i2u8bo_tS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i2u8bo_tS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef struct S_i8i2u8bo_ (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, const void* method);
    struct S_i8i2u8bo_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Mono.Unix.Native.Cmsghdr ReadFromBuffer(Mono.Unix.Native.Msghdr, Int64) declare in Mono.Unix.Native.Cmsghdr
bool w_S_i8i4i4_oi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i4i4_oi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef struct S_i8i4i4_ (*FuncToCall)(Il2CppObject* p0, int64_t p1, const void* method);
    struct S_i8i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// TimestampConversionRatio get_TimestampToNanosecondsConversionRatio() declare in Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility
bool w_S_i8i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i8i8_ (*FuncToCall)(const void* method);
    struct S_i8i8_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// PlasticPipe.Traffic GetTotal() declare in PlasticPipe.Client.ClientTransportTotalTraffic
bool w_S_i8i8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i8i8_ (*FuncToCall)(void*,const void* method);
    struct S_i8i8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// PlasticPipe.Traffic BeginCall(PlasticPipe.Client.IClientConnection) declare in PlasticPipe.Client.ClientTransportTotalTraffic
bool w_S_i8i8_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i8_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i8i8_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_i8i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonReaderState get_CurrentState() declare in System.Text.Json.Utf8JsonReader
bool w_S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__ (*FuncToCall)(void*,const void* method);
    struct S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Profiling.ProfilerRecorderSample GetSample(Int32) declare in Unity.Profiling.ProfilerRecorder
bool w_S_i8i8i8_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i8i8_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i8i8i8_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Codice.Client.Commands.UpdateOperationStatus GetUpdateStatus() declare in Codice.Client.BaseCommands.UpdateNotifier
bool w_S_i8i8i8i8bb_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i8i8i8bb_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i8i8i8i8bb_ (*FuncToCall)(void*,const void* method);
    struct S_i8i8i8i8bb_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Diagnostics.CounterSample get_Sample() declare in System.Diagnostics.InstanceData
bool w_S_i8i8i8i8i8i8i8i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i8i8i8i8i8i8i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i8i8i8i8i8i8i8i4_ (*FuncToCall)(void*,const void* method);
    struct S_i8i8i8i8i8i8i8i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Nullable`1[System.Decimal]] AverageAsync(Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[System.Nullable`1[System.Decimal]], System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_S_oN_bS_i4i4i4i4u8__i2_tDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oN_bS_i4i4i4i4u8__i2_tDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_oN_bS_i4i4i4i4u8__i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oN_bS_i4i4i4i4u8__i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Mono.Cecil.Cil.InstructionOffset get_Start() declare in Mono.Cecil.Cil.ScopeDebugInformation
bool w_S_oN_bi4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oN_bi4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oN_bi4__ (*FuncToCall)(void*,const void* method);
    struct S_oN_bi4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Nullable`1[System.Int32]] MinAsync(Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[System.Nullable`1[System.Int32]], System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_S_oN_bi4_i2_tDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oN_bi4_i2_tDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_oN_bi4_i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oN_bi4_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Nullable`1[System.Int64]] MinAsync(Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[System.Nullable`1[System.Int64]], System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_S_oN_bi8_i2_tDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oN_bi8_i2_tDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_oN_bi8_i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oN_bi8_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Nullable`1[System.Single]] AverageAsync(Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[System.Nullable`1[System.Single]], System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_S_oN_br4_i2_tDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oN_br4_i2_tDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_oN_br4_i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oN_br4_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Nullable`1[System.Double]] AverageAsync(Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[System.Nullable`1[System.Int32]], System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_S_oN_br8_i2_tDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oN_br8_i2_tDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_oN_br8_i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oN_br8_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.CompilerServices.AsyncUniTaskVoidMethodBuilder Create() declare in Cysharp.Threading.Tasks.CompilerServices.AsyncUniTaskVoidMethodBuilder
bool w_S_oO_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oO_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oO_ (*FuncToCall)(const void* method);
    struct S_oO_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Reflection.CustomAttributeTypedArgument get_TypedValue() declare in System.Reflection.CustomAttributeNamedArgument
bool w_S_oO_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oO_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oO_ (*FuncToCall)(void*,const void* method);
    struct S_oO_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ComponentModel.Design.Serialization.MemberRelationship get_Item(System.Object, System.ComponentModel.MemberDescriptor) declare in System.ComponentModel.Design.Serialization.MemberRelationshipService
bool w_S_oO_tOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oO_tOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_oO_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_oO_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ComponentModel.Design.Serialization.MemberRelationship get_Item(System.ComponentModel.Design.Serialization.MemberRelationship) declare in System.ComponentModel.Design.Serialization.MemberRelationshipService
bool w_S_oO_tS_oO_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oO_tS_oO_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oO_* pp0 = DataTransfer::GetPointer<S_oO_>(apis, env, _sv0);
    S_oO_ p0 = pp0 ? *pp0 : S_oO_ {};

    typedef struct S_oO_ (*FuncToCall)(void*,struct S_oO_ p0, const void* method);
    struct S_oO_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Core.Result`1[JetBrains.Core.Unit] TryExecute(System.Action, Boolean) declare in JetBrains.Lifetimes.Lifetime
bool w_S_oO_toDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oO_toDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_oO_ (*FuncToCall)(void*,Il2CppObject* p0, bool p1, const void* method);
    struct S_oO_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Core.Result`1[JetBrains.Core.Unit] TryBracket(System.Action, System.Action, Boolean) declare in JetBrains.Lifetimes.Lifetime
bool w_S_oO_tooDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oO_tooDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_oO_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, bool p2, const void* method);
    struct S_oO_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[Cysharp.Threading.Tasks.AsyncUnit] AsAsyncUnitUniTask() declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oS__i2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS__i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oS__i2_ (*FuncToCall)(void*,const void* method);
    struct S_oS__i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[UnityEngine.ParticleSystemJobs.ParticleSystemJobData] OnParticleUpdateJobScheduledAsync() declare in Cysharp.Threading.Tasks.Triggers.AsyncParticleUpdateJobScheduledTrigger
bool w_S_oS_i4S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_pi4i4__i2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_i4S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_pi4i4__i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oS_i4S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_pi4i4__i2_ (*FuncToCall)(void*,const void* method);
    struct S_oS_i4S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_pi4i4__i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[UnityEngine.ParticleSystemJobs.ParticleSystemJobData] OnParticleUpdateJobScheduledAsync(System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Triggers.AsyncParticleUpdateJobScheduledTrigger
bool w_S_oS_i4S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_pi4i4__i2_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_i4S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_pi4i4__i2_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_oS_i4S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_pi4i4__i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oS_i4S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__S_Pvi4i4i4S_pi4i4_i4_S_pi4i4__i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Bee.BinLog.NodeInfo get_EnqueuedNode() declare in Bee.BinLog.NodeEnqueuedMessage
bool w_S_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4___t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4___t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4___ (*FuncToCall)(void*,const void* method);
    struct S_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4___ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Decimal] AverageAsync(Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[System.Decimal], System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_S_oS_i4i4i4i4u8_i2_tDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_i4i4i4i4u8_i2_tDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_oS_i4i4i4i4u8_i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oS_i4i4i4i4u8_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.SwitchToSynchronizationContextAwaitable SwitchToSynchronizationContext(System.Threading.SynchronizationContext, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oS_o__oDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_o__oDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_oS_o__ (*FuncToCall)(Il2CppObject* p0, struct S_o_ p1, const void* method);
    struct S_oS_o__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Awaiter GetAwaiter() declare in Cysharp.Threading.Tasks.SwitchToSynchronizationContextAwaitable
bool w_S_oS_o__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_o__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oS_o__ (*FuncToCall)(void*,const void* method);
    struct S_oS_o__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.CancellationTokenRegistration AddTo(System.IDisposable, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.CancellationTokenExtensions
bool w_S_oS_oi4__tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4__tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_oS_oi4__ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oS_oi4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.CancellationTokenRegistration Register(System.Action) declare in System.Threading.CancellationToken
bool w_S_oS_oi4__to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4__to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_oS_oi4__ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_oS_oi4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.CancellationTokenRegistration Register(System.Action`1[System.Object], System.Object) declare in System.Threading.CancellationToken
bool w_S_oS_oi4__toO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4__toO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_oS_oi4__ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_oS_oi4__ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.CancellationTokenRegistration Register(System.Action`1[System.Object], System.Object, Boolean) declare in System.Threading.CancellationToken
bool w_S_oS_oi4__toOb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4__toOb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_oS_oi4__ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, bool p2, const void* method);
    struct S_oS_oi4__ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.CancellationTokenRegistration Register(System.Action`1[System.Object], System.Object, Boolean, Boolean) declare in System.Threading.CancellationToken
bool w_S_oS_oi4__toObb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4__toObb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef struct S_oS_oi4__ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, bool p2, bool p3, const void* method);
    struct S_oS_oi4__ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.CancellationTokenRegistration Register(System.Action, Boolean) declare in System.Threading.CancellationToken
bool w_S_oS_oi4__tob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4__tob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_oS_oi4__ (*FuncToCall)(void*,Il2CppObject* p0, bool p1, const void* method);
    struct S_oS_oi4__ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.ValueTuple`2[System.Single[],System.Int32]] OnAudioFilterReadAsync() declare in Cysharp.Threading.Tasks.Triggers.AsyncAudioFilterReadTrigger
bool w_S_oS_oi4_i2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4_i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oS_oi4_i2_ (*FuncToCall)(void*,const void* method);
    struct S_oS_oi4_i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.ValueTuple`2[System.Single[],System.Int32]] OnAudioFilterReadAsync(System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Triggers.AsyncAudioFilterReadTrigger
bool w_S_oS_oi4_i2_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4_i2_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_oS_oi4_i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oS_oi4_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.ValueTuple`2[UnityEngine.RenderTexture,UnityEngine.RenderTexture]] OnRenderImageAsync() declare in Cysharp.Threading.Tasks.Triggers.AsyncRenderImageTrigger
bool w_S_oS_oo_i2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oo_i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oS_oo_i2_ (*FuncToCall)(void*,const void* method);
    struct S_oS_oo_i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.ValueTuple`2[UnityEngine.RenderTexture,UnityEngine.RenderTexture]] OnRenderImageAsync(System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Triggers.AsyncRenderImageTrigger
bool w_S_oS_oo_i2_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oo_i2_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_oS_oo_i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oS_oo_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.CompilerServices.AsyncVoidMethodBuilder Create() declare in System.Runtime.CompilerServices.AsyncVoidMethodBuilder
bool w_S_oS_oo_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oo_o_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oS_oo_o_ (*FuncToCall)(const void* method);
    struct S_oS_oo_o_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[UnityEngine.Rendering.AsyncGPUReadbackRequest] ToUniTask(UnityEngine.Rendering.AsyncGPUReadbackRequest, Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_oS_pi4_i2_tDi4DS_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_pi4_i2_tDi4DS_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_oS_pi4_i2_ (*FuncToCall)(void*,int32_t p0, struct S_o_ p1, bool p2, const void* method);
    struct S_oS_pi4_i2_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[UnityEngine.Rendering.AsyncGPUReadbackRequest] WithCancellation(UnityEngine.Rendering.AsyncGPUReadbackRequest, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_oS_pi4_i2_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_pi4_i2_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_oS_pi4_i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oS_pi4_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[UnityEngine.Rendering.AsyncGPUReadbackRequest] WithCancellation(UnityEngine.Rendering.AsyncGPUReadbackRequest, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_oS_pi4_i2_tS_o_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_pi4_i2_tS_o_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_oS_pi4_i2_ (*FuncToCall)(void*,struct S_o_ p0, bool p1, const void* method);
    struct S_oS_pi4_i2_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[UnityEngine.Vector2] OnValueChangedAsync(UnityEngine.UI.ScrollRect) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_oS_r4r4_i2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_r4r4_i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oS_r4r4_i2_ (*FuncToCall)(void*,const void* method);
    struct S_oS_r4r4_i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[UnityEngine.Vector2] OnValueChangedAsync(UnityEngine.UI.ScrollRect, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_oS_r4r4_i2_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_r4r4_i2_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_oS_r4r4_i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oS_r4r4_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Cursor get_value() declare in UnityEngine.UIElements.StyleCursor
bool w_S_oS_r4r4_i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_r4r4_i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oS_r4r4_i4_ (*FuncToCall)(void*,const void* method);
    struct S_oS_r4r4_i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Rendering.LightUnitSliderUIRange CautionRange(System.String, Single) declare in UnityEditor.Rendering.LightUnitSliderUIRange
bool w_S_oS_r4r4_r4_sr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_r4r4_r4_sr4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_oS_r4r4_r4_ (*FuncToCall)(Il2CppString* p0, float p1, const void* method);
    struct S_oS_r4r4_r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.TextGenerationSettings GetGenerationSettings(UnityEngine.Vector2) declare in UnityEngine.UI.Text
bool w_S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_b_tS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_b_tS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_b_ (*FuncToCall)(void*,struct S_r4r4_ p0, const void* method);
    struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_b_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.ValueTuple`3[System.String,System.Int32,System.Int32]] OnEndTextSelectionAsync(TMPro.TMP_InputField) declare in Cysharp.Threading.Tasks.TextMeshProAsyncExtensions
bool w_S_oS_si4i4_i2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_si4i4_i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oS_si4i4_i2_ (*FuncToCall)(void*,const void* method);
    struct S_oS_si4i4_i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.ValueTuple`3[System.String,System.Int32,System.Int32]] OnEndTextSelectionAsync(TMPro.TMP_InputField, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.TextMeshProAsyncExtensions
bool w_S_oS_si4i4_i2_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_si4i4_i2_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_oS_si4i4_i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oS_si4i4_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.CancellationToken get_None() declare in System.Threading.CancellationToken
bool w_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_o_ (*FuncToCall)(const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlGuid op_Implicit(System.Guid) declare in System.Data.SqlTypes.SqlGuid
bool w_S_o_S_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef struct S_o_ (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBinary op_Explicit(System.Data.SqlTypes.SqlGuid) declare in System.Data.SqlTypes.SqlBinary
bool w_S_o_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_o_ (*FuncToCall)(struct S_o_ p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBinary op_Addition(System.Data.SqlTypes.SqlBinary, System.Data.SqlTypes.SqlBinary) declare in System.Data.SqlTypes.SqlBinary
bool w_S_o_S_o_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_S_o_S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};

    typedef struct S_o_ (*FuncToCall)(struct S_o_ p0, struct S_o_ p1, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlGuid op_Explicit(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlGuid
bool w_S_o_S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_S_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef struct S_o_ (*FuncToCall)(struct S_soi4i4b_ p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Lifetimes.Lifetime Intersect(JetBrains.Lifetimes.Lifetime[]) declare in JetBrains.Lifetimes.Lifetime
bool w_S_o_VS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_VS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, true)) return false;
    }
    
    // JSValToCSVal valuetype params
    Il2CppArray* p0 = Params<S_o_>::PackValueType(apis, env, info, TIp0, js_args_len, 0);
                

    typedef struct S_o_ (*FuncToCall)(Il2CppArray* p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.LockHolder Hold(System.Threading.Lock) declare in System.Threading.LockHolder
bool w_S_o_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_o_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// TypeCollection GetTypesDerivedFrom(System.Type, System.String) declare in UnityEditor.TypeCache
bool w_S_o_os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_o_ (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlGuid Parse(System.String) declare in System.Data.SqlTypes.SqlGuid
bool w_S_o_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_o_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.CancellationToken get_CancellationToken() declare in System.OperationCanceledException
bool w_S_o_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_o_ (*FuncToCall)(void*,const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Lifetimes.Lifetime AssertEverTerminated(System.String) declare in JetBrains.Lifetimes.Lifetime
bool w_S_o_tDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_tDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal string  with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_o_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Lifetimes.Lifetime KeepAlive(System.Object) declare in JetBrains.Lifetimes.Lifetime
bool w_S_o_tO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_tO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_o_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraphExecution RecordAndExecute(UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraphParameters ByRef) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_S_o_tPS_si4bS_pS_pi4i4__o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_tPS_si4bS_pS_pi4i4__o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_si4bS_pS_pi4i4__o_* p0 = DataTransfer::GetPointer<S_si4bS_pS_pi4i4__o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_si4bS_pS_pi4i4__o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_si4bS_pS_pi4i4__o_));
        p0 = &up0;
    }
        

    typedef struct S_o_ (*FuncToCall)(void*,struct S_si4bS_pS_pi4i4__o_* p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.CancellationToken Timeout(System.TimeSpan) declare in Cysharp.Threading.Tasks.TimeoutController
bool w_S_o_tS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_tS_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};

    typedef struct S_o_ (*FuncToCall)(void*,struct S_i8_ p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Lifetimes.Lifetime CreateTerminatedAfter(System.TimeSpan, System.Threading.Tasks.TaskScheduler) declare in JetBrains.Lifetimes.Lifetime
bool w_S_o_tS_i8_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_tS_i8_Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef struct S_o_ (*FuncToCall)(void*,struct S_i8_ p0, Il2CppObject* p1, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBinary Adjust(System.Data.SqlTypes.SqlBinary) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_o_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_o_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBinary GetSqlBinary(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_o_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_o_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Lifetimes.Lifetime OnTermination(System.Action) declare in JetBrains.Lifetimes.Lifetime
bool w_S_o_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_o_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Lifetimes.Lifetime AddBracket(System.Action, System.Action) declare in JetBrains.Lifetimes.Lifetime
bool w_S_o_too(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_too");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_o_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.ReturnToSynchronizationContext ReturnToCurrentSynchronizationContext(Boolean, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_obS_o__DbDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_obS_o__DbDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_obS_o__ (*FuncToCall)(bool p0, struct S_o_ p1, const void* method);
    struct S_obS_o__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.ReturnToSynchronizationContext ReturnToSynchronizationContext(System.Threading.SynchronizationContext, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_obS_o__oDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_obS_o__oDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_obS_o__ (*FuncToCall)(Il2CppObject* p0, struct S_o_ p1, const void* method);
    struct S_obS_o__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Awaiter DisposeAsync() declare in Cysharp.Threading.Tasks.ReturnToSynchronizationContext
bool w_S_obS_o__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_obS_o__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_obS_o__ (*FuncToCall)(void*,const void* method);
    struct S_obS_o__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// ConfiguredTaskAwaiter GetAwaiter() declare in System.Runtime.CompilerServices.ConfiguredTaskAwaitable
bool w_S_ob_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ob_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_ob_ (*FuncToCall)(void*,const void* method);
    struct S_ob_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RayTracingInstanceCullingResults CullInstances(UnityEngine.Experimental.Rendering.RayTracingInstanceCullingConfig ByRef) declare in UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure
bool w_S_ob_tPS_i4S_r4r4r4_r4ooS_oo_S_i4i4oo_S_i4i4oo_S_i4i4i4_S_obbb_S_i4S_r4r4r4_r4r4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ob_tPS_i4S_r4r4r4_r4ooS_oo_S_i4i4oo_S_i4i4oo_S_i4i4i4_S_obbb_S_i4S_r4r4r4_r4r4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4S_r4r4r4_r4ooS_oo_S_i4i4oo_S_i4i4oo_S_i4i4i4_S_obbb_S_i4S_r4r4r4_r4r4i4__* p0 = DataTransfer::GetPointer<S_i4S_r4r4r4_r4ooS_oo_S_i4i4oo_S_i4i4oo_S_i4i4i4_S_obbb_S_i4S_r4r4r4_r4r4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4S_r4r4r4_r4ooS_oo_S_i4i4oo_S_i4i4oo_S_i4i4i4_S_obbb_S_i4S_r4r4r4_r4r4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4S_r4r4r4_r4ooS_oo_S_i4i4oo_S_i4i4oo_S_i4i4i4_S_obbb_S_i4S_r4r4r4_r4r4i4__));
        p0 = &up0;
    }
        

    typedef struct S_ob_ (*FuncToCall)(void*,struct S_i4S_r4r4r4_r4ooS_oo_S_i4i4oo_S_i4i4oo_S_i4i4i4_S_obbb_S_i4S_r4r4r4_r4r4i4__* p0, const void* method);
    struct S_ob_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.CompilerServices.ConfiguredAsyncDisposable ConfigureAwait(System.IAsyncDisposable, Boolean) declare in System.Threading.Tasks.TaskAsyncEnumerableExtensions
bool w_S_ob_tb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ob_tb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_ob_ (*FuncToCall)(void*,bool p0, const void* method);
    struct S_ob_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// ExecuteIfAliveCookie UsingExecuteIfAlive(Boolean) declare in JetBrains.Lifetimes.Lifetime
bool w_S_obbb_tDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_obbb_tDb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_obbb_ (*FuncToCall)(void*,bool p0, const void* method);
    struct S_obbb_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Boolean] SuppressCancellationThrow() declare in Cysharp.Threading.Tasks.UniTask
bool w_S_obi2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_obi2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_obi2_ (*FuncToCall)(void*,const void* method);
    struct S_obi2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Boolean] TimeoutWithoutException(Cysharp.Threading.Tasks.UniTask, System.TimeSpan, Cysharp.Threading.Tasks.DelayType, Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationTokenSource) declare in Cysharp.Threading.Tasks.UniTaskExtensions
bool w_S_obi2_tS_i8_Di4Di4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_obi2_tS_i8_Di4Di4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                

    typedef struct S_obi2_ (*FuncToCall)(void*,struct S_i8_ p0, int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    struct S_obi2_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Boolean] OnValueChangedAsync(UnityEngine.UI.Toggle, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_obi2_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_obi2_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_obi2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_obi2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Timeline.ClipDrawOptions GetClipOptions(UnityEngine.Timeline.TimelineClip) declare in UnityEditor.Timeline.ClipEditor
bool w_S_obsbsS_r4r4r4r4__to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_obsbsS_r4r4r4r4__to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_obsbsS_r4r4r4r4__ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_obsbsS_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask NextFrame() declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oi2_ (*FuncToCall)(const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask FromCanceled(System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_oi2_ (*FuncToCall)(struct S_o_ p0, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask Delay(System.TimeSpan, Boolean, Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_S_i8_DbDi4DS_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_S_i8_DbDi4DS_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal valuetype  with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef struct S_oi2_ (*FuncToCall)(struct S_i8_ p0, bool p1, int32_t p2, struct S_o_ p3, bool p4, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask Delay(System.TimeSpan, Cysharp.Threading.Tasks.DelayType, Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_S_i8_i4Di4DS_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_S_i8_i4Di4DS_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal valuetype  with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef struct S_oi2_ (*FuncToCall)(struct S_i8_ p0, int32_t p1, int32_t p2, struct S_o_ p3, bool p4, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask Never(System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_oi2_ (*FuncToCall)(struct S_o_ p0, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask Yield(System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_S_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_S_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_oi2_ (*FuncToCall)(struct S_o_ p0, bool p1, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask WaitUntilCanceled(System.Threading.CancellationToken, Cysharp.Threading.Tasks.PlayerLoopTiming, Boolean) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_S_o_Di4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_S_o_Di4Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_oi2_ (*FuncToCall)(struct S_o_ p0, int32_t p1, bool p2, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask WhenAll(Cysharp.Threading.Tasks.UniTask[]) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_VS_oi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_VS_oi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, true)) return false;
    }
    
    // JSValToCSVal valuetype params
    Il2CppArray* p0 = Params<S_oi2_>::PackValueType(apis, env, info, TIp0, js_args_len, 0);
                

    typedef struct S_oi2_ (*FuncToCall)(Il2CppArray* p0, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask NextFrame(Cysharp.Threading.Tasks.PlayerLoopTiming) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_oi2_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask WaitForSeconds(Int32, Boolean, Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_i4DbDi4DS_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_i4DbDi4DS_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal valuetype  with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef struct S_oi2_ (*FuncToCall)(int32_t p0, bool p1, int32_t p2, struct S_o_ p3, bool p4, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask DelayFrame(Int32, Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_i4Di4DS_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_i4Di4DS_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal valuetype  with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_oi2_ (*FuncToCall)(int32_t p0, int32_t p1, struct S_o_ p2, bool p3, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask Yield(Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_i4S_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_i4S_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_oi2_ (*FuncToCall)(int32_t p0, struct S_o_ p1, bool p2, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask Delay(Int32, Cysharp.Threading.Tasks.DelayType, Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_i4i4Di4DS_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_i4i4Di4DS_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal valuetype  with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef struct S_oi2_ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, struct S_o_ p3, bool p4, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask WaitForEndOfFrame(UnityEngine.MonoBehaviour) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_oi2_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask Run(System.Action, Boolean, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_oDbDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_oDbDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal valuetype  with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_oi2_ (*FuncToCall)(Il2CppObject* p0, bool p1, struct S_o_ p2, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask WaitUntil(System.Func`1[System.Boolean], Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_oDi4DS_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_oDi4DS_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal valuetype  with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_oi2_ (*FuncToCall)(Il2CppObject* p0, int32_t p1, struct S_o_ p2, bool p3, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask Run(System.Action`1[System.Object], System.Object, Boolean, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_oODbDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_oODbDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal valuetype  with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_oi2_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, struct S_o_ p3, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask Create(System.Func`2[System.Threading.CancellationToken,Cysharp.Threading.Tasks.UniTask], System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_oS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_oS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};

    typedef struct S_oi2_ (*FuncToCall)(Il2CppObject* p0, struct S_o_ p1, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask WaitForEndOfFrame(UnityEngine.MonoBehaviour, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_oS_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_oS_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_oi2_ (*FuncToCall)(Il2CppObject* p0, struct S_o_ p1, bool p2, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask WaitForSeconds(Single, Boolean, Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi2_r4DbDi4DS_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_r4DbDi4DS_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal valuetype  with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef struct S_oi2_ (*FuncToCall)(float p0, bool p1, int32_t p2, struct S_o_ p3, bool p4, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask get_Task() declare in Cysharp.Threading.Tasks.AsyncLazy
bool w_S_oi2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oi2_ (*FuncToCall)(void*,const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask AsUniTask(System.Threading.Tasks.Task, Boolean) declare in Cysharp.Threading.Tasks.UniTaskExtensions
bool w_S_oi2_tDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_tDb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_oi2_ (*FuncToCall)(void*,bool p0, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask ToUniTask(System.Collections.IEnumerator, Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.EnumeratorAsyncExtensions
bool w_S_oi2_tDi4DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_tDi4DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_oi2_ (*FuncToCall)(void*,int32_t p0, struct S_o_ p1, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask ToUniTask(UnityEngine.AsyncOperation, System.IProgress`1[System.Single], Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_oi2_tDoDi4DS_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_tDoDi4DS_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal ref  with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 0, TIp0);
                
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal valuetype  with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_oi2_ (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, struct S_o_ p2, bool p3, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask Timeout(Cysharp.Threading.Tasks.UniTask, System.TimeSpan, Cysharp.Threading.Tasks.DelayType, Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationTokenSource) declare in Cysharp.Threading.Tasks.UniTaskExtensions
bool w_S_oi2_tS_i8_Di4Di4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_tS_i8_Di4Di4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                

    typedef struct S_oi2_ (*FuncToCall)(void*,struct S_i8_ p0, int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask WithCancellation(System.Collections.IEnumerator, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.EnumeratorAsyncExtensions
bool w_S_oi2_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_oi2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask WithCancellation(UnityEngine.AsyncOperation, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_oi2_tS_o_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_tS_o_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_oi2_ (*FuncToCall)(void*,struct S_o_ p0, bool p1, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask Unwrap(System.Threading.Tasks.Task`1[Cysharp.Threading.Tasks.UniTask], Boolean) declare in Cysharp.Threading.Tasks.UniTaskExtensions
bool w_S_oi2_tb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_tb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_oi2_ (*FuncToCall)(void*,bool p0, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask ToUniTask(Unity.Jobs.JobHandle, Cysharp.Threading.Tasks.PlayerLoopTiming) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_oi2_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_oi2_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask WaitAsync(Unity.Jobs.JobHandle, Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_oi2_ti4DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_ti4DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_oi2_ (*FuncToCall)(void*,int32_t p0, struct S_o_ p1, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask ToUniTask(System.Collections.IEnumerator, UnityEngine.MonoBehaviour) declare in Cysharp.Threading.Tasks.EnumeratorAsyncExtensions
bool w_S_oi2_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi2_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_oi2_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_oi2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Selection GetSelection() declare in UnityEditor.Rendering.InspectorCurveEditor
bool w_S_oi4N_bS_r4r4r4r4i4i4r4r4___t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4N_bS_r4r4r4r4i4i4r4r4___t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oi4N_bS_r4r4r4r4i4i4r4r4___ (*FuncToCall)(void*,const void* method);
    struct S_oi4N_bS_r4r4r4r4i4i4r4r4___ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cookie NewThreadLocalWriter() declare in JetBrains.Serialization.UnsafeWriter
bool w_S_oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oi4_ (*FuncToCall)(const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonElement SerializeToElement(System.Object, System.Text.Json.Serialization.Metadata.JsonTypeInfo) declare in System.Text.Json.JsonSerializer
bool w_S_oi4_Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_Oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_oi4_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonElement SerializeToElement(System.Object, System.Type, System.Text.Json.JsonSerializerOptions) declare in System.Text.Json.JsonSerializer
bool w_S_oi4_OoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_OoDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef struct S_oi4_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonElement SerializeToElement(System.Object, System.Type, System.Text.Json.Serialization.JsonSerializerContext) declare in System.Text.Json.JsonSerializer
bool w_S_oi4_Ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_Ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_oi4_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonElement ParseValue(System.Text.Json.Utf8JsonReader ByRef) declare in System.Text.Json.JsonElement
bool w_S_oi4_PS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_PS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0 = DataTransfer::GetPointer<S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__));
        p0 = &up0;
    }
        

    typedef struct S_oi4_ (*FuncToCall)(struct S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonElement TransformSchema(System.Text.Json.JsonElement, Microsoft.Extensions.AI.AIJsonSchemaTransformOptions) declare in Microsoft.Extensions.AI.AIJsonUtilities
bool w_S_oi4_S_oi4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_S_oi4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_oi4_* pp0 = DataTransfer::GetPointer<S_oi4_>(apis, env, _sv0);
    S_oi4_ p0 = pp0 ? *pp0 : S_oi4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_oi4_ (*FuncToCall)(struct S_oi4_ p0, Il2CppObject* p1, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleFont op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleFont
bool w_S_oi4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_oi4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleFont op_Implicit(UnityEngine.Font) declare in UnityEngine.UIElements.StyleFont
bool w_S_oi4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_oi4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonElement CreateJsonSchema(System.Type, System.String, Boolean, System.Object, System.Text.Json.JsonSerializerOptions, Microsoft.Extensions.AI.AIJsonSchemaCreateOptions) declare in Microsoft.Extensions.AI.AIJsonUtilities
bool w_S_oi4_oDsDbDODoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_oDsDbDODoDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 5, TIp5);
                

    typedef struct S_oi4_ (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonElement CreateFunctionJsonSchema(System.Reflection.MethodBase, System.String, System.String, System.Text.Json.JsonSerializerOptions, Microsoft.Extensions.AI.AIJsonSchemaCreateOptions) declare in Microsoft.Extensions.AI.AIJsonUtilities
bool w_S_oi4_oDsDsDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_oDsDsDoDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                

    typedef struct S_oi4_ (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Net.Sockets.IPPacketInformation get_ReceiveMessageFromPacketInfo() declare in System.Net.Sockets.SocketAsyncEventArgs
bool w_S_oi4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oi4_ (*FuncToCall)(void*,const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonElement GetProperty(System.ReadOnlySpan`1[System.Char]) declare in System.Text.Json.JsonElement
bool w_S_oi4_tS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_tS_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef struct S_oi4_ (*FuncToCall)(void*,struct S_S_p_i4_ p0, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonElement get_Item(Int32) declare in System.Text.Json.JsonElement
bool w_S_oi4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_oi4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonElement GetOrCreateTransformedSchema(Microsoft.Extensions.AI.AIFunction) declare in Microsoft.Extensions.AI.AIJsonSchemaTransformCache
bool w_S_oi4_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_oi4_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonElement GetProperty(System.String) declare in System.Text.Json.JsonElement
bool w_S_oi4_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_oi4_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Int32] WhenAny(Cysharp.Threading.Tasks.UniTask[]) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi4i2_VS_oi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i2_VS_oi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, true)) return false;
    }
    
    // JSValToCSVal valuetype params
    Il2CppArray* p0 = Params<S_oi2_>::PackValueType(apis, env, info, TIp0, js_args_len, 0);
                

    typedef struct S_oi4i2_ (*FuncToCall)(Il2CppArray* p0, const void* method);
    struct S_oi4i2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Int32] WhenAny(System.Collections.Generic.IEnumerable`1[Cysharp.Threading.Tasks.UniTask]) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_oi4i2_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i2_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_oi4i2_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_oi4i2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Int32] OnValueChangedAsync(UnityEngine.UI.Dropdown) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_oi4i2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oi4i2_ (*FuncToCall)(void*,const void* method);
    struct S_oi4i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Int32] MinAsync(Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[System.Int32], System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_S_oi4i2_tDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i2_tDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_oi4i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oi4i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Int32] OnValueChangedAsync(UnityEngine.UI.Dropdown, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_oi4i2_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i2_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_oi4i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oi4i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ArraySegment`1[System.Byte] CreateServerBuffer(Int32) declare in System.Net.WebSockets.WebSocket
bool w_S_oi4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_oi4i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_oi4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ArraySegment`1[System.Byte] CreateClientBuffer(Int32, Int32) declare in System.Net.WebSockets.WebSocket
bool w_S_oi4i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_oi4i4_ (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    struct S_oi4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.TestTools.CoveredMethodStats GetStatsFor(System.Reflection.MethodBase) declare in UnityEngine.TestTools.Coverage
bool w_S_oi4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_oi4i4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_oi4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.ShaderGraph.Internal.ShaderGraphRequirements GetRequirements() declare in UnityEditor.ShaderGraph.PositionControl
bool w_S_oi4i4i4i4i4i4bbbbbobbbbb_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4i4i4i4i4bbbbbobbbbb_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oi4i4i4i4i4i4bbbbbobbbbb_ (*FuncToCall)(void*,const void* method);
    struct S_oi4i4i4i4i4i4bbbbbobbbbb_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Net.Sockets.SocketInformation DuplicateAndClose(Int32) declare in System.Net.Sockets.Socket
bool w_S_oi4o_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4o_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_oi4o_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_oi4o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Enumerator GetEnumerator() declare in Microsoft.Extensions.Primitives.StringValues
bool w_S_oi4s_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4s_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oi4s_ (*FuncToCall)(void*,const void* method);
    struct S_oi4s_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Content ReadWorkspaceContentForTesting(System.String, Codice.CM.WorkspaceServer.IWorkspaceRevisionInfoCache, Codice.Utils.Buffers.FlexibleBufferPool) declare in Codice.CM.WorkspaceServer.WorkspaceTreeDataStore
bool w_S_oi8_soo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi8_soo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_oi8_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_oi8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Int64] MinAsync(Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[System.Int64], System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_S_oi8i2_tDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi8i2_tDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_oi8i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_oi8i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.CompilerServices.AsyncUniTaskMethodBuilder Create() declare in Cysharp.Threading.Tasks.CompilerServices.AsyncUniTaskMethodBuilder
bool w_S_ooO_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooO_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_ooO_ (*FuncToCall)(const void* method);
    struct S_ooO_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Security.Cryptography.ECCurve CreateFromOid(System.Security.Cryptography.Oid) declare in System.Security.Cryptography.ECCurve
bool w_S_ooS_oo_oooi4N_bS_s__ooo_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooS_oo_oooi4N_bS_s__ooo_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_ooS_oo_oooi4N_bS_s__ooo_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_ooS_oo_oooi4N_bS_s__ooo_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Security.Cryptography.ECCurve CreateFromFriendlyName(System.String) declare in System.Security.Cryptography.ECCurve
bool w_S_ooS_oo_oooi4N_bS_s__ooo_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooS_oo_oooi4N_bS_s__ooo_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_ooS_oo_oooi4N_bS_s__ooo_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_ooS_oo_oooi4N_bS_s__ooo_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Mono.Unix.UnixPipes CreatePipes() declare in Mono.Unix.UnixPipes
bool w_S_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oo_ (*FuncToCall)(const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Player.ScriptCompilationResult CompilePlayerScripts(UnityEditor.Build.Player.ScriptCompilationSettings, System.String) declare in UnityEditor.Build.Player.PlayerBuildInterface
bool w_S_oo_S_i4i4i4i4oo_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_S_i4i4i4i4oo_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4oo_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4oo_>(apis, env, _sv0);
    S_i4i4i4i4oo_ p0 = pp0 ? *pp0 : S_i4i4i4i4oo_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_oo_ (*FuncToCall)(struct S_i4i4i4i4oo_ p0, Il2CppString* p1, const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.AssetIndexChangeSet GetDiff(Int64, System.Collections.Generic.IEnumerable`1[System.String], System.Func`2[System.String,System.Boolean]) declare in UnityEditor.Search.SearchMonitor
bool w_S_oo_i8oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_i8oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_oo_ (*FuncToCall)(int64_t p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.FontDefinition FromFont(UnityEngine.Font) declare in UnityEngine.UIElements.FontDefinition
bool w_S_oo_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_oo_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Info GetLinkInfo(Codice.CM.Common.WorkspaceInfo, PlasticGui.IPlasticAPI) declare in PlasticGui.WorkspaceWindow.Merge.MergeInProgress
bool w_S_oo_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_oo_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.FontDefinition get_value() declare in UnityEngine.UIElements.StyleFontDefinition
bool w_S_oo_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oo_ (*FuncToCall)(void*,const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Rd.SerializationCtx WithInternRootsHere(JetBrains.Rd.Base.RdBindableBase, System.String[]) declare in JetBrains.Rd.SerializationCtx
bool w_S_oo_toVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_toVs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, js_args_len, 1);
                

    typedef struct S_oo_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppArray* p1, const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Timeline.SequenceContext GetCurrentContext() declare in UnityEditor.Timeline.TimelineNavigator
bool w_S_oob_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oob_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oob_ (*FuncToCall)(void*,const void* method);
    struct S_oob_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.SearchMonitorView GetView(Boolean) declare in UnityEditor.Search.SearchMonitor
bool w_S_oobb_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oobb_Db");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_oobb_ (*FuncToCall)(bool p0, const void* method);
    struct S_oobb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[UnityEngine.Collision] OnCollisionEnterAsync() declare in Cysharp.Threading.Tasks.Triggers.AsyncCollisionEnterTrigger
bool w_S_ooi2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooi2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_ooi2_ (*FuncToCall)(void*,const void* method);
    struct S_ooi2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[UnityEngine.Object[]] AwaitForAllAssets(UnityEngine.AssetBundleRequest, System.IProgress`1[System.Single], Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_ooi2_tDoDi4DS_o_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooi2_tDoDi4DS_o_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal ref  with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 0, TIp0);
                
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal valuetype  with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_ooi2_ (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, struct S_o_ p2, bool p3, const void* method);
    struct S_ooi2_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[UnityEngine.Object[]] AwaitForAllAssets(UnityEngine.AssetBundleRequest, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_ooi2_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooi2_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_ooi2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_ooi2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[UnityEngine.Object[]] AwaitForAllAssets(UnityEngine.AssetBundleRequest, System.Threading.CancellationToken, Boolean) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_ooi2_tS_o_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooi2_tS_o_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_ooi2_ (*FuncToCall)(void*,struct S_o_ p0, bool p1, const void* method);
    struct S_ooi2_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AI.NavMeshTriangulation CalculateTriangulation() declare in UnityEngine.AI.NavMesh
bool w_S_ooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooo_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_ooo_ (*FuncToCall)(const void* method);
    struct S_ooo_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.GameManagerDependencyInfo CalculatePlayerDependenciesForGameManagers(UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_ooo_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooo_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp0 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv0);
    S_oS_i4i4i4i4_i4i4_ p0 = pp0 ? *pp0 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(apis, env, _sv1);
    S_u4u4u4u4u4bbbbbbb_ p1 = pp1 ? *pp1 : S_u4u4u4u4u4bbbbbbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_ooo_ (*FuncToCall)(struct S_oS_i4i4i4i4_i4i4_ p0, struct S_u4u4u4u4u4bbbbbbb_ p1, Il2CppObject* p2, const void* method);
    struct S_ooo_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.GameManagerDependencyInfo CalculatePlayerDependenciesForGameManagers(UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildUsageCache) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_ooo_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooo_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp0 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv0);
    S_oS_i4i4i4i4_i4i4_ p0 = pp0 ? *pp0 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(apis, env, _sv1);
    S_u4u4u4u4u4bbbbbbb_ p1 = pp1 ? *pp1 : S_u4u4u4u4u4bbbbbbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef struct S_ooo_ (*FuncToCall)(struct S_oS_i4i4i4i4_i4i4_ p0, struct S_u4u4u4u4u4bbbbbbb_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_ooo_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.GameManagerDependencyInfo CalculatePlayerDependenciesForGameManagers(UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildUsageCache, UnityEditor.Build.Content.DependencyType) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_ooo_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_ooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooo_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_ooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp0 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv0);
    S_oS_i4i4i4i4_i4i4_ p0 = pp0 ? *pp0 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(apis, env, _sv1);
    S_u4u4u4u4u4bbbbbbb_ p1 = pp1 ? *pp1 : S_u4u4u4u4u4bbbbbbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef struct S_ooo_ (*FuncToCall)(struct S_oS_i4i4i4i4_i4i4_ p0, struct S_u4u4u4u4u4bbbbbbb_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, const void* method);
    struct S_ooo_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Mono.Security.Cryptography.DHParameters ExportParameters(Boolean) declare in Mono.Security.Cryptography.DiffieHellmanManaged
bool w_S_ooo_tb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooo_tb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_ooo_ (*FuncToCall)(void*,bool p0, const void* method);
    struct S_ooo_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// FullscreenEditor.ViewPyramid get_ActualViewPyramid() declare in FullscreenEditor.FullscreenContainer
bool w_S_oooi4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooi4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oooi4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_oooi4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Background FromTexture2D(UnityEngine.Texture2D) declare in UnityEngine.UIElements.Background
bool w_S_oooo_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooo_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_oooo_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_oooo_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Background get_icon() declare in UnityEngine.UIElements.Column
bool w_S_oooo_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooo_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oooo_ (*FuncToCall)(void*,const void* method);
    struct S_oooo_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Reflection.InterfaceMapping GetInterfaceMap(System.Type) declare in System.Type
bool w_S_oooo_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooo_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_oooo_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_oooo_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.UQueryBuilder`1[UnityEngine.UIElements.VisualElement] Query(UnityEngine.UIElements.VisualElement) declare in UnityEngine.UIElements.UQueryExtensions
bool w_S_ooooi4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooi4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_ooooi4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_ooooi4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.UQueryBuilder`1[UnityEngine.UIElements.VisualElement] Query(UnityEngine.UIElements.VisualElement, System.String, System.String) declare in UnityEngine.UIElements.UQueryExtensions
bool w_S_ooooi4i4i4_tDsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooi4i4i4_tDsDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal string  with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 0);
                
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_ooooi4i4i4_ (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, const void* method);
    struct S_ooooi4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.UQueryBuilder`1[UnityEngine.UIElements.VisualElement] Query(UnityEngine.UIElements.VisualElement, System.String, System.String[]) declare in UnityEngine.UIElements.UQueryExtensions
bool w_S_ooooi4i4i4_tDsVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooi4i4i4_tDsVs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal string  with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 0);
                
    // JSValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, js_args_len, 1);
                

    typedef struct S_ooooi4i4i4_ (*FuncToCall)(void*,Il2CppString* p0, Il2CppArray* p1, const void* method);
    struct S_ooooi4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.WriteResult WriteGameManagersSerializedFile(System.String, UnityEditor.Build.Content.WriteManagerParameters) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_ooooo_sS_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooo_sS_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_o_* pp1 = DataTransfer::GetPointer<S_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_o_>(apis, env, _sv1);
    S_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_o_ p1 = pp1 ? *pp1 : S_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_o_ {};

    typedef struct S_ooooo_ (*FuncToCall)(Il2CppString* p0, struct S_S_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_o_ p1, const void* method);
    struct S_ooooo_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.WriteResult WriteSerializedFile(System.String, UnityEditor.Build.Content.WriteParameters) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_ooooo_sS_oS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooo_sS_oS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_oS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_* pp1 = DataTransfer::GetPointer<S_oS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_>(apis, env, _sv1);
    S_oS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_ p1 = pp1 ? *pp1 : S_oS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_ {};

    typedef struct S_ooooo_ (*FuncToCall)(Il2CppString* p0, struct S_oS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_ p1, const void* method);
    struct S_ooooo_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.WriteResult WriteSceneSerializedFile(System.String, UnityEditor.Build.Content.WriteSceneParameters) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_ooooo_sS_soS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooo_sS_soS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_soS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_* pp1 = DataTransfer::GetPointer<S_soS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_>(apis, env, _sv1);
    S_soS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_ p1 = pp1 ? *pp1 : S_soS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_ {};

    typedef struct S_ooooo_ (*FuncToCall)(Il2CppString* p0, struct S_soS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo_ p1, const void* method);
    struct S_ooooo_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.WriteResult WriteSerializedFile(System.String, UnityEditor.Build.Content.WriteCommand, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildReferenceMap) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_ooooo_soS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooo_soS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp2 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv2);
    S_oS_i4i4i4i4_i4i4_ p2 = pp2 ? *pp2 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp3 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(apis, env, _sv3);
    S_u4u4u4u4u4bbbbbbb_ p3 = pp3 ? *pp3 : S_u4u4u4u4u4bbbbbbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef struct S_ooooo_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, struct S_oS_i4i4i4i4_i4i4_ p2, struct S_u4u4u4u4u4bbbbbbb_ p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    struct S_ooooo_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.WriteResult WriteSerializedFile(System.String, UnityEditor.Build.Content.WriteCommand, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildReferenceMap, UnityEditor.Build.Content.AssetBundleInfo) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_ooooo_soS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooo_soS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp2 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv2);
    S_oS_i4i4i4i4_i4i4_ p2 = pp2 ? *pp2 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp3 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(apis, env, _sv3);
    S_u4u4u4u4u4bbbbbbb_ p3 = pp3 ? *pp3 : S_u4u4u4u4u4bbbbbbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef struct S_ooooo_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, struct S_oS_i4i4i4i4_i4i4_ p2, struct S_u4u4u4u4u4bbbbbbb_ p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    struct S_ooooo_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.WriteResult WriteSceneSerializedFile(System.String, System.String, System.String, UnityEditor.Build.Content.WriteCommand, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildReferenceMap) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_ooooo_sssoS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooo_sssoS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp7 = wrapData->TypeInfos[8];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp4 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv4);
    S_oS_i4i4i4i4_i4i4_ p4 = pp4 ? *pp4 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp5 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(apis, env, _sv5);
    S_u4u4u4u4u4bbbbbbb_ p5 = pp5 ? *pp5 : S_u4u4u4u4u4bbbbbbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef struct S_ooooo_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, struct S_oS_i4i4i4i4_i4i4_ p4, struct S_u4u4u4u4u4bbbbbbb_ p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    struct S_ooooo_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.WriteResult WriteSceneSerializedFile(System.String, System.String, System.String, UnityEditor.Build.Content.WriteCommand, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildReferenceMap, UnityEditor.Build.Content.PreloadInfo) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_ooooo_sssoS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooo_sssoS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp7 = wrapData->TypeInfos[8];
    auto TIp8 = wrapData->TypeInfos[9];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp4 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv4);
    S_oS_i4i4i4i4_i4i4_ p4 = pp4 ? *pp4 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp5 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(apis, env, _sv5);
    S_u4u4u4u4u4bbbbbbb_ p5 = pp5 ? *pp5 : S_u4u4u4u4u4bbbbbbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal o/O
    Il2CppObject* p8 = JsValueToCSRef(apis, TIp8, env, _sv8);

    typedef struct S_ooooo_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, struct S_oS_i4i4i4i4_i4i4_ p4, struct S_u4u4u4u4u4bbbbbbb_ p5, Il2CppObject* p6, Il2CppObject* p7, Il2CppObject* p8, const void* method);
    struct S_ooooo_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.WriteResult WriteSceneSerializedFile(System.String, System.String, System.String, UnityEditor.Build.Content.WriteCommand, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildReferenceMap, UnityEditor.Build.Content.PreloadInfo, UnityEditor.Build.Content.SceneBundleInfo) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_ooooo_sssoS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooo_sssoS_oS_i4i4i4i4_i4i4_S_u4u4u4u4u4bbbbbbb_oooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp7 = wrapData->TypeInfos[8];
    auto TIp8 = wrapData->TypeInfos[9];
    auto TIp9 = wrapData->TypeInfos[10];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (checkJSArgument) {
        if (js_args_len != 10) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv9, TIp9, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp4 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv4);
    S_oS_i4i4i4i4_i4i4_ p4 = pp4 ? *pp4 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp5 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(apis, env, _sv5);
    S_u4u4u4u4u4bbbbbbb_ p5 = pp5 ? *pp5 : S_u4u4u4u4u4bbbbbbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal o/O
    Il2CppObject* p8 = JsValueToCSRef(apis, TIp8, env, _sv8);
    // JSValToCSVal o/O
    Il2CppObject* p9 = JsValueToCSRef(apis, TIp9, env, _sv9);

    typedef struct S_ooooo_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, struct S_oS_i4i4i4i4_i4i4_ p4, struct S_u4u4u4u4u4bbbbbbb_ p5, Il2CppObject* p6, Il2CppObject* p7, Il2CppObject* p8, Il2CppObject* p9, const void* method);
    struct S_ooooo_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Trails GetTrails() declare in UnityEngine.ParticleSystem
bool w_S_oooooi4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooi4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oooooi4i4_ (*FuncToCall)(void*,const void* method);
    struct S_oooooi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Security.Cryptography.DSAParameters ExportParameters(Boolean) declare in System.Security.Cryptography.DSACryptoServiceProvider
bool w_S_oooooooi4_tb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooooi4_tb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_oooooooi4_ (*FuncToCall)(void*,bool p0, const void* method);
    struct S_oooooooi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Security.Cryptography.RSAParameters get_RsaPublicKey() declare in System.Configuration.RsaProtectedConfigurationProvider
bool w_S_oooooooo_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooooo_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oooooooo_ (*FuncToCall)(void*,const void* method);
    struct S_oooooooo_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Security.Cryptography.RSAParameters ExportParameters(Boolean) declare in System.Security.Cryptography.RSACryptoServiceProvider
bool w_S_oooooooo_tb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooooo_tb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_oooooooo_ (*FuncToCall)(void*,bool p0, const void* method);
    struct S_oooooooo_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// RuntimeResources GetRuntimeResources() declare in UnityEngine.Rendering.ProbeReferenceVolume
bool w_S_oooooooooo_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooooooo_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oooooooooo_ (*FuncToCall)(void*,const void* method);
    struct S_oooooooooo_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.LowLevel.PlayerLoopSystem GetDefaultPlayerLoop() declare in UnityEngine.LowLevel.PlayerLoop
bool w_S_ooopp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooopp_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_ooopp_ (*FuncToCall)(const void* method);
    struct S_ooopp_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.EventSystems.RaycastResult get_pointerCurrentRaycast() declare in UnityEngine.EventSystems.PointerEventData
bool w_S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_ (*FuncToCall)(void*,const void* method);
    struct S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.HumanDescription get_humanDescription() declare in UnityEngine.Avatar
bool w_S_oor4r4r4r4r4r4r4r4sbbb_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_oor4r4r4r4r4r4r4r4sbbb_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_oor4r4r4r4r4r4r4r4sbbb_ (*FuncToCall)(void*,const void* method);
    struct S_oor4r4r4r4r4r4r4r4sbbb_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.ConstraintSource GetSource(Int32) declare in UnityEngine.Animations.AimConstraint
bool w_S_or4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_or4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_or4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_or4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Single] OnValueChangedAsync(UnityEngine.UI.Scrollbar) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_or4i2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_or4i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_or4i2_ (*FuncToCall)(void*,const void* method);
    struct S_or4i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Single] AverageAsync(Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[System.Single], System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_S_or4i2_tDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_or4i2_tDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_or4i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_or4i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Single] OnValueChangedAsync(UnityEngine.UI.Scrollbar, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_or4i2_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_or4i2_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_or4i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_or4i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.LookDev.Sky get_sky() declare in UnityEditor.Rendering.LookDev.Environment
bool w_S_or4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_or4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_or4r4_ (*FuncToCall)(void*,const void* method);
    struct S_or4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.Double] AverageAsync(Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[System.Int32], System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_S_or8i2_tDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_or8i2_tDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_or8i2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_or8i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonEncodedText Encode(System.ReadOnlySpan`1[System.Char], System.Text.Encodings.Web.JavaScriptEncoder) declare in System.Text.Json.JsonEncodedText
bool w_S_os_S_S_p_i4_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_os_S_S_p_i4_Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef struct S_os_ (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, const void* method);
    struct S_os_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonEncodedText Encode(System.String, System.Text.Encodings.Web.JavaScriptEncoder) declare in System.Text.Json.JsonEncodedText
bool w_S_os_sDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_os_sDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef struct S_os_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    struct S_os_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.String] OnValueChangedAsync(TMPro.TMP_InputField) declare in Cysharp.Threading.Tasks.TextMeshProAsyncExtensions
bool w_S_osi2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_osi2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_osi2_ (*FuncToCall)(void*,const void* method);
    struct S_osi2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.UniTask`1[System.String] OnValueChangedAsync(TMPro.TMP_InputField, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.TextMeshProAsyncExtensions
bool w_S_osi2_tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_osi2_tS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_osi2_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_osi2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.AssetImporters.TextureGenerationOutput GenerateTexture(UnityEditor.AssetImporters.TextureGenerationSettings, Unity.Collections.NativeArray`1[UnityEngine.Color32]) declare in UnityEditor.AssetImporters.TextureGenerator
bool w_S_osooo_S_sbbooooso_S_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_osooo_S_sbbooooso_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sbbooooso_* pp0 = DataTransfer::GetPointer<S_sbbooooso_>(apis, env, _sv0);
    S_sbbooooso_ p0 = pp0 ? *pp0 : S_sbbooooso_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef struct S_osooo_ (*FuncToCall)(struct S_sbbooooso_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    struct S_osooo_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.BuildPlayerOptions get_BuildPlayerOptions() declare in UnityEditor.Build.BuildPlayerContext
bool w_S_ossi4i4i4i4o_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ossi4i4i4i4o_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_ossi4i4i4i4o_ (*FuncToCall)(void*,const void* method);
    struct S_ossi4i4i4i4o_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.VFX.VFXBatchedEffectInfo GetBatchedEffectInfo(UnityEngine.VFX.VisualEffectAsset) declare in UnityEngine.VFX.VFXManager
bool w_S_ou4u4u4u4u4u4u8u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ou4u4u4u4u4u4u8u8_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_ou4u4u4u4u4u4u8u8_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_ou4u4u4u4u4u4u8u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.CullingResults get_cullingResults() declare in UnityEngine.Rendering.ShadowDrawingSettings
bool w_S_pPvS_pi4i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pPvS_pi4i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_pPvS_pi4i4__ (*FuncToCall)(void*,const void* method);
    struct S_pPvS_pi4i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.CullingResults Cull(UnityEngine.Rendering.ScriptableCullingParameters ByRef) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_S_pPvS_pi4i4__tPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pPvS_pi4i4__tPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* p0 = DataTransfer::GetPointer<S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_));
        p0 = &up0;
    }
        

    typedef struct S_pPvS_pi4i4__ (*FuncToCall)(void*,struct S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* p0, const void* method);
    struct S_pPvS_pi4i4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.AI.NavMeshWorld GetDefaultWorld() declare in UnityEngine.Experimental.AI.NavMeshWorld
bool w_S_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_p_ (*FuncToCall)(const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.RuntimeTypeHandle GetTypeHandle(System.Object) declare in System.Type
bool w_S_p_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_O");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_p_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.InteropServices.GCHandle Alloc(System.Object, System.Runtime.InteropServices.GCHandleType) declare in System.Runtime.InteropServices.GCHandle
bool w_S_p_Oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_Oi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_p_ (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.RuntimeTypeHandle TargetTypeToken(TypedReference) declare in System.TypedReference
bool w_S_p_S_S_p_pp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_S_S_p_pp_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_pp_* pp0 = DataTransfer::GetPointer<S_S_p_pp_>(apis, env, _sv0);
    S_S_p_pp_ p0 = pp0 ? *pp0 : S_S_p_pp_ {};

    typedef struct S_p_ (*FuncToCall)(struct S_S_p_pp_ p0, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.InteropServices.GCHandle op_Explicit(IntPtr) declare in System.Runtime.InteropServices.GCHandle
bool w_S_p_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_p");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef struct S_p_ (*FuncToCall)(void* p0, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.RuntimeTypeHandle get_TypeHandle() declare in System.Type
bool w_S_p_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_p_ (*FuncToCall)(void*,const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.RuntimeFieldHandle ResolveFieldHandle(Int32) declare in System.ModuleHandle
bool w_S_p_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_p_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.RuntimeTypeHandle ResolveTypeHandle(Int32, System.RuntimeTypeHandle[], System.RuntimeTypeHandle[]) declare in System.ModuleHandle
bool w_S_p_ti4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_ti4oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_p_ (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.IO.LowLevel.Unsafe.ReadHandle ReadDeferred(Unity.IO.LowLevel.Unsafe.FileHandle ByRef, Unity.IO.LowLevel.Unsafe.ReadCommandArray*, Unity.Jobs.JobHandle) declare in Unity.IO.LowLevel.Unsafe.AsyncReadManager
bool w_S_pi4_PS_pi4_PvS_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_PS_pi4_PvS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_pi4_* p0 = DataTransfer::GetPointer<S_pi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_pi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_pi4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal struct
    S_u8i4i4p_* pp2 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, _sv2);
    S_u8i4i4p_ p2 = pp2 ? *pp2 : S_u8i4i4p_ {};

    typedef struct S_pi4_ (*FuncToCall)(struct S_pi4_* p0, void* p1, struct S_u8i4i4p_ p2, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.IO.LowLevel.Unsafe.ReadHandle Read(Unity.IO.LowLevel.Unsafe.FileHandle ByRef, Unity.IO.LowLevel.Unsafe.ReadCommandArray) declare in Unity.IO.LowLevel.Unsafe.AsyncReadManager
bool w_S_pi4_PS_pi4_S_Pvi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_PS_pi4_S_Pvi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_pi4_* p0 = DataTransfer::GetPointer<S_pi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_pi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_pi4_));
        p0 = &up0;
    }
        
    // JSValToCSVal struct
    S_Pvi4_* pp1 = DataTransfer::GetPointer<S_Pvi4_>(apis, env, _sv1);
    S_Pvi4_ p1 = pp1 ? *pp1 : S_Pvi4_ {};

    typedef struct S_pi4_ (*FuncToCall)(struct S_pi4_* p0, struct S_Pvi4_ p1, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.Texture, Int32, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest]) declare in UnityEngine.Rendering.AsyncGPUReadback
bool w_S_pi4_oDi4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_oDi4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef struct S_pi4_ (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppObject* p2, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.ComputeBuffer, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest]) declare in UnityEngine.Rendering.AsyncGPUReadback
bool w_S_pi4_oDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_oDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef struct S_pi4_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.ComputeBuffer, Int32, Int32, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest]) declare in UnityEngine.Rendering.AsyncGPUReadback
bool w_S_pi4_oi4i4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_oi4i4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                

    typedef struct S_pi4_ (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.Texture, Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest]) declare in UnityEngine.Rendering.AsyncGPUReadback
bool w_S_pi4_oi4i4i4i4i4i4i4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_oi4i4i4i4i4i4i4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp8 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (true) {
        if (js_args_len < 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (js_args_len > 8 && !DataTransfer::IsAssignable(apis, env, _sv8, TIp8, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal ref  with default
    Il2CppObject* p8 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 8, TIp8);
                

    typedef struct S_pi4_ (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, Il2CppObject* p8, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.Texture, Int32, Int32, Int32, Int32, Int32, Int32, Int32, UnityEngine.TextureFormat, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest]) declare in UnityEngine.Rendering.AsyncGPUReadback
bool w_S_pi4_oi4i4i4i4i4i4i4i4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_oi4i4i4i4i4i4i4i4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp9 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (true) {
        if (js_args_len < 9) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (js_args_len > 9 && !DataTransfer::IsAssignable(apis, env, _sv9, TIp9, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal ref  with default
    Il2CppObject* p9 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 9, TIp9);
                

    typedef struct S_pi4_ (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, Il2CppObject* p9, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.IO.LowLevel.Unsafe.FileHandle OpenFileAsync(System.String) declare in Unity.IO.LowLevel.Unsafe.AsyncReadManager
bool w_S_pi4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_pi4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.IO.LowLevel.Unsafe.ReadHandle GetFileInfo(System.String, Unity.IO.LowLevel.Unsafe.FileInfoResult*) declare in Unity.IO.LowLevel.Unsafe.AsyncReadManager
bool w_S_pi4_sPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_sPv");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef struct S_pi4_ (*FuncToCall)(Il2CppString* p0, void* p1, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.IO.LowLevel.Unsafe.ReadHandle Read(System.String, Unity.IO.LowLevel.Unsafe.ReadCommand*, UInt32, System.String, UInt64, Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem) declare in Unity.IO.LowLevel.Unsafe.AsyncReadManager
bool w_S_pi4_sPvu4DsDu8Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_sPvu4DsDu8Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<uint64_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal string  with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    uint64_t p4 = OptionalParameter<uint64_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef struct S_pi4_ (*FuncToCall)(Il2CppString* p0, void* p1, uint32_t p2, Il2CppString* p3, uint64_t p4, int32_t p5, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle Create() declare in Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle
bool w_S_pi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_pi4i4_ (*FuncToCall)(const void* method);
    struct S_pi4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.GraphicsFence CreateAsyncGraphicsFence(UnityEngine.Rendering.SynchronisationStage) declare in UnityEngine.Graphics
bool w_S_pi4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_pi4i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_pi4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.GraphicsFence CreateGraphicsFence(UnityEngine.Rendering.GraphicsFenceType, UnityEngine.Rendering.SynchronisationStageFlags) declare in UnityEngine.Graphics
bool w_S_pi4i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4i4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_pi4i4_ (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    struct S_pi4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.GraphicsFence CreateAsyncGraphicsFence() declare in UnityEngine.Rendering.CommandBuffer
bool w_S_pi4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_pi4i4_ (*FuncToCall)(void*,const void* method);
    struct S_pi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.GraphicsFence CreateAsyncGraphicsFence(UnityEngine.Rendering.SynchronisationStage) declare in UnityEngine.Rendering.CommandBuffer
bool w_S_pi4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_pi4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_pi4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.GraphicsFence CreateGraphicsFence(UnityEngine.Rendering.GraphicsFenceType, UnityEngine.Rendering.SynchronisationStageFlags) declare in UnityEngine.Rendering.CommandBuffer
bool w_S_pi4i4_ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_pi4i4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct S_pi4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.PlayableGraph Create() declare in UnityEngine.Playables.PlayableGraph
bool w_S_pu4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_pu4_ (*FuncToCall)(const void* method);
    struct S_pu4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.PlayableGraph Create(System.String) declare in UnityEngine.Playables.PlayableGraph
bool w_S_pu4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_pu4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_pu4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.PlayableGraph get_playableGraph() declare in UnityEngine.Animator
bool w_S_pu4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_pu4_ (*FuncToCall)(void*,const void* method);
    struct S_pu4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RendererList op_Implicit(UnityEngine.Experimental.Rendering.RenderGraphModule.RendererListHandle) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RendererListHandle
bool w_S_pu4u4u4_S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_S_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};

    typedef struct S_pu4u4u4_ (*FuncToCall)(struct S_bi4_ p0, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RendererList CreateRendererList(UnityEngine.Rendering.RendererListParams ByRef) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_S_pu4u4u4_tPS_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_tPS_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___* p0 = DataTransfer::GetPointer<S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___));
        p0 = &up0;
    }
        

    typedef struct S_pu4u4u4_ (*FuncToCall)(void*,struct S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___* p0, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RendererList CreateShadowRendererList(UnityEngine.Rendering.ShadowDrawingSettings ByRef) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_S_pu4u4u4_tPS_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_tPS_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_* p0 = DataTransfer::GetPointer<S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_));
        p0 = &up0;
    }
        

    typedef struct S_pu4u4u4_ (*FuncToCall)(void*,struct S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_* p0, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RendererList CreateRendererList(UnityEngine.Rendering.RendererUtils.RendererListDesc) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_S_pu4u4u4_tS_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_tS_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_* pp0 = DataTransfer::GetPointer<S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_>(apis, env, _sv0);
    S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_ p0 = pp0 ? *pp0 : S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_ {};

    typedef struct S_pu4u4u4_ (*FuncToCall)(void*,struct S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_ p0, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RendererList CreateSkyboxRendererList(UnityEngine.Camera) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_S_pu4u4u4_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_pu4u4u4_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RendererList CreateSkyboxRendererList(UnityEngine.Camera, UnityEngine.Matrix4x4, UnityEngine.Matrix4x4) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_S_pu4u4u4_toS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_toS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_pu4u4u4_ (*FuncToCall)(void*,Il2CppObject* p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RendererList CreateSkyboxRendererList(UnityEngine.Camera, UnityEngine.Matrix4x4, UnityEngine.Matrix4x4, UnityEngine.Matrix4x4, UnityEngine.Matrix4x4) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_S_pu4u4u4_toS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_toS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_pu4u4u4_ (*FuncToCall)(void*,Il2CppObject* p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p4, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Length Auto() declare in UnityEngine.UIElements.Length
bool w_S_r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4i4_ (*FuncToCall)(const void* method);
    struct S_r4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleFloat op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleFloat
bool w_S_r4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_r4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Angle Degrees(Single) declare in UnityEngine.UIElements.Angle
bool w_S_r4i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4i4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r4i4_ (*FuncToCall)(float p0, const void* method);
    struct S_r4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Length get_x() declare in UnityEngine.UIElements.BackgroundSize
bool w_S_r4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4i4_ (*FuncToCall)(void*,const void* method);
    struct S_r4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 get_zero() declare in UnityEngine.Vector2
bool w_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 mul(Unity.Mathematics.float2x4, Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_r4r4_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 mul(Unity.Mathematics.float2x3, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_r4r4_S_S_r4r4_S_r4r4_S_r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_S_r4r4_S_r4r4_S_r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 mul(Unity.Mathematics.float2x2, Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_r4r4_S_S_r4r4_S_r4r4__S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_S_r4r4_S_r4r4__S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 float2(Unity.Mathematics.half2) declare in Unity.Mathematics.math
bool w_S_r4r4_S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_S_u2_S_u2__ p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 float2(Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_r4r4_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_bb_ p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector2Int) declare in UnityEngine.Vector2Int
bool w_S_r4r4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_i4i4_ p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 Perpendicular(UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 normalizesafe(Unity.Mathematics.float2, Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r4r4_DS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_DS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal valuetype  with default
    S_r4r4_ p1 = OptionalParameter<S_r4r4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 modf(Unity.Mathematics.float2, Unity.Mathematics.float2 ByRef) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r4r4_PS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_PS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4_* p1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4_));
        p1 = &up1;
    }
        

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_* p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 mul(Unity.Mathematics.float2, Unity.Mathematics.float2x2) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r4r4_S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4__ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 Scale(UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 projectsafe(Unity.Mathematics.float2, Unity.Mathematics.float2, Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r4r4_S_r4r4_DS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_DS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal valuetype  with default
    S_r4r4_ p2 = OptionalParameter<S_r4r4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4_* p2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4_* p2, float p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single, Single) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4_* p2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4_* p2, float p3, float p4, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single, Single, Single) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4_* p2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4_* p2, float p3, float p4, float p5, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 select(Unity.Mathematics.float2, Unity.Mathematics.float2, Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r4r4_S_r4r4_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_bb_* pp2 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv2);
    S_bb_ p2 = pp2 ? *pp2 : S_bb_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_bb_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetPositionWithAlignment(UnityEngine.Vector2, UnityEngine.Vector2, Alignment) declare in UnityEditor.Searcher.SearcherWindow
bool w_S_r4r4_S_r4r4_S_r4r4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_i4i4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector2 Clamp(System.Numerics.Vector2, System.Numerics.Vector2, System.Numerics.Vector2) declare in System.Numerics.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 remap(Unity.Mathematics.float2, Unity.Mathematics.float2, Unity.Mathematics.float2, Unity.Mathematics.float2, Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, struct S_r4r4_ p4, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 select(Unity.Mathematics.float2, Unity.Mathematics.float2, Boolean) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r4r4_S_r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, bool p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 Lerp(UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 shuffle(Unity.Mathematics.float2, Unity.Mathematics.float2, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r4r4_S_r4r4_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector2 Transform(System.Numerics.Vector2, System.Numerics.Quaternion) declare in System.Numerics.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector2 Transform(System.Numerics.Vector2, System.Numerics.Matrix3x2) declare in System.Numerics.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector2 Transform(System.Numerics.Vector2, System.Numerics.Matrix4x4) declare in System.Numerics.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_S_r4r4_S_r4r4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, Il2CppArray* p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, Boolean, Boolean, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_S_r4r4_S_r4r4_bbVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_bbVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, bool p1, bool p2, Il2CppArray* p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, Boolean, Boolean, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_S_r4r4_S_r4r4_bbooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_bbooVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        auto TIp5_V = il2cpp::vm::Class::GetElementClass(TIp5);if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5_V, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal ref params
    Il2CppArray* p5 = Params<void*>::PackRef(apis, env, info, TIp5, js_args_len, 5);
                

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, bool p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppArray* p5, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, Boolean, Boolean, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_S_r4r4_S_r4r4_bboooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_bboooVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len < 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        auto TIp6_V = il2cpp::vm::Class::GetElementClass(TIp6);if (js_args_len > 6 && !DataTransfer::IsAssignable(apis, env, _sv6, TIp6_V, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal ref params
    Il2CppArray* p6 = Params<void*>::PackRef(apis, env, info, TIp6, js_args_len, 6);
                

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, bool p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppArray* p6, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, UnityEngine.GUIStyle) declare in UnityEngine.GUILayout
bool w_S_r4r4_S_r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, Il2CppObject* p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_S_r4r4_S_r4r4_oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_oVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 PixelAdjustPoint(UnityEngine.Vector2, UnityEngine.Transform, UnityEngine.Canvas) declare in UnityEngine.RectTransformUtility
bool w_S_r4r4_S_r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_S_r4r4_S_r4r4_ooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_ooVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 ClampMagnitude(UnityEngine.Vector2, Single) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, float p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetPointOnCircle(UnityEngine.Vector2, Single, Single) declare in DG.Tweening.Core.DOTweenUtils
bool w_S_r4r4_S_r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p0, float p1, float p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector3) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 mul(Unity.Mathematics.float3, Unity.Mathematics.float3x2) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r4r4r4_S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4_S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 shuffle(Unity.Mathematics.float3, Unity.Mathematics.float3, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r4r4r4_S_r4r4r4_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4_S_r4r4r4_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector4) declare in UnityEngine.Vector4
bool w_S_r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 mul(Unity.Mathematics.float4, Unity.Mathematics.float4x2) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 NormalizedToPoint(UnityEngine.Rect, UnityEngine.Vector2) declare in UnityEngine.Rect
bool w_S_r4r4_S_r4r4r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 BeginScrollView(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Rect) declare in UnityEngine.GUI
bool w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 BeginScrollView(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Rect, Boolean, Boolean) declare in UnityEngine.GUI
bool w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_bb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4r4r4_ p2, bool p3, bool p4, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 BeginScrollView(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Rect, Boolean, Boolean, UnityEngine.GUIStyle, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_bboo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_bboo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4r4r4_ p2, bool p3, bool p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 BeginScrollView(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Rect, UnityEngine.GUIStyle, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 shuffle(Unity.Mathematics.float4, Unity.Mathematics.float4, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r4r4r4r4_S_r4r4r4r4_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_r4r4r4r4_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 Vector2Field(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Vector2) declare in UnityEditor.EditorGUI
bool w_S_r4r4_S_r4r4r4r4_oS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 Vector2Field(UnityEngine.Rect, System.String, UnityEngine.Vector2) declare in UnityEditor.EditorGUI
bool w_S_r4r4_S_r4r4r4r4_sS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_sS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 float2(Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_r4r4_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_r8r8_ p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 float2(Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_r4r4_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_u2_ p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 float2(Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_r4r4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(struct S_u4u4_ p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 float2(Boolean) declare in Unity.Mathematics.math
bool w_S_r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4_ (*FuncToCall)(bool p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetTextAnchorPivot(UnityEngine.TextAnchor) declare in UnityEngine.UI.Text
bool w_S_r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 CalculateRatioAgainstMaxSize(Int32, Int32) declare in UnityEngine.Rendering.RTHandles
bool w_S_r4r4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4_ (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetMinSize(UnityEngine.Sprite) declare in UnityEngine.Sprites.DataUtility
bool w_S_r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 ScreenToPanel(UnityEngine.UIElements.IPanel, UnityEngine.Vector2) declare in UnityEngine.UIElements.RuntimePanelUtils
bool w_S_r4r4_oS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 Vector2Field(UnityEngine.GUIContent, UnityEngine.Vector2, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4_oS_r4r4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_oS_r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, Il2CppArray* p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 WorldToScreenPoint(UnityEngine.Camera, UnityEngine.Vector3) declare in UnityEngine.RectTransformUtility
bool w_S_r4r4_oS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_oS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 CameraTransformWorldToPanel(UnityEngine.UIElements.IPanel, UnityEngine.Vector3, UnityEngine.Camera) declare in UnityEngine.UIElements.RuntimePanelUtils
bool w_S_r4r4_oS_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_oS_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4_ p1, Il2CppObject* p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 float2(Single) declare in Unity.Mathematics.math
bool w_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4_ (*FuncToCall)(float p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 op_Multiply(Single, UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_S_r4r4_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(float p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 float2(Single, Single) declare in Unity.Mathematics.math
bool w_S_r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4_ (*FuncToCall)(float p0, float p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 float2(Double) declare in Unity.Mathematics.math
bool w_S_r4r4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4_ (*FuncToCall)(double p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 Vector2Field(System.String, UnityEngine.Vector2, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4_sS_r4r4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_sS_r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_r4r4_ (*FuncToCall)(Il2CppString* p0, struct S_r4r4_ p1, Il2CppArray* p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 get_curvature() declare in UnityEngine.Camera
bool w_S_r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetPositionOnCircle(DG.Tweening.Plugins.CircleOptions, Single) declare in DG.Tweening.Plugins.CirclePlugin
bool w_S_r4r4_tS_r4bbS_r4r4_r4r4b_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tS_r4bbS_r4r4_r4r4b_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4bbS_r4r4_r4r4b_* pp0 = DataTransfer::GetPointer<S_r4bbS_r4r4_r4r4b_>(apis, env, _sv0);
    S_r4bbS_r4r4_r4r4b_ p0 = pp0 ? *pp0 : S_r4bbS_r4r4_r4r4b_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4_ (*FuncToCall)(void*,struct S_r4bbS_r4r4_r4r4b_ p0, float p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 CalcScreenSize(UnityEngine.Vector2) declare in UnityEngine.GUIStyle
bool w_S_r4r4_tS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(void*,struct S_r4r4_ p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 NextFloat2(Unity.Mathematics.float2, Unity.Mathematics.float2) declare in Unity.Mathematics.Random
bool w_S_r4r4_tS_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tS_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 WorldToScreenPoint(UnityEngine.Vector3) declare in UnityEditor.CameraProjectionCache
bool w_S_r4r4_tS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(void*,struct S_r4r4r4_ p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetCursorPixelPosition(UnityEngine.Rect, UnityEngine.GUIContent, Int32) declare in UnityEngine.GUIStyle
bool w_S_r4r4_tS_r4r4r4r4_oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tS_r4r4r4r4_oi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetRenderedValues(Boolean) declare in TMPro.TMP_Text
bool w_S_r4r4_tb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4_ (*FuncToCall)(void*,bool p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetPropertyRangeLimits(Int32) declare in UnityEngine.Shader
bool w_S_r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetShapeVertex(Int32, Int32) declare in UnityEngine.PhysicsShapeGroup2D
bool w_S_r4r4_ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 CalcSize(UnityEngine.GUIContent) declare in UnityEngine.GUIStyle
bool w_S_r4r4_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 ChangeCoordinatesTo(UnityEngine.UIElements.VisualElement, UnityEngine.UIElements.VisualElement, UnityEngine.Vector2) declare in UnityEngine.UIElements.VisualElementExtensions
bool w_S_r4r4_toS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_toS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 ComputeWindFactor(TreeEditor.TreeNode, Single) declare in TreeEditor.TreeGroup
bool w_S_r4r4_tor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tor4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, float p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetPoint(Single) declare in UnityEngine.Ray2D
bool w_S_r4r4_tr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4_ (*FuncToCall)(void*,float p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetMousePosition(Single, Boolean) declare in UnityEngine.Rendering.MousePositionDebug
bool w_S_r4r4_tr4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tr4b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4_ (*FuncToCall)(void*,float p0, bool p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetPreferredValues(Single, Single) declare in TMPro.TMP_Text
bool w_S_r4r4_tr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tr4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4_ (*FuncToCall)(void*,float p0, float p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetTextureOffset(System.String) declare in UnityEngine.Material
bool w_S_r4r4_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetTextureScale(System.String, Boolean ByRef, Boolean ByRef) declare in UnityEditor.MaterialEditor
bool w_S_r4r4_tsPbPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tsPbPb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;
    // JSValToCSVal P primitive
    bool up2 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv2);
    bool* p2 = &up2;

    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppString* p0, bool* p1, bool* p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<bool>::toScript(apis, env, *p2));
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 MeasureTextSize(System.String, Single, MeasureMode, Single, MeasureMode) declare in UnityEngine.UIElements.TextElement
bool w_S_r4r4_tsr4i4r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tsr4i4r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppString* p0, float p1, int32_t p2, float p3, int32_t p4, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2 GetPreferredValues(System.String, Single, Single) declare in TMPro.TMP_Text
bool w_S_r4r4_tsr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tsr4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppString* p0, float p1, float p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2 float2(UInt32) declare in Unity.Mathematics.math
bool w_S_r4r4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.JointMotor get_motor() declare in UnityEngine.HingeJoint
bool w_S_r4r4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4i4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 get_shadowCascade4Split() declare in UnityEngine.QualitySettings
bool w_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 rotate(Unity.Mathematics.RigidTransform, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_S_S_r4r4r4r4__S_r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_S_S_r4r4r4r4__S_r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4r4r4r4__S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_S_r4r4r4r4__S_r4r4r4__>(apis, env, _sv0);
    S_S_S_r4r4r4r4__S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_S_r4r4r4r4__S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_S_S_r4r4r4r4__S_r4r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 mul(Unity.Mathematics.float3x4, Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 mul(Unity.Mathematics.float3x3, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 mul(Unity.Mathematics.float3x2, Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_S_r4r4r4_S_r4r4r4__S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_S_r4r4r4_S_r4r4r4__S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 rotate(Unity.Mathematics.float4x4, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 forward(Unity.Mathematics.quaternion) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4r4__ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 mul(Unity.Mathematics.quaternion, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_S_r4r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_S_r4r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 float3(Unity.Mathematics.half3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2__ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_S_u2_S_u2_S_u2__ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 float3(Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_bbb_ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 op_Implicit(UnityEngine.Vector3Int) declare in UnityEngine.Vector3Int
bool w_S_r4r4r4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_i4i4i4_ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 PositionHandle(PositionHandleIds, UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEditor.Handles
bool w_S_r4r4r4_S_i4i4i4i4i4i4i4_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_i4i4i4i4i4i4i4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4i4i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_i4i4i4i4i4i4i4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 op_Implicit(UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_S_r4r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 mul(Unity.Mathematics.float2, Unity.Mathematics.float2x3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4_S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4_S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 psrdnoise(Unity.Mathematics.float2, Unity.Mathematics.float2) declare in Unity.Mathematics.noise
bool w_S_r4r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 psrdnoise(Unity.Mathematics.float2, Unity.Mathematics.float2, Single) declare in Unity.Mathematics.noise
bool w_S_r4r4r4_S_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4_S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 shuffle(Unity.Mathematics.float2, Unity.Mathematics.float2, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4_S_r4r4_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4_S_r4r4_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 float3(Unity.Mathematics.float2, Single) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, float p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 RelativeMouseAt(UnityEngine.Vector3) declare in UnityEngine.Display
bool w_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 normalizesafe(Unity.Mathematics.float3, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4r4_DS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_DS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal valuetype  with default
    S_r4r4r4_ p1 = OptionalParameter<S_r4r4r4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 modf(Unity.Mathematics.float3, Unity.Mathematics.float3 ByRef) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_PS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4_));
        p1 = &up1;
    }
        

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_* p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 mul(Unity.Mathematics.float3, Unity.Mathematics.float3x3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4r4_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Scale(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 projectsafe(Unity.Mathematics.float3, Unity.Mathematics.float3, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_DS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_DS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal valuetype  with default
    S_r4r4r4_ p2 = OptionalParameter<S_r4r4r4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Snap(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.SnapAxis) declare in UnityEngine.Snapping
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_Du1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_Du1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    uint8_t p2 = OptionalParameter<uint8_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, uint8_t p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_* p2, float p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_* p2, float p3, float p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single, Single) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_* p2, float p3, float p4, float p5, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 ClosestPtSegmentRay(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Ray, Single ByRef, Single ByRef, UnityEngine.Vector3 ByRef) declare in UnityEditor.MathUtils
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_S_r4r4r4_S_r4r4r4__Pr4Pr4PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_S_r4r4r4_S_r4r4r4__Pr4Pr4PS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv2);
    S_S_r4r4r4_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P primitive
    float up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv3);
    float* p3 = &up3;
    // JSValToCSVal P primitive
    float up4 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv4);
    float* p4 = &up4;
    // JSValToCSVal Pstruct
    S_r4r4r4_* p5 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv5)); // valuetype ref
    S_r4r4r4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(S_r4r4r4_));
        p5 = &up5;
    }
        

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_S_r4r4r4_S_r4r4r4__ p2, float* p3, float* p4, struct S_r4r4r4_* p5, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<float>::toScript(apis, env, *p3));
    apis->update_boxed_value(env, _sv4, converter::Converter<float>::toScript(apis, env, *p4));
    if (p5 == &up5)
    {
        apis->update_boxed_value(env, _sv5, DataTransfer::CopyValueType(apis, env, *p5, TIp5));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 select(Unity.Mathematics.float3, Unity.Mathematics.float3, Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_bbb_* pp2 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv2);
    S_bbb_ p2 = pp2 ? *pp2 : S_bbb_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_bbb_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 ProjectPointLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEditor.HandleUtility
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 remap(Unity.Mathematics.float3, Unity.Mathematics.float3, Unity.Mathematics.float3, Unity.Mathematics.float3, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Slider2D(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, UnityEngine.Vector2) declare in UnityEditor.Handles
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal struct
    S_r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv6);
    S_r4r4_ p6 = pp6 ? *pp6 : S_r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, Il2CppObject* p5, struct S_r4r4_ p6, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Slider2D(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, UnityEngine.Vector2, Boolean) declare in UnityEditor.Handles
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal struct
    S_r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv6);
    S_r4r4_ p6 = pp6 ? *pp6 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, Il2CppObject* p5, struct S_r4r4_ p6, bool p7, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Slider2D(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, Single) declare in UnityEditor.Handles
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, Il2CppObject* p5, float p6, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Slider2D(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, Single, Boolean) declare in UnityEditor.Handles
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, Il2CppObject* p5, float p6, bool p7, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 ClosestPointToArc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, Single) declare in UnityEditor.HandleUtility
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, float p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 ScaleHandle(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEditor.Handles
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 DoScaleHandle(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single) declare in UnityEditor.Handles
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, float p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 select(Unity.Mathematics.float3, Unity.Mathematics.float3, Boolean) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, bool p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Slerp(UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 EasedValue(UnityEngine.Vector3, UnityEngine.Vector3, Single, DG.Tweening.Ease) declare in DG.Tweening.DOVirtual
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, int32_t p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 EasedValue(UnityEngine.Vector3, UnityEngine.Vector3, Single, DG.Tweening.Ease, Single) declare in DG.Tweening.DOVirtual
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, int32_t p3, float p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 EasedValue(UnityEngine.Vector3, UnityEngine.Vector3, Single, DG.Tweening.Ease, Single, Single) declare in DG.Tweening.DOVirtual
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, int32_t p3, float p4, float p5, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 EasedValue(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.AnimationCurve) declare in DG.Tweening.DOVirtual
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Slider(UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, Single) declare in UnityEditor.Handles
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, Il2CppObject* p3, float p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 RotateTowards(UnityEngine.Vector3, UnityEngine.Vector3, Single, Single) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, float p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 shuffle(Unity.Mathematics.float3, Unity.Mathematics.float3, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 DoPositionHandle(UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEditor.Handles
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 FreeMoveHandle(UnityEngine.Vector3, UnityEngine.Quaternion, Single, UnityEngine.Vector3, CapFunction) declare in UnityEditor.Handles
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4S_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4S_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, Il2CppObject* p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector3 Transform(System.Numerics.Vector3, System.Numerics.Matrix4x4) declare in System.Numerics.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 ClosestPoint(UnityEngine.Vector3, UnityEngine.Collider, UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.Physics
bool w_S_r4r4r4_S_r4r4r4_oS_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_oS_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 ClampMagnitude(UnityEngine.Vector3, Single) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, float p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 FreeMoveHandle(UnityEngine.Vector3, Single, UnityEngine.Vector3, CapFunction) declare in UnityEditor.Handles
bool w_S_r4r4r4_S_r4r4r4_r4S_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_r4S_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, float p1, struct S_r4r4r4_ p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 ToEulerAngles(UnityEngine.Quaternion) declare in UnityEngine.Quaternion
bool w_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 mul(Unity.Mathematics.float4, Unity.Mathematics.float4x3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 op_Multiply(UnityEngine.Quaternion, UnityEngine.Vector3) declare in UnityEngine.Quaternion
bool w_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 shuffle(Unity.Mathematics.float4, Unity.Mathematics.float4, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r4r4r4r4_S_r4r4r4r4_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4_S_r4r4r4r4_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Vector3Field(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Vector3) declare in UnityEditor.EditorGUI
bool w_S_r4r4r4_S_r4r4r4r4_oS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4_oS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Vector3Field(UnityEngine.Rect, System.String, UnityEngine.Vector3) declare in UnityEditor.EditorGUI
bool w_S_r4r4r4_S_r4r4r4r4_sS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4_sS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 PerspectiveClipToWorld(UnityEngine.Matrix4x4, UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEditor.CameraEditorUtils
bool w_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 GetCoefficient(UnityEngine.Rendering.SphericalHarmonicsL2, Int32) declare in UnityEngine.Rendering.SphericalHarmonicsL2Utils
bool w_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, int32_t p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 float3(Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r8r8r8_ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 float3(Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_u2_ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 float3(Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_r4r4r4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_u4u4u4_ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 ClosestPointToPolyLine(UnityEngine.Vector3[]) declare in UnityEditor.HandleUtility
bool w_S_r4r4r4_VS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_VS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, true)) return false;
    }
    
    // JSValToCSVal valuetype params
    Il2CppArray* p0 = Params<S_r4r4r4_>::PackValueType(apis, env, info, TIp0, js_args_len, 0);
                

    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppArray* p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 float3(Boolean) declare in Unity.Mathematics.math
bool w_S_r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4_ (*FuncToCall)(bool p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 GetLocalPosition(UnityEngine.XR.XRNode) declare in UnityEngine.XR.InputTracking
bool w_S_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Swizzle(CellSwizzle, UnityEngine.Vector3) declare in UnityEngine.Grid
bool w_S_r4r4r4_i4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Slider2D(Int32, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, UnityEngine.Vector2) declare in UnityEditor.Handles
bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal struct
    S_r4r4_* pp8 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv8);
    S_r4r4_ p8 = pp8 ? *pp8 : S_r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, struct S_r4r4r4_ p5, float p6, Il2CppObject* p7, struct S_r4r4_ p8, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Slider2D(Int32, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, UnityEngine.Vector2, Boolean) declare in UnityEditor.Handles
bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (checkJSArgument) {
        if (js_args_len != 10) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal struct
    S_r4r4_* pp8 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv8);
    S_r4r4_ p8 = pp8 ? *pp8 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);

    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, struct S_r4r4r4_ p5, float p6, Il2CppObject* p7, struct S_r4r4_ p8, bool p9, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Slider2D(Int32, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, UnityEngine.Vector2) declare in UnityEditor.Handles
bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal struct
    S_r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv7);
    S_r4r4_ p7 = pp7 ? *pp7 : S_r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, Il2CppObject* p6, struct S_r4r4_ p7, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Slider2D(Int32, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, UnityEngine.Vector2, Boolean) declare in UnityEditor.Handles
bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal struct
    S_r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv7);
    S_r4r4_ p7 = pp7 ? *pp7 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);

    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, Il2CppObject* p6, struct S_r4r4_ p7, bool p8, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Slider(Int32, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, Single) declare in UnityEditor.Handles
bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);

    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, Il2CppObject* p5, float p6, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Slider(Int32, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, Single) declare in UnityEditor.Handles
bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_r4or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_r4or4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, Il2CppObject* p4, float p5, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 FreeMoveHandle(Int32, UnityEngine.Vector3, UnityEngine.Quaternion, Single, UnityEngine.Vector3, CapFunction) declare in UnityEditor.Handles
bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4r4_r4S_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4r4_r4S_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, Il2CppObject* p5, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 FreeMoveHandle(Int32, UnityEngine.Vector3, Single, UnityEngine.Vector3, CapFunction) declare in UnityEditor.Handles
bool w_S_r4r4r4_i4S_r4r4r4_r4S_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_r4S_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, Il2CppObject* p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 GetInspectorRotation(UnityEngine.Transform) declare in UnityEditor.TransformUtils
bool w_S_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 WorldToGUIPointWithDepth(UnityEngine.Camera, UnityEngine.Vector3) declare in UnityEditor.HandleUtility
bool w_S_r4r4r4_oS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_oS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Vector3Field(UnityEngine.GUIContent, UnityEngine.Vector3, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4r4_oS_r4r4r4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_oS_r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4_ p1, Il2CppArray* p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 GetVector3(Single) declare in TreeEditor.SmoothRandom
bool w_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4_ (*FuncToCall)(float p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 float3(Single, Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_r4r4r4_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(float p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 op_Multiply(Single, UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_S_r4r4r4_r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_r4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(float p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 CIExyToLMS(Single, Single) declare in UnityEngine.Rendering.ColorUtils
bool w_S_r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4_ (*FuncToCall)(float p0, float p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 float3(Single, Single, Single) declare in Unity.Mathematics.math
bool w_S_r4r4r4_r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 float3(Double) declare in Unity.Mathematics.math
bool w_S_r4r4r4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4_ (*FuncToCall)(double p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 GetTrackerPosition(System.String) declare in UnityEngine.ClusterInput
bool w_S_r4r4r4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 GetVector3(System.String, UnityEngine.Vector3) declare in UnityEditor.SessionState
bool w_S_r4r4r4_sS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_sS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppString* p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 Vector3Field(System.String, UnityEngine.Vector3, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4r4_sS_r4r4r4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_sS_r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppString* p0, struct S_r4r4r4_ p1, Il2CppArray* p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 get_position() declare in UnityEngine.Experimental.AI.NavMeshLocation
bool w_S_r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 GetCellCenterLocal(UnityEngine.Vector3Int) declare in UnityEngine.Grid
bool w_S_r4r4r4_tS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_i4i4i4_ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 WorldToScreenPoint(UnityEngine.Vector3) declare in UnityEngine.Camera
bool w_S_r4r4r4_tS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4_ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 NextFloat3(Unity.Mathematics.float3, Unity.Mathematics.float3) declare in Unity.Mathematics.Random
bool w_S_r4r4r4_tS_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 WorldToScreenPoint(UnityEngine.Vector3, MonoOrStereoscopicEye) declare in UnityEngine.Camera
bool w_S_r4r4r4_tS_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4_ p0, int32_t p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 GetPosition(UnityEngine.Animations.AnimationStream) declare in UnityEngine.Animations.TransformStreamHandle
bool w_S_r4r4r4_tS_u4pppppp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_u4pppppp_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_u4pppppp_ p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 GetIKPosition(UnityEngine.AvatarIKGoal) declare in UnityEngine.Animator
bool w_S_r4r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 ConvertToStartValue(DG.Tweening.Core.TweenerCore`3[UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions], UnityEngine.Vector3) declare in DG.Tweening.Plugins.Vector3Plugin
bool w_S_r4r4r4_toS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_toS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 ConvertToStartValue(DG.Tweening.Core.TweenerCore`3[UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions], UnityEngine.Quaternion) declare in DG.Tweening.Plugins.QuaternionPlugin
bool w_S_r4r4r4_toS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_toS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 GetPoint(Single) declare in UnityEngine.Ray
bool w_S_r4r4r4_tr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,float p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 GetInterpolatedNormal(Single, Single) declare in UnityEngine.TerrainData
bool w_S_r4r4r4_tr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tr4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,float p0, float p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 TransformDirection(Single, Single, Single) declare in UnityEngine.Transform
bool w_S_r4r4r4_tr4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tr4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3 GetVector(System.String) declare in UnityEngine.Animator
bool w_S_r4r4r4_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3 float3(UInt32) declare in Unity.Mathematics.math
bool w_S_r4r4r4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// PlaybackState GetPlaybackState() declare in UnityEngine.ParticleSystem
bool w_S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.JointDrive get_xDrive() declare in UnityEngine.ConfigurableJoint
bool w_S_r4r4r4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4i4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 get_defaultTextureHDRDecodeValues() declare in UnityEngine.ReflectionProbe
bool w_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 GetShadowBias(UnityEngine.Rendering.VisibleLight ByRef, Int32, UnityEngine.Rendering.Universal.ShadowData ByRef, UnityEngine.Matrix4x4, Single) declare in UnityEngine.Rendering.Universal.ShadowUtils
bool w_S_r4r4r4r4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_i4PS_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_i4PS_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_* p0 = DataTransfer::GetPointer<S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_* p2 = DataTransfer::GetPointer<S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_));
        p2 = &up2;
    }
        
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_* p0, int32_t p1, struct S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_* p2, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3, float p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 GetPayloadScaleOffset(UnityEngine.Vector2 ByRef, UnityEngine.Vector2 ByRef, UnityEngine.Vector4 ByRef) declare in UnityEngine.Rendering.PowerOfTwoTextureAtlas
bool w_S_r4r4r4r4_PS_r4r4_PS_r4r4_PS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_PS_r4r4_PS_r4r4_PS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4_* p0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4_* p1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4r4_));
        p2 = &up2;
    }
        

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_* p0, struct S_r4r4_* p1, struct S_r4r4r4r4_* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 mul(Unity.Mathematics.RigidTransform, Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_S_S_r4r4r4r4__S_r4r4r4__S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_S_S_r4r4r4r4__S_r4r4r4__S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4r4r4r4__S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_S_r4r4r4r4__S_r4r4r4__>(apis, env, _sv0);
    S_S_S_r4r4r4r4__S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_S_r4r4r4r4__S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_S_S_r4r4r4r4__S_r4r4r4__ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 mul(Unity.Mathematics.float4x4, Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 mul(Unity.Mathematics.float4x3, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 mul(Unity.Mathematics.float4x2, Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4__S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4__S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion op_Implicit(Unity.Mathematics.quaternion) declare in Unity.Mathematics.quaternion
bool w_S_r4r4r4r4_S_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4r4__ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 float4(Unity.Mathematics.half4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_S_u2_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_S_u2_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2_S_u2__ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_S_u2_S_u2_S_u2_S_u2__ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 float4(Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_bbbb_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 float4(Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion RotationHandle(RotationHandleIds, UnityEngine.Quaternion, UnityEngine.Vector3) declare in UnityEditor.Handles
bool w_S_r4r4r4r4_S_i4i4i4i4i4_S_r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_i4i4i4i4i4_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_i4i4i4i4i4_ p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color op_Implicit(UnityEngine.Color32) declare in UnityEngine.Color32
bool w_S_r4r4r4r4_S_i4u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_i4u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(apis, env, _sv0);
    S_i4u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4u1u1u1u1_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_i4u1u1u1u1_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 op_Implicit(UnityEngine.Vector2) declare in UnityEngine.Vector4
bool w_S_r4r4r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 mul(Unity.Mathematics.float2, Unity.Mathematics.float2x4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 float4(Unity.Mathematics.float2, Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 GetFlareData0(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2, Single, Single, Single, UnityEngine.Vector2, Boolean) declare in UnityEngine.Rendering.LensFlareCommonSRP
bool w_S_r4r4r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_r4r4r4S_r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_r4r4r4S_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal struct
    S_r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv7);
    S_r4r4_ p7 = pp7 ? *pp7 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, float p4, float p5, float p6, struct S_r4r4_ p7, bool p8, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 shuffle(Unity.Mathematics.float2, Unity.Mathematics.float2, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4_S_r4r4_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4_S_r4r4_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector4 Transform(System.Numerics.Vector2, System.Numerics.Quaternion) declare in System.Numerics.Vector4
bool w_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector4 Transform(System.Numerics.Vector2, System.Numerics.Matrix4x4) declare in System.Numerics.Vector4
bool w_S_r4r4r4r4_S_r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 float4(Unity.Mathematics.float2, Single, Single) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, float p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion LookRotation(UnityEngine.Vector3) declare in UnityEngine.Quaternion
bool w_S_r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 mul(Unity.Mathematics.float3, Unity.Mathematics.float3x4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4r4_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion FromToRotation(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Quaternion
bool w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 shuffle(Unity.Mathematics.float3, Unity.Mathematics.float3, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector4 Transform(System.Numerics.Vector3, System.Numerics.Quaternion) declare in System.Numerics.Vector4
bool w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector4 Transform(System.Numerics.Vector3, System.Numerics.Matrix4x4) declare in System.Numerics.Vector4
bool w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect WorldPointToSizedRect(UnityEngine.Vector3, UnityEngine.GUIContent, UnityEngine.GUIStyle) declare in UnityEditor.HandleUtility
bool w_S_r4r4r4r4_S_r4r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion AxisAngle(UnityEngine.Vector3, Single) declare in UnityEngine.Quaternion
bool w_S_r4r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, float p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 op_Implicit(UnityEngine.Color) declare in UnityEngine.Color
bool w_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 normalizesafe(Unity.Mathematics.float4, Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4r4r4_DS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_DS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal valuetype  with default
    S_r4r4r4r4_ p1 = OptionalParameter<S_r4r4r4r4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 modf(Unity.Mathematics.float4, Unity.Mathematics.float4 ByRef) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4r4r4_PS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_PS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4r4_));
        p1 = &up1;
    }
        

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect AlignRectToDevice(UnityEngine.Rect, Int32 ByRef, Int32 ByRef) declare in UnityEngine.GUIUtility
bool w_S_r4r4r4r4_S_r4r4r4r4_Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_Pi4Pi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, int32_t* p1, int32_t* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 mul(Unity.Mathematics.float4, Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion DoRotationHandle(UnityEngine.Quaternion, UnityEngine.Vector3) declare in UnityEditor.Handles
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion Disc(UnityEngine.Quaternion, UnityEngine.Vector3, UnityEngine.Vector3, Single, Boolean, Single) declare in UnityEditor.Handles
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_S_r4r4r4_r4br4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_S_r4r4r4_r4br4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, bool p4, float p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion FreeRotateHandle(UnityEngine.Quaternion, UnityEngine.Vector3, Single) declare in UnityEditor.Handles
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color op_Addition(UnityEngine.Color, UnityEngine.Color) declare in UnityEngine.Color
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 projectsafe(Unity.Mathematics.float4, Unity.Mathematics.float4, Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_DS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_DS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal valuetype  with default
    S_r4r4r4r4_ p2 = OptionalParameter<S_r4r4r4r4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 select(Unity.Mathematics.float4, Unity.Mathematics.float4, Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_bbbb_* pp2 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv2);
    S_bbbb_ p2 = pp2 ? *pp2 : S_bbbb_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, struct S_bbbb_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion GetSquadIntermediate(UnityEngine.Quaternion, UnityEngine.Quaternion, UnityEngine.Quaternion) declare in UnityEditor.MathUtils
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 remap(Unity.Mathematics.float4, Unity.Mathematics.float4, Unity.Mathematics.float4, Unity.Mathematics.float4, Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4r4_ p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 TextureScaleOffsetProperty(UnityEngine.Rect, UnityEngine.Vector4, Boolean) declare in UnityEditor.MaterialEditor
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, bool p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color Lerp(UnityEngine.Color, UnityEngine.Color, Single) declare in UnityEngine.Color
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 shuffle(Unity.Mathematics.float4, Unity.Mathematics.float4, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector4 Transform(System.Numerics.Vector4, System.Numerics.Matrix4x4) declare in System.Numerics.Vector4
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect RectField(UnityEngine.Rect, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4r4r4_S_r4r4r4r4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppArray* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect PrefixLabel(UnityEngine.Rect, Int32, UnityEngine.GUIContent) declare in UnityEditor.EditorGUI
bool w_S_r4r4r4r4_S_r4r4r4r4_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect PrefixLabel(UnityEngine.Rect, Int32, UnityEngine.GUIContent, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_S_r4r4r4r4_S_r4r4r4r4_i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_i4oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect PrefixLabel(UnityEngine.Rect, UnityEngine.GUIContent) declare in UnityEditor.EditorGUI
bool w_S_r4r4r4r4_S_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 Vector4Field(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Vector4) declare in UnityEditor.EditorGUI
bool w_S_r4r4r4r4_S_r4r4r4r4_oS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_oS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color ColorField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Color, Boolean, Boolean, Boolean) declare in UnityEditor.EditorGUI
bool w_S_r4r4r4r4_S_r4r4r4r4_oS_r4r4r4r4_bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_oS_r4r4r4r4_bbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, struct S_r4r4r4r4_ p2, bool p3, bool p4, bool p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color ColorField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Color, Boolean, Boolean, Boolean, UnityEditor.ColorPickerHDRConfig) declare in UnityEditor.EditorGUI
bool w_S_r4r4r4r4_S_r4r4r4r4_oS_r4r4r4r4_bbbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_oS_r4r4r4r4_bbbo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, struct S_r4r4r4r4_ p2, bool p3, bool p4, bool p5, Il2CppObject* p6, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect PrefixLabel(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_S_r4r4r4r4_S_r4r4r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color op_Multiply(UnityEngine.Color, Single) declare in UnityEngine.Color
bool w_S_r4r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, float p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect Inflate(UnityEngine.Rect, Single, Single, Single, Single) declare in UnityEditor.Experimental.GraphView.RectUtils
bool w_S_r4r4r4r4_S_r4r4r4r4_r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, float p1, float p2, float p3, float p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 Vector4Field(UnityEngine.Rect, System.String, UnityEngine.Vector4) declare in UnityEditor.EditorGUI
bool w_S_r4r4r4r4_S_r4r4r4r4_sS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_sS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion QuaternionFromMatrix(UnityEngine.Matrix4x4) declare in UnityEditor.MathUtils
bool w_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 op_Multiply(UnityEngine.Matrix4x4, UnityEngine.Vector4) declare in UnityEngine.Matrix4x4
bool w_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 float4(Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r8r8r8r8_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 float4(Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_u2_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 float4(Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect BeginHorizontal(UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4r4r4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, false)) return false;
    }
    
    // JSValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, js_args_len, 0);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppArray* p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 float4(Boolean) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(bool p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetWorkAreaRect(Boolean, UnityEngine.Object) declare in FullscreenEditor.FullscreenRects
bool w_S_r4r4r4r4_bDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_bDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(bool p0, Il2CppObject* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetControlRect(Boolean, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4r4r4_bVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_bVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(bool p0, Il2CppArray* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetControlRect(Boolean, Single, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4r4r4_br4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_br4Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(bool p0, float p1, Il2CppArray* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetControlRect(Boolean, Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4r4r4_br4oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_br4oVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(bool p0, float p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 GetGlobalVector(Int32) declare in UnityEngine.Shader
bool w_S_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetFullscreenRect(FullscreenEditor.RectSourceMode, UnityEngine.ScriptableObject) declare in FullscreenEditor.FullscreenRects
bool w_S_r4r4r4r4_i4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p0, Il2CppObject* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion Disc(Int32, UnityEngine.Quaternion, UnityEngine.Vector3, UnityEngine.Vector3, Single, Boolean, Single) declare in UnityEditor.Handles
bool w_S_r4r4r4r4_i4S_r4r4r4r4_S_r4r4r4_S_r4r4r4_r4br4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_S_r4r4r4_S_r4r4r4_r4br4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, bool p5, float p6, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion FreeRotateHandle(Int32, UnityEngine.Quaternion, UnityEngine.Vector3, Single) declare in UnityEditor.Handles
bool w_S_r4r4r4r4_i4S_r4r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, UnityEngine.Texture) declare in UnityEngine.GUI
bool w_S_r4r4r4r4_i4S_r4r4r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, UnityEngine.Texture, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_S_r4r4r4r4_i4S_r4r4r4r4_ooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_ooVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppArray* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, UnityEngine.Texture, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_S_r4r4r4r4_i4S_r4r4r4r4_ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, UnityEngine.Texture, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_S_r4r4r4r4_i4S_r4r4r4r4_oooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_oooVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len < 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        auto TIp5_V = il2cpp::vm::Class::GetElementClass(TIp5);if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5_V, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal ref params
    Il2CppArray* p5 = Params<void*>::PackRef(apis, env, info, TIp5, js_args_len, 5);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppArray* p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, System.String) declare in UnityEngine.GUI
bool w_S_r4r4r4r4_i4S_r4r4r4r4_os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, System.String, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_S_r4r4r4r4_i4S_r4r4r4r4_osVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_osVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppString* p3, Il2CppArray* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, System.String, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_S_r4r4r4r4_i4S_r4r4r4r4_oso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_oso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, System.String, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_S_r4r4r4r4_i4S_r4r4r4r4_osoVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_osoVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len < 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        auto TIp5_V = il2cpp::vm::Class::GetElementClass(TIp5);if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5_V, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal ref params
    Il2CppArray* p5 = Params<void*>::PackRef(apis, env, info, TIp5, js_args_len, 5);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p0, struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppString* p3, Il2CppObject* p4, Il2CppArray* p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 GetInnerUV(UnityEngine.Sprite) declare in UnityEngine.Sprites.DataUtility
bool w_S_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect FindCullAndClipWorldRect(System.Collections.Generic.List`1[UnityEngine.UI.RectMask2D], Boolean ByRef) declare in UnityEngine.UI.Clipping
bool w_S_r4r4r4r4_oPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oPb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p0, bool* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect CameraTransformWorldToPanelRect(UnityEngine.UIElements.IPanel, UnityEngine.Vector3, UnityEngine.Vector2, UnityEngine.Camera) declare in UnityEngine.UIElements.RuntimePanelUtils
bool w_S_r4r4r4r4_oS_r4r4r4_S_r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oS_r4r4r4_S_r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4_ p1, struct S_r4r4_ p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 Vector4Field(UnityEngine.GUIContent, UnityEngine.Vector4, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4r4r4_oS_r4r4r4r4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oS_r4r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, Il2CppArray* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color ColorField(UnityEngine.GUIContent, UnityEngine.Color, Boolean, Boolean, Boolean, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4r4r4_oS_r4r4r4r4_bbbVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oS_r4r4r4r4_bbbVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        auto TIp5_V = il2cpp::vm::Class::GetElementClass(TIp5);if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal ref params
    Il2CppArray* p5 = Params<void*>::PackRef(apis, env, info, TIp5, js_args_len, 5);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, bool p2, bool p3, bool p4, Il2CppArray* p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color ColorField(UnityEngine.GUIContent, UnityEngine.Color, Boolean, Boolean, Boolean, UnityEditor.ColorPickerHDRConfig, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4r4r4_oS_r4r4r4r4_bbboVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oS_r4r4r4r4_bbboVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len < 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        auto TIp6_V = il2cpp::vm::Class::GetElementClass(TIp6);if (js_args_len > 6 && !DataTransfer::IsAssignable(apis, env, _sv6, TIp6_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal ref params
    Il2CppArray* p6 = Params<void*>::PackRef(apis, env, info, TIp6, js_args_len, 6);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, bool p2, bool p3, bool p4, Il2CppObject* p5, Il2CppArray* p6, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect BeginHorizontal(UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4r4r4_oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p0, Il2CppArray* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 GetSpriteOuterUV(UnityEngine.Sprite, Boolean) declare in UnityEditorInternal.InternalEditorUtility
bool w_S_r4r4r4r4_ob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p0, bool p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetRect(UnityEngine.GUIContent, UnityEngine.GUIStyle) declare in UnityEngine.GUILayoutUtility
bool w_S_r4r4r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetRect(UnityEngine.GUIContent, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayoutUtility
bool w_S_r4r4r4r4_ooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ooVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect TextureColorProps(UnityEditor.MaterialEditor, UnityEngine.GUIContent, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty, Boolean) declare in UnityEditor.BaseShaderGUI
bool w_S_r4r4r4r4_ooooDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ooooDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color CorrelatedColorTemperatureToRGB(Single) declare in UnityEngine.Mathf
bool w_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 float4(Single, Unity.Mathematics.float2, Single) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_r4S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, struct S_r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion AngleAxis(Single, UnityEngine.Vector3) declare in UnityEngine.Quaternion
bool w_S_r4r4r4r4_r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color op_Multiply(Single, UnityEngine.Color) declare in UnityEngine.Color
bool w_S_r4r4r4r4_r4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion GetQuatSquad(Single, UnityEngine.Quaternion, UnityEngine.Quaternion, UnityEngine.Quaternion, UnityEngine.Quaternion) declare in UnityEditor.MathUtils
bool w_S_r4r4r4r4_r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4r4_ p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetAspectRect(Single, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayoutUtility
bool w_S_r4r4r4r4_r4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, Il2CppArray* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetAspectRect(Single, UnityEngine.GUIStyle) declare in UnityEngine.GUILayoutUtility
bool w_S_r4r4r4r4_r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, Il2CppObject* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetAspectRect(Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayoutUtility
bool w_S_r4r4r4r4_r4oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4oVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color ColorHSV(Single, Single) declare in UnityEngine.Random
bool w_S_r4r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 float4(Single, Single, Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_r4r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetRect(Single, Single, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayoutUtility
bool w_S_r4r4r4r4_r4r4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, Il2CppArray* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetRect(Single, Single, UnityEngine.GUIStyle) declare in UnityEngine.GUILayoutUtility
bool w_S_r4r4r4r4_r4r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, Il2CppObject* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetRect(Single, Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayoutUtility
bool w_S_r4r4r4r4_r4r4oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4oVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color HSVToRGB(Single, Single, Single) declare in UnityEngine.Color
bool w_S_r4r4r4r4_r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color HSVToRGB(Single, Single, Single, Boolean) declare in UnityEngine.Color
bool w_S_r4r4r4r4_r4r4r4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, bool p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect MinMaxRect(Single, Single, Single, Single) declare in UnityEngine.Rect
bool w_S_r4r4r4r4_r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetRect(Single, Single, Single, Single, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayoutUtility
bool w_S_r4r4r4r4_r4r4r4r4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, Il2CppArray* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetRect(Single, Single, Single, Single, UnityEngine.GUIStyle) declare in UnityEngine.GUILayoutUtility
bool w_S_r4r4r4r4_r4r4r4r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, Il2CppObject* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetRect(Single, Single, Single, Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayoutUtility
bool w_S_r4r4r4r4_r4r4r4r4oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4oVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len < 5) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        auto TIp5_V = il2cpp::vm::Class::GetElementClass(TIp5);if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5_V, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal ref params
    Il2CppArray* p5 = Params<void*>::PackRef(apis, env, info, TIp5, js_args_len, 5);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, Il2CppObject* p4, Il2CppArray* p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color ColorHSV(Single, Single, Single, Single, Single, Single) declare in UnityEngine.Random
bool w_S_r4r4r4r4_r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color ColorHSV(Single, Single, Single, Single, Single, Single, Single, Single) declare in UnityEngine.Random
bool w_S_r4r4r4r4_r4r4r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 float4(Double) declare in Unity.Mathematics.math
bool w_S_r4r4r4r4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(double p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion GetTrackerRotation(System.String) declare in UnityEngine.ClusterInput
bool w_S_r4r4r4r4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 Vector4Field(System.String, UnityEngine.Vector4, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_r4r4r4r4_sS_r4r4r4r4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_sS_r4r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppString* p0, struct S_r4r4r4r4_ p1, Il2CppArray* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion get_rotation() declare in UnityEngine.AI.NavMeshData
bool w_S_r4r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetViewport(Int32) declare in UnityEngine.Experimental.Rendering.XRPass
bool w_S_r4r4r4r4_tDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tDi4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color GetColor(UnityEngine.Vector3Int) declare in UnityEngine.Tilemaps.ITilemap
bool w_S_r4r4r4r4_tS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_i4i4i4_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 ApplyXRViewCenterOffset(UnityEngine.Vector2) declare in UnityEngine.Experimental.Rendering.XRPass
bool w_S_r4r4r4r4_tS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect Add(UnityEngine.Rect) declare in UnityEngine.RectOffset
bool w_S_r4r4r4r4_tS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4 NextFloat4(Unity.Mathematics.float4, Unity.Mathematics.float4) declare in Unity.Mathematics.Random
bool w_S_r4r4r4r4_tS_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect ComputeAxisAlignedBound(UnityEngine.Rect, UnityEngine.Matrix4x4) declare in UnityEditor.Experimental.GraphView.RectangleSelector
bool w_S_r4r4r4r4_tS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 VectorProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, UnityEngine.GUIContent) declare in UnityEditor.MaterialEditor
bool w_S_r4r4r4r4_tS_r4r4r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color ColorProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, System.String) declare in UnityEditor.MaterialEditor
bool w_S_r4r4r4r4_tS_r4r4r4r4_os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4r4r4_os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion GetRotation(UnityEngine.Animations.AnimationStream) declare in UnityEngine.Animations.TransformStreamHandle
bool w_S_r4r4r4r4_tS_u4pppppp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_u4pppppp_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_u4pppppp_ p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion GetIKRotation(UnityEngine.AvatarIKGoal) declare in UnityEngine.Animator
bool w_S_r4r4r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetCellRect(Int32, UnityEngine.Rect) declare in UnityEditor.IMGUI.Controls.MultiColumnHeader
bool w_S_r4r4r4r4_ti4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ti4S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color GetPixel(Int32, Int32) declare in UnityEngine.WebCamTexture
bool w_S_r4r4r4r4_ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color GetPixel(Int32, Int32, Int32) declare in UnityEngine.Texture2D
bool w_S_r4r4r4r4_ti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ti4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color GetPixel(UnityEngine.CubemapFace, Int32, Int32, Int32) declare in UnityEngine.Cubemap
bool w_S_r4r4r4r4_ti4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ti4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect GetScreenRect(UnityEngine.Camera) declare in UnityEngine.GUIElement
bool w_S_r4r4r4r4_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 GetPayloadScaleOffset(UnityEngine.Texture, UnityEngine.Vector4 ByRef) declare in UnityEngine.Rendering.PowerOfTwoTextureAtlas
bool w_S_r4r4r4r4_toPS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_toPS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4r4_));
        p1 = &up1;
    }
        

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, struct S_r4r4r4r4_* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext) declare in UnityEngine.UIElements.UxmlColorAttributeDescription
bool w_S_r4r4r4r4_toS_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_toS_oooo_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, struct S_oooo_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect ChangeCoordinatesTo(UnityEngine.UIElements.VisualElement, UnityEngine.UIElements.VisualElement, UnityEngine.Rect) declare in UnityEngine.UIElements.VisualElementExtensions
bool w_S_r4r4r4r4_toS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_toS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector4 VectorProperty(UnityEditor.MaterialProperty, UnityEngine.GUIContent) declare in UnityEditor.MaterialEditor
bool w_S_r4r4r4r4_too(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_too");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect TexturePropertySingleLine(UnityEngine.GUIContent, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty) declare in UnityEditor.MaterialEditor
bool w_S_r4r4r4r4_tooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect TexturePropertyWithHDRColor(UnityEngine.GUIContent, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty, Boolean) declare in UnityEditor.MaterialEditor
bool w_S_r4r4r4r4_tooob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tooob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect TexturePropertySingleLine(UnityEngine.GUIContent, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty) declare in UnityEditor.MaterialEditor
bool w_S_r4r4r4r4_toooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_toooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect TexturePropertyWithHDRColor(UnityEngine.GUIContent, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty, UnityEditor.ColorPickerHDRConfig, Boolean) declare in UnityEditor.MaterialEditor
bool w_S_r4r4r4r4_toooob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_toooob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rect TexturePropertyTwoLines(UnityEngine.GUIContent, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty, UnityEngine.GUIContent, UnityEditor.MaterialProperty) declare in UnityEditor.MaterialEditor
bool w_S_r4r4r4r4_tooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tooooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color ColorProperty(UnityEditor.MaterialProperty, System.String) declare in UnityEditor.MaterialEditor
bool w_S_r4r4r4r4_tos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color Evaluate(Single) declare in UnityEngine.Gradient
bool w_S_r4r4r4r4_tr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,float p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color GetPixelBilinear(Single, Single) declare in UnityEngine.Texture2D
bool w_S_r4r4r4r4_tr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tr4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,float p0, float p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color GetPixelBilinear(Single, Single, Int32) declare in UnityEngine.Texture2D
bool w_S_r4r4r4r4_tr4r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tr4r4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,float p0, float p1, int32_t p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color GetPixelBilinear(Single, Single, Single) declare in UnityEngine.Texture3D
bool w_S_r4r4r4r4_tr4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tr4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color GetPixelBilinear(Single, Single, Single, Int32) declare in UnityEngine.Texture3D
bool w_S_r4r4r4r4_tr4r4r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tr4r4r4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,float p0, float p1, float p2, int32_t p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Quaternion GetQuaternion(System.String) declare in UnityEngine.Animator
bool w_S_r4r4r4r4_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color GetColor(System.String, Boolean ByRef) declare in UnityEditor.MaterialEditor
bool w_S_r4r4r4r4_tsPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tsPb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppString* p0, bool* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color ColorProperty(System.String, System.String) declare in UnityEditor.MaterialEditor
bool w_S_r4r4r4r4_tss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color ToRGBA(UInt32) declare in UnityEngine.Rendering.ColorUtils
bool w_S_r4r4r4r4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Keyframe get_Item(Int32) declare in UnityEngine.AnimationCurve
bool w_S_r4r4r4r4i4i4r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4i4i4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4i4i4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r4r4r4r4i4i4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.TextCore.GlyphMetrics get_metrics() declare in UnityEngine.TextCore.Glyph
bool w_S_r4r4r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix3x2 get_Identity() declare in System.Numerics.Matrix3x2
bool w_S_r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix3x2 CreateTranslation(System.Numerics.Vector2) declare in System.Numerics.Matrix3x2
bool w_S_r4r4r4r4r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix3x2 CreateScale(System.Numerics.Vector2, System.Numerics.Vector2) declare in System.Numerics.Matrix3x2
bool w_S_r4r4r4r4r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix3x2 Negate(System.Numerics.Matrix3x2) declare in System.Numerics.Matrix3x2
bool w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4_ p0, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix3x2 Add(System.Numerics.Matrix3x2, System.Numerics.Matrix3x2) declare in System.Numerics.Matrix3x2
bool w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4_ p0, struct S_r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix3x2 Lerp(System.Numerics.Matrix3x2, System.Numerics.Matrix3x2, Single) declare in System.Numerics.Matrix3x2
bool w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4_ p0, struct S_r4r4r4r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix3x2 Multiply(System.Numerics.Matrix3x2, Single) declare in System.Numerics.Matrix3x2
bool w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4_ p0, float p1, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix3x2 CreateScale(Single) declare in System.Numerics.Matrix3x2
bool w_S_r4r4r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(float p0, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix3x2 CreateScale(Single, System.Numerics.Vector2) declare in System.Numerics.Matrix3x2
bool w_S_r4r4r4r4r4r4_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(float p0, struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix3x2 CreateTranslation(Single, Single) declare in System.Numerics.Matrix3x2
bool w_S_r4r4r4r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(float p0, float p1, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix3x2 CreateScale(Single, Single, System.Numerics.Vector2) declare in System.Numerics.Matrix3x2
bool w_S_r4r4r4r4r4r4_r4r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_r4r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(float p0, float p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.FrustumPlanes get_decomposeProjection() declare in UnityEngine.Matrix4x4
bool w_S_r4r4r4r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.JointLimits get_limits() declare in UnityEngine.HingeJoint
bool w_S_r4r4r4r4r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.ArticulationDrive get_xDrive() declare in UnityEngine.ArticulationBody
bool w_S_r4r4r4r4r4r4r4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4r4r4r4r4i4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4r4r4r4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 get_matrix() declare in UnityEngine.Gizmos
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 CreateReflection(System.Numerics.Plane) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_S_r4r4r4_r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_S_r4r4r4_r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv0);
    S_S_r4r4r4_r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4_r4_ p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 op_Implicit(Unity.Mathematics.float4x4) declare in Unity.Mathematics.float4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 Scale(UnityEngine.Vector3) declare in UnityEngine.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 CreateShadow(System.Numerics.Vector3, System.Numerics.Plane) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_S_r4r4r4_r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_S_r4r4r4_r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_S_r4r4r4_r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 CreateScale(System.Numerics.Vector3, System.Numerics.Vector3) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 LookAt(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 CreateBillboard(System.Numerics.Vector3, System.Numerics.Vector3, System.Numerics.Vector3, System.Numerics.Vector3) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 CreateConstrainedBillboard(System.Numerics.Vector3, System.Numerics.Vector3, System.Numerics.Vector3, System.Numerics.Vector3, System.Numerics.Vector3) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 TRS(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3) declare in UnityEngine.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 CreateFromAxisAngle(System.Numerics.Vector3, Single) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p0, float p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 Rotate(UnityEngine.Quaternion) declare in UnityEngine.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 Frustum(UnityEngine.FrustumPlanes) declare in UnityEngine.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4_ p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 Inverse(UnityEngine.Matrix4x4) declare in UnityEngine.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 Transform(System.Numerics.Matrix4x4, System.Numerics.Quaternion) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 op_Multiply(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4) declare in UnityEngine.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 MultiplyOrthoMatrix(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4, Boolean) declare in UnityEngine.Rendering.CoreMatrixUtils
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, bool p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 Lerp(System.Numerics.Matrix4x4, System.Numerics.Matrix4x4, Single) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 GetGPUProjectionMatrix(UnityEngine.Matrix4x4, Boolean) declare in UnityEngine.GL
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, bool p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 Multiply(System.Numerics.Matrix4x4, Single) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, float p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 GetGlobalMatrix(Int32) declare in UnityEngine.Shader
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 CreateScale(Single) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 CreateScale(Single, System.Numerics.Vector3) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p0, struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 CreateTranslation(Single, Single, Single) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Matrix4x4 CreateScale(Single, Single, Single, System.Numerics.Vector3) declare in System.Numerics.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, struct S_r4r4r4_ p3, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 Perspective(Single, Single, Single, Single) declare in UnityEngine.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 Ortho(Single, Single, Single, Single, Single, Single) declare in UnityEngine.Matrix4x4
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 GetGlobalMatrix(System.String) declare in UnityEngine.Shader
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 get_transform() declare in UnityEngine.AI.NavMeshBuildSource
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 GetProjMatrix(Int32) declare in UnityEngine.Experimental.Rendering.XRPass
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tDi4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 GetTransformMatrix(UnityEngine.Vector3Int) declare in UnityEngine.Tilemaps.ITilemap
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,struct S_i4i4i4_ p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 CalculateObliqueMatrix(UnityEngine.Vector4) declare in UnityEngine.Camera
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 GetLocalToParentMatrix(UnityEngine.Animations.AnimationStream) declare in UnityEngine.Animations.TransformStreamHandle
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_u4pppppp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_u4pppppp_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,struct S_u4pppppp_ p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 PolygonLocalToWorldMatrix(UnityEngine.Experimental.AI.PolygonId) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,struct S_u8_ p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 GetStereoNonJitteredProjectionMatrix(StereoscopicEye) declare in UnityEngine.Camera
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 GetLocalMatrixAtTime(Single) declare in TreeEditor.TreeNode
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,float p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Matrix4x4 GetMatrix(System.String) declare in UnityEngine.MaterialPropertyBlock
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.SphericalHarmonicsL2 get_ambientProbe() declare in UnityEngine.RenderSettings
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.SphericalHarmonicsL2 op_Addition(UnityEngine.Rendering.SphericalHarmonicsL2, UnityEngine.Rendering.SphericalHarmonicsL2) declare in UnityEngine.Rendering.SphericalHarmonicsL2
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.SphericalHarmonicsL2 op_Multiply(UnityEngine.Rendering.SphericalHarmonicsL2, Single) declare in UnityEngine.Rendering.SphericalHarmonicsL2
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, float p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.SphericalHarmonicsL2 op_Multiply(Single, UnityEngine.Rendering.SphericalHarmonicsL2) declare in UnityEngine.Rendering.SphericalHarmonicsL2
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ValueTuple`2[System.Single,System.String] GetMaximumIntensity() declare in UnityEditor.Rendering.IESEngine
bool w_S_r4s_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4s_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r4s_ (*FuncToCall)(void*,const void* method);
    struct S_r4s_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.LocationInfo get_lastData() declare in UnityEngine.LocationService
bool w_S_r8r4r4r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r8r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r8r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 mul(Unity.Mathematics.double2x4, Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_r8r8_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, struct S_r8r8r8r8_ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 mul(Unity.Mathematics.double2x3, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_r8r8_S_S_r8r8_S_r8r8_S_r8r8__S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_S_r8r8_S_r8r8_S_r8r8__S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, struct S_r8r8r8_ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 mul(Unity.Mathematics.double2x2, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_S_r8r8_S_r8r8__S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_S_r8r8_S_r8r8__S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, struct S_r8r8_ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 double2(Unity.Mathematics.half2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_S_u2_S_u2__ p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 double2(Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_bb_ p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 double2(Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_i4i4_ p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex op_Explicit(System.Decimal) declare in System.Numerics.Complex
bool w_S_r8r8_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex op_Explicit(System.Numerics.BigInteger) declare in System.Numerics.Complex
bool w_S_r8r8_S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_i4o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_i4o_ p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 double2(Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex Negate(System.Numerics.Complex) declare in System.Numerics.Complex
bool w_S_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 normalizesafe(Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8_DS_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_DS_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal valuetype  with default
    S_r8r8_ p1 = OptionalParameter<S_r8r8_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 modf(Unity.Mathematics.double2, Unity.Mathematics.double2 ByRef) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8_PS_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_PS_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal Pstruct
    S_r8r8_* p1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r8r8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r8r8_));
        p1 = &up1;
    }
        

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_* p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 mul(Unity.Mathematics.double2, Unity.Mathematics.double2x2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8_S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_S_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8__ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex Add(System.Numerics.Complex, System.Numerics.Complex) declare in System.Numerics.Complex
bool w_S_r8r8_S_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 projectsafe(Unity.Mathematics.double2, Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8_S_r8r8_DS_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_S_r8r8_DS_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal valuetype  with default
    S_r8r8_ p2 = OptionalParameter<S_r8r8_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, struct S_r8r8_ p2, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 select(Unity.Mathematics.double2, Unity.Mathematics.double2, Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8_S_r8r8_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_S_r8r8_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal struct
    S_bb_* pp2 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv2);
    S_bb_ p2 = pp2 ? *pp2 : S_bb_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, struct S_bb_ p2, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 lerp(Unity.Mathematics.double2, Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8_S_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_S_r8r8_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv2);
    S_r8r8_ p2 = pp2 ? *pp2 : S_r8r8_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, struct S_r8r8_ p2, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 remap(Unity.Mathematics.double2, Unity.Mathematics.double2, Unity.Mathematics.double2, Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8_S_r8r8_S_r8r8_S_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_S_r8r8_S_r8r8_S_r8r8_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv2);
    S_r8r8_ p2 = pp2 ? *pp2 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp3 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv3);
    S_r8r8_ p3 = pp3 ? *pp3 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp4 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv4);
    S_r8r8_ p4 = pp4 ? *pp4 : S_r8r8_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, struct S_r8r8_ p2, struct S_r8r8_ p3, struct S_r8r8_ p4, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 select(Unity.Mathematics.double2, Unity.Mathematics.double2, Boolean) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8_S_r8r8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_S_r8r8_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, bool p2, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 lerp(Unity.Mathematics.double2, Unity.Mathematics.double2, Double) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8_S_r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_S_r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, double p2, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 shuffle(Unity.Mathematics.double2, Unity.Mathematics.double2, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8_S_r8r8_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_S_r8r8_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex Log(System.Numerics.Complex, Double) declare in System.Numerics.Complex
bool w_S_r8r8_S_r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p0, double p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 mul(Unity.Mathematics.double3, Unity.Mathematics.double3x2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8r8_S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8r8_S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 shuffle(Unity.Mathematics.double3, Unity.Mathematics.double3, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8r8_S_r8r8r8_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8r8_S_r8r8r8_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 mul(Unity.Mathematics.double4, Unity.Mathematics.double4x2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 shuffle(Unity.Mathematics.double4, Unity.Mathematics.double4, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r8r8_S_r8r8r8r8_S_r8r8r8r8_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8r8r8_S_r8r8r8r8_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 double2(Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_r8r8_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_u2_ p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 double2(Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_r8r8_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};

    typedef struct S_r8r8_ (*FuncToCall)(struct S_u4u4_ p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 double2(Boolean) declare in Unity.Mathematics.math
bool w_S_r8r8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8_ (*FuncToCall)(bool p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex op_Implicit(SByte) declare in System.Numerics.Complex
bool w_S_r8r8_i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_i1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8_ (*FuncToCall)(int8_t p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex op_Implicit(Int16) declare in System.Numerics.Complex
bool w_S_r8r8_i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_i2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8_ (*FuncToCall)(int16_t p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex op_Implicit(Int32) declare in System.Numerics.Complex
bool w_S_r8r8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex op_Implicit(Int64) declare in System.Numerics.Complex
bool w_S_r8r8_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8_ (*FuncToCall)(int64_t p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex op_Implicit(Single) declare in System.Numerics.Complex
bool w_S_r8r8_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8_ (*FuncToCall)(float p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex op_Implicit(Double) declare in System.Numerics.Complex
bool w_S_r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8_ (*FuncToCall)(double p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 op_Multiply(Double, Unity.Mathematics.double2) declare in Unity.Mathematics.double2
bool w_S_r8r8_r8S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_r8S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef struct S_r8r8_ (*FuncToCall)(double p0, struct S_r8r8_ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex FromPolarCoordinates(Double, Double) declare in System.Numerics.Complex
bool w_S_r8r8_r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_r8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_r8r8_ (*FuncToCall)(double p0, double p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 get_xx() declare in Unity.Mathematics.double2
bool w_S_r8r8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r8r8_ (*FuncToCall)(void*,const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 NextDouble2(Unity.Mathematics.double2) declare in Unity.Mathematics.Random
bool w_S_r8r8_tS_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_tS_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};

    typedef struct S_r8r8_ (*FuncToCall)(void*,struct S_r8r8_ p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2 NextDouble2(Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.Random
bool w_S_r8r8_tS_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_tS_r8r8_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef struct S_r8r8_ (*FuncToCall)(void*,struct S_r8r8_ p0, struct S_r8r8_ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex op_Implicit(Byte) declare in System.Numerics.Complex
bool w_S_r8r8_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_u1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8_ (*FuncToCall)(uint8_t p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex op_Implicit(UInt16) declare in System.Numerics.Complex
bool w_S_r8r8_u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_u2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8_ (*FuncToCall)(uint16_t p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex op_Implicit(UInt32) declare in System.Numerics.Complex
bool w_S_r8r8_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Complex op_Implicit(UInt64) declare in System.Numerics.Complex
bool w_S_r8r8_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_u8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8_ (*FuncToCall)(uint64_t p0, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 mul(Unity.Mathematics.double3x4, Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, struct S_r8r8r8r8_ p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 mul(Unity.Mathematics.double3x3, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, struct S_r8r8r8_ p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 mul(Unity.Mathematics.double3x2, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_S_r8r8r8_S_r8r8r8__S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_S_r8r8r8_S_r8r8r8__S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, struct S_r8r8_ p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 rotate(Unity.Mathematics.double4x4, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_r8r8r8_ p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Unity.Mathematics.half3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2__ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_S_u2_S_u2_S_u2__ p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_bbb_ p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_i4i4i4_ p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 mul(Unity.Mathematics.double2, Unity.Mathematics.double2x3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8_S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8_S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 shuffle(Unity.Mathematics.double2, Unity.Mathematics.double2, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8_S_r8r8_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8_S_r8r8_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Unity.Mathematics.double2, Double) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8_ p0, double p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 normalizesafe(Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8_DS_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_DS_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal valuetype  with default
    S_r8r8r8_ p1 = OptionalParameter<S_r8r8r8_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 modf(Unity.Mathematics.double3, Unity.Mathematics.double3 ByRef) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8_PS_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_PS_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal Pstruct
    S_r8r8r8_* p1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r8r8r8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r8r8r8_));
        p1 = &up1;
    }
        

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_* p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 mul(Unity.Mathematics.double3, Unity.Mathematics.double3x3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 min(Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 projectsafe(Unity.Mathematics.double3, Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8_S_r8r8r8_DS_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_S_r8r8r8_DS_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal valuetype  with default
    S_r8r8r8_ p2 = OptionalParameter<S_r8r8r8_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, struct S_r8r8r8_ p2, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 select(Unity.Mathematics.double3, Unity.Mathematics.double3, Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_bbb_* pp2 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv2);
    S_bbb_ p2 = pp2 ? *pp2 : S_bbb_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, struct S_bbb_ p2, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 lerp(Unity.Mathematics.double3, Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv2);
    S_r8r8r8_ p2 = pp2 ? *pp2 : S_r8r8r8_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, struct S_r8r8r8_ p2, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 remap(Unity.Mathematics.double3, Unity.Mathematics.double3, Unity.Mathematics.double3, Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv2);
    S_r8r8r8_ p2 = pp2 ? *pp2 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp3 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv3);
    S_r8r8r8_ p3 = pp3 ? *pp3 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp4 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv4);
    S_r8r8r8_ p4 = pp4 ? *pp4 : S_r8r8r8_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, struct S_r8r8r8_ p2, struct S_r8r8r8_ p3, struct S_r8r8r8_ p4, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 select(Unity.Mathematics.double3, Unity.Mathematics.double3, Boolean) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8_S_r8r8r8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_S_r8r8r8_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, bool p2, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 lerp(Unity.Mathematics.double3, Unity.Mathematics.double3, Double) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8_S_r8r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_S_r8r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, double p2, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 shuffle(Unity.Mathematics.double3, Unity.Mathematics.double3, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8_S_r8r8r8_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_S_r8r8r8_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 op_Multiply(Unity.Mathematics.double3, Double) declare in Unity.Mathematics.double3
bool w_S_r8r8r8_S_r8r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, double p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 mul(Unity.Mathematics.double4, Unity.Mathematics.double4x3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 shuffle(Unity.Mathematics.double4, Unity.Mathematics.double4, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_r8r8r8r8_S_r8r8r8r8_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_r8r8r8r8_S_r8r8r8r8_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_u2_ p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_r8r8r8_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(struct S_u4u4u4_ p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Boolean) declare in Unity.Mathematics.math
bool w_S_r8r8r8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8r8_ (*FuncToCall)(bool p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Int32) declare in Unity.Mathematics.math
bool w_S_r8r8r8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8r8_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Single) declare in Unity.Mathematics.math
bool w_S_r8r8r8_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8r8_ (*FuncToCall)(float p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Double) declare in Unity.Mathematics.math
bool w_S_r8r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8r8_ (*FuncToCall)(double p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Double, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_r8r8r8_r8S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_r8S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(double p0, struct S_r8r8_ p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 op_Multiply(Double, Unity.Mathematics.double3) declare in Unity.Mathematics.double3
bool w_S_r8r8r8_r8S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_r8S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(double p0, struct S_r8r8r8_ p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(Double, Double, Double) declare in Unity.Mathematics.math
bool w_S_r8r8r8_r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_r8r8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef struct S_r8r8r8_ (*FuncToCall)(double p0, double p1, double p2, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 get_xxx() declare in Unity.Mathematics.double2
bool w_S_r8r8r8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r8r8r8_ (*FuncToCall)(void*,const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 NextDouble3(Unity.Mathematics.double3) declare in Unity.Mathematics.Random
bool w_S_r8r8r8_tS_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_tS_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(void*,struct S_r8r8r8_ p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 NextDouble3(Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.Random
bool w_S_r8r8r8_tS_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_tS_r8r8r8_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef struct S_r8r8r8_ (*FuncToCall)(void*,struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3 double3(UInt32) declare in Unity.Mathematics.math
bool w_S_r8r8r8_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8r8_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 mul(Unity.Mathematics.double4x4, Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_r8r8r8r8_ p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 mul(Unity.Mathematics.double4x3, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_r8r8r8_ p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 mul(Unity.Mathematics.double4x2, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8__S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8__S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_r8r8_ p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Unity.Mathematics.half4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_S_u2_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_S_u2_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2_S_u2__ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_S_u2_S_u2_S_u2_S_u2__ p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_bbbb_ p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_i4i4i4i4_ p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 mul(Unity.Mathematics.double2, Unity.Mathematics.double2x4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 shuffle(Unity.Mathematics.double2, Unity.Mathematics.double2, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8_S_r8r8_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8_S_r8r8_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Unity.Mathematics.double2, Double, Double) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8_r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8_r8r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8_ p0, double p1, double p2, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 mul(Unity.Mathematics.double3, Unity.Mathematics.double3x4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 shuffle(Unity.Mathematics.double3, Unity.Mathematics.double3, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8_S_r8r8r8_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8_S_r8r8r8_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Unity.Mathematics.double3, Double) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8_ p0, double p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 normalizesafe(Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8r8_DS_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_DS_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal valuetype  with default
    S_r8r8r8r8_ p1 = OptionalParameter<S_r8r8r8r8_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 modf(Unity.Mathematics.double4, Unity.Mathematics.double4 ByRef) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8r8_PS_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_PS_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal Pstruct
    S_r8r8r8r8_* p1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r8r8r8r8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r8r8r8r8_));
        p1 = &up1;
    }
        

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_* p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 mul(Unity.Mathematics.double4, Unity.Mathematics.double4x4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 min(Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 projectsafe(Unity.Mathematics.double4, Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_DS_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_DS_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal valuetype  with default
    S_r8r8r8r8_ p2 = OptionalParameter<S_r8r8r8r8_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, struct S_r8r8r8r8_ p2, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 select(Unity.Mathematics.double4, Unity.Mathematics.double4, Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_bbbb_* pp2 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv2);
    S_bbbb_ p2 = pp2 ? *pp2 : S_bbbb_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, struct S_bbbb_ p2, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 lerp(Unity.Mathematics.double4, Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv2);
    S_r8r8r8r8_ p2 = pp2 ? *pp2 : S_r8r8r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, struct S_r8r8r8r8_ p2, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 remap(Unity.Mathematics.double4, Unity.Mathematics.double4, Unity.Mathematics.double4, Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv2);
    S_r8r8r8r8_ p2 = pp2 ? *pp2 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp3 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv3);
    S_r8r8r8r8_ p3 = pp3 ? *pp3 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp4 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv4);
    S_r8r8r8r8_ p4 = pp4 ? *pp4 : S_r8r8r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, struct S_r8r8r8r8_ p2, struct S_r8r8r8r8_ p3, struct S_r8r8r8r8_ p4, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 select(Unity.Mathematics.double4, Unity.Mathematics.double4, Boolean) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, bool p2, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 lerp(Unity.Mathematics.double4, Unity.Mathematics.double4, Double) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, double p2, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 shuffle(Unity.Mathematics.double4, Unity.Mathematics.double4, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 op_Multiply(Unity.Mathematics.double4, Double) declare in Unity.Mathematics.double4
bool w_S_r8r8r8r8_S_r8r8r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_r8r8r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_r8r8r8r8_ p0, double p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_u2_ p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(struct S_u4u4u4u4_ p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Boolean) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(bool p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Int32) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Single) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(float p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Double) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(double p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Double, Unity.Mathematics.double2, Double) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_r8S_r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_r8S_r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(double p0, struct S_r8r8_ p1, double p2, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Double, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_r8S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_r8S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(double p0, struct S_r8r8r8_ p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 op_Multiply(Double, Unity.Mathematics.double4) declare in Unity.Mathematics.double4
bool w_S_r8r8r8r8_r8S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_r8S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(double p0, struct S_r8r8r8r8_ p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Double, Double, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_r8r8S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_r8r8S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv2);
    S_r8r8_ p2 = pp2 ? *pp2 : S_r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(double p0, double p1, struct S_r8r8_ p2, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(Double, Double, Double, Double) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_r8r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_r8r8r8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(double p0, double p1, double p2, double p3, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 get_xxxx() declare in Unity.Mathematics.double2
bool w_S_r8r8r8r8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_r8r8r8r8_ (*FuncToCall)(void*,const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 NextDouble4(Unity.Mathematics.double4) declare in Unity.Mathematics.Random
bool w_S_r8r8r8r8_tS_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_tS_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(void*,struct S_r8r8r8r8_ p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 NextDouble4(Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.Random
bool w_S_r8r8r8r8_tS_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_tS_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};

    typedef struct S_r8r8r8r8_ (*FuncToCall)(void*,struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4 double4(UInt32) declare in Unity.Mathematics.math
bool w_S_r8r8r8r8_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8r8r8_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8r8r8_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_r8r8r8r8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Bee.BeeDriver.ActiveBuildStatus get_Status() declare in Bee.BeeDriver.ActiveBuild
bool w_S_sN_bS_i4i4___t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sN_bS_i4i4___t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_sN_bS_i4i4___ (*FuncToCall)(void*,const void* method);
    struct S_sN_bS_i4i4___ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Collections.Generic.KeyValuePair`2[System.String,System.Object] get_Item(Int32) declare in System.Diagnostics.TagList
bool w_S_sO_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sO_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_sO_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_sO_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.Serialization.SerializationEntry get_Current() declare in System.Runtime.Serialization.SerializationInfoEnumerator
bool w_S_sOo_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sOo_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_sOo_ (*FuncToCall)(void*,const void* method);
    struct S_sOo_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.ShaderGraph.Internal.GraphCode GetCode(UnityEditor.ShaderGraph.Internal.OutputMetadata[]) declare in UnityEditor.ShaderGraph.Internal.ShaderGraphVfxAsset
bool w_S_sS_oi4i4i4i4i4i4bbbbbobbbbb_o_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sS_oi4i4i4i4i4i4bbbbbobbbbb_o_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_sS_oi4i4i4i4i4i4bbbbbobbbbb_o_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_sS_oi4i4i4i4i4i4bbbbbobbbbb_o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Timeline.TrackDrawOptions GetTrackOptions(UnityEngine.Timeline.TrackAsset, UnityEngine.Object) declare in UnityEditor.Timeline.TrackEditor
bool w_S_sS_r4r4r4r4_r4o_too(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sS_r4r4r4r4_r4o_too");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_sS_r4r4r4r4_r4o_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_sS_r4r4r4r4_r4o_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Security.Cryptography.HashAlgorithmName get_MD5() declare in System.Security.Cryptography.HashAlgorithmName
bool w_S_s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_s_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_s_ (*FuncToCall)(const void* method);
    struct S_s_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Diagnostics.ActivityTraceId CreateFromBytes(System.ReadOnlySpan`1[System.Byte]) declare in System.Diagnostics.ActivityTraceId
bool w_S_s_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_s_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef struct S_s_ (*FuncToCall)(struct S_S_p_i4_ p0, const void* method);
    struct S_s_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.NamedBuildTarget FromBuildTargetGroup(UnityEditor.BuildTargetGroup) declare in UnityEditor.Build.NamedBuildTarget
bool w_S_s_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_s_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_s_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_s_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.InteropServices.OSPlatform Create(System.String) declare in System.Runtime.InteropServices.OSPlatform
bool w_S_s_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_s_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_s_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_s_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Security.Cryptography.HashAlgorithmName get_HashAlgorithm() declare in System.Security.Cryptography.Rfc2898DeriveBytes
bool w_S_s_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_s_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_s_ (*FuncToCall)(void*,const void* method);
    struct S_s_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.ShaderInfo GetShaderInfo(UnityEngine.Shader) declare in UnityEditor.ShaderUtil
bool w_S_sbbb_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sbbb_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_sbbb_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_sbbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.MPE.ChannelClientInfo GetChannelClientInfo(Int32) declare in UnityEditor.MPE.ChannelClient
bool w_S_si4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_si4i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_si4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.MPE.ChannelClientInfo GetChannelClientInfo(System.String) declare in UnityEditor.MPE.ChannelClient
bool w_S_si4i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_si4i4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_si4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.MPE.ChannelClientInfo GetChannelClientInfo() declare in UnityEditor.MPE.ChannelClient
bool w_S_si4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_si4i4_ (*FuncToCall)(void*,const void* method);
    struct S_si4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.StringView Trim(Char[]) declare in UnityEditor.Search.StringView
bool w_S_si4i4_tVc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4_tVc");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive params
    Il2CppArray* p0 = Params<Il2CppChar>::PackPrimitive(apis, env, info, TIp0, js_args_len, 0);
                

    typedef struct S_si4i4_ (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    struct S_si4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.StringView Substring(Int32) declare in UnityEditor.Search.StringView
bool w_S_si4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_si4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_si4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.StringView Substring(Int32, Int32) declare in UnityEditor.Search.StringView
bool w_S_si4i4_ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_si4i4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct S_si4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.TextCore.Text.FontAssetCreationEditorSettings get_fontAssetCreationEditorSettings() declare in UnityEngine.TextCore.Text.FontAsset
bool w_S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_ (*FuncToCall)(void*,const void* method);
    struct S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Security.Cryptography.CngProperty GetProperty(System.String, System.Security.Cryptography.CngPropertyOptions) declare in System.Security.Cryptography.CngKey
bool w_S_si4oN_bi4__tsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4oN_bi4__tsi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_si4oN_bi4__ (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, const void* method);
    struct S_si4oN_bi4__ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// GluonGui.WorkspaceWindow.Views.Checkin.Operations.CheckinProgressData CalculateProgress(Codice.Client.GameUI.Checkin.CheckinProgress, ProgressData, Codice.Client.BaseCommands.CheckIn.Progress.CheckinUploadProgressRender, System.String, Boolean) declare in GluonGui.WorkspaceWindow.Views.Checkin.Operations.CheckinProgressDataCalculator
bool w_S_si4si4sb_ooosb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4si4sb_ooosb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef struct S_si4si4sb_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, bool p4, const void* method);
    struct S_si4si4sb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.SearchDocument GetDocument(Int32) declare in UnityEditor.Search.SearchIndexer
bool w_S_si4ssi4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4ssi4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_si4ssi4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_si4ssi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Collections.Generic.KeyValuePair`2[System.String,System.Text.Json.Nodes.JsonNode] GetAt(Int32) declare in System.Text.Json.Nodes.JsonObject
bool w_S_so_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_so_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_so_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_so_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ValueTuple`2[System.String,UnityEngine.Texture] GenerateCubeCookie(UnityEditor.TextureImporterCompression, Int32) declare in UnityEditor.Rendering.IESEngine
bool w_S_so_ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_so_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_so_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct S_so_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ValueTuple`2[System.String,UnityEngine.Texture] Generate2DCookie(UnityEditor.TextureImporterCompression, Single, Int32, Boolean) declare in UnityEditor.Rendering.IESEngine
bool w_S_so_ti4r4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_so_ti4r4i4b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef struct S_so_ (*FuncToCall)(void*,int32_t p0, float p1, int32_t p2, bool p3, const void* method);
    struct S_so_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Explicit(System.Data.SqlTypes.SqlInt16) declare in System.Data.SqlTypes.SqlString
bool w_S_soi4i4b_S_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_S_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};

    typedef struct S_soi4i4b_ (*FuncToCall)(struct S_bi2_ p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Explicit(System.Data.SqlTypes.SqlInt32) declare in System.Data.SqlTypes.SqlString
bool w_S_soi4i4b_S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_S_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};

    typedef struct S_soi4i4b_ (*FuncToCall)(struct S_bi4_ p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Explicit(System.Data.SqlTypes.SqlDateTime) declare in System.Data.SqlTypes.SqlString
bool w_S_soi4i4b_S_bi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_S_bi4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4i4_* pp0 = DataTransfer::GetPointer<S_bi4i4_>(apis, env, _sv0);
    S_bi4i4_ p0 = pp0 ? *pp0 : S_bi4i4_ {};

    typedef struct S_soi4i4b_ (*FuncToCall)(struct S_bi4i4_ p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Explicit(System.Data.SqlTypes.SqlInt64) declare in System.Data.SqlTypes.SqlString
bool w_S_soi4i4b_S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_S_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef struct S_soi4i4b_ (*FuncToCall)(struct S_bi8_ p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Explicit(System.Data.SqlTypes.SqlSingle) declare in System.Data.SqlTypes.SqlString
bool w_S_soi4i4b_S_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_S_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};

    typedef struct S_soi4i4b_ (*FuncToCall)(struct S_br4_ p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Explicit(System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlString
bool w_S_soi4i4b_S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_S_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};

    typedef struct S_soi4i4b_ (*FuncToCall)(struct S_br8_ p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Explicit(System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlString
bool w_S_soi4i4b_S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_S_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};

    typedef struct S_soi4i4b_ (*FuncToCall)(struct S_bu1_ p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Explicit(System.Data.SqlTypes.SqlGuid) declare in System.Data.SqlTypes.SqlString
bool w_S_soi4i4b_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_soi4i4b_ (*FuncToCall)(struct S_o_ p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Addition(System.Data.SqlTypes.SqlString, System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlString
bool w_S_soi4i4b_S_soi4i4b_S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_S_soi4i4b_S_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};
    // JSValToCSVal struct
    S_soi4i4b_* pp1 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv1);
    S_soi4i4b_ p1 = pp1 ? *pp1 : S_soi4i4b_ {};

    typedef struct S_soi4i4b_ (*FuncToCall)(struct S_soi4i4b_ p0, struct S_soi4i4b_ p1, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Explicit(System.Data.SqlTypes.SqlBoolean) declare in System.Data.SqlTypes.SqlString
bool w_S_soi4i4b_S_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_S_u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef struct S_soi4i4b_ (*FuncToCall)(struct S_u1_ p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Explicit(System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlString
bool w_S_soi4i4b_S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_S_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_soi4i4b_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Explicit(System.Data.SqlTypes.SqlChars) declare in System.Data.SqlTypes.SqlChars
bool w_S_soi4i4b_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_soi4i4b_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString op_Implicit(System.String) declare in System.Data.SqlTypes.SqlString
bool w_S_soi4i4b_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_soi4i4b_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString ToSqlString() declare in System.Data.SqlTypes.SqlBoolean
bool w_S_soi4i4b_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_soi4i4b_ (*FuncToCall)(void*,const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString Adjust(System.Data.SqlTypes.SqlString) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_soi4i4b_tS_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_tS_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef struct S_soi4i4b_ (*FuncToCall)(void*,struct S_soi4i4b_ p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlString GetSqlString(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_soi4i4b_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_soi4i4b_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_soi4i4b_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_soi4i4b_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.SceneDependencyInfo CalculatePlayerDependenciesForScene(System.String, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagSet) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oS_i4i4i4i4_i4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oS_i4i4i4i4_i4i4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp1 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv1);
    S_oS_i4i4i4i4_i4i4_ p1 = pp1 ? *pp1 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_sooS_u4u4u4u4u4bbbbbbb__ (*FuncToCall)(Il2CppString* p0, struct S_oS_i4i4i4i4_i4i4_ p1, Il2CppObject* p2, const void* method);
    struct S_sooS_u4u4u4u4u4bbbbbbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.SceneDependencyInfo CalculatePlayerDependenciesForScene(System.String, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildUsageCache) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oS_i4i4i4i4_i4i4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oS_i4i4i4i4_i4i4_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp1 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv1);
    S_oS_i4i4i4i4_i4i4_ p1 = pp1 ? *pp1 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef struct S_sooS_u4u4u4u4u4bbbbbbb__ (*FuncToCall)(Il2CppString* p0, struct S_oS_i4i4i4i4_i4i4_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_sooS_u4u4u4u4u4bbbbbbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.SceneDependencyInfo CalculatePlayerDependenciesForScene(System.String, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildUsageCache, UnityEditor.Build.Content.DependencyType) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oS_i4i4i4i4_i4i4_ooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oS_i4i4i4i4_i4i4_ooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp1 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv1);
    S_oS_i4i4i4i4_i4i4_ p1 = pp1 ? *pp1 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef struct S_sooS_u4u4u4u4u4bbbbbbb__ (*FuncToCall)(Il2CppString* p0, struct S_oS_i4i4i4i4_i4i4_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, const void* method);
    struct S_sooS_u4u4u4u4u4bbbbbbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.SceneDependencyInfo PrepareScene(System.String, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildUsageCache, System.String) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oS_i4i4i4i4_i4i4_oos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oS_i4i4i4i4_i4i4_oos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp1 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv1);
    S_oS_i4i4i4i4_i4i4_ p1 = pp1 ? *pp1 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef struct S_sooS_u4u4u4u4u4bbbbbbb__ (*FuncToCall)(Il2CppString* p0, struct S_oS_i4i4i4i4_i4i4_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppString* p4, const void* method);
    struct S_sooS_u4u4u4u4u4bbbbbbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.SceneDependencyInfo PrepareScene(System.String, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagSet, System.String) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oS_i4i4i4i4_i4i4_os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oS_i4i4i4i4_i4i4_os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_oS_i4i4i4i4_i4i4_* pp1 = DataTransfer::GetPointer<S_oS_i4i4i4i4_i4i4_>(apis, env, _sv1);
    S_oS_i4i4i4i4_i4i4_ p1 = pp1 ? *pp1 : S_oS_i4i4i4i4_i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef struct S_sooS_u4u4u4u4u4bbbbbbb__ (*FuncToCall)(Il2CppString* p0, struct S_oS_i4i4i4i4_i4i4_ p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    struct S_sooS_u4u4u4u4u4bbbbbbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.PlayableBinding Create(System.String, UnityEngine.Object) declare in UnityEngine.Animations.AnimationPlayableBinding
bool w_S_sooo_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooo_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_sooo_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    struct S_sooo_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.PlayableBinding Create(System.String, UnityEngine.Object, System.Type) declare in UnityEngine.Playables.ScriptPlayableBinding
bool w_S_sooo_soo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooo_soo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_sooo_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_sooo_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.EditorCurveBinding SerializeReferenceCurve(System.String, System.Type, Int64, System.String, Boolean, Boolean) declare in UnityEditor.EditorCurveBinding
bool w_S_sosi4i4i4i4i4i4i4_soi8sbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sosi4i4i4i4i4i4i4_soi8sbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef struct S_sosi4i4i4i4i4i4i4_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, int64_t p2, Il2CppString* p3, bool p4, bool p5, const void* method);
    struct S_sosi4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.EditorCurveBinding FloatCurve(System.String, System.Type, System.String) declare in UnityEditor.EditorCurveBinding
bool w_S_sosi4i4i4i4i4i4i4_sos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sosi4i4i4i4i4i4i4_sos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef struct S_sosi4i4i4i4i4i4i4_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    struct S_sosi4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// log4net.Core.LoggingEventData GetLoggingEventData() declare in log4net.Core.LoggingEvent
bool w_S_sossS_u8_osssso_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sossS_u8_osssso_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_sossS_u8_osssso_ (*FuncToCall)(void*,const void* method);
    struct S_sossS_u8_osssso_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// log4net.Core.LoggingEventData GetLoggingEventData(log4net.Core.FixFlags) declare in log4net.Core.LoggingEvent
bool w_S_sossS_u8_osssso_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sossS_u8_osssso_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_sossS_u8_osssso_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_sossS_u8_osssso_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Explorer.UpdateProgressData CalculateProgressForRevisionDownload(Codice.Client.BaseCommands.UpdateProgress) declare in GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Explorer.UpdateProgressDataCalculator
bool w_S_sr8s_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sr8s_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_sr8s_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_sr8s_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Explorer.UpdateProgressData CalculateProgressForWorkspaceUpdate(System.String, Codice.Client.BaseCommands.UpdateProgress, ProgressData) declare in GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Explorer.UpdateProgressDataCalculator
bool w_S_sr8s_soo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_sr8s_soo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_sr8s_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_sr8s_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Installation get_CurrentInstallation() declare in Unity.CodeEditor.CodeEditor
bool w_S_ss_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ss_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_ss_ (*FuncToCall)(void*,const void* method);
    struct S_ss_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Timeline.MarkerDrawOptions GetMarkerOptions(UnityEngine.Timeline.IMarker) declare in UnityEditor.Timeline.MarkerEditor
bool w_S_ss_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ss_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_ss_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_ss_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Installation GetInstallationForPath(System.String) declare in Unity.CodeEditor.CodeEditor
bool w_S_ss_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ss_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_ss_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_ss_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// TMPro.FontAssetCreationSettings get_creationSettings() declare in TMPro.TMP_FontAsset
bool w_S_ssi4i4i4i4i4i4i4sssi4r4i4b_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ssi4i4i4i4i4i4i4sssi4r4i4b_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_ssi4i4i4i4i4i4i4sssi4r4i4b_ (*FuncToCall)(void*,const void* method);
    struct S_ssi4i4i4i4i4i4i4sssi4r4i4b_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Hardware.DevDevice get_none() declare in UnityEditor.Hardware.DevDevice
bool w_S_ssssi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ssssi4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_ssssi4i4_ (*FuncToCall)(const void* method);
    struct S_ssssi4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// MethodInfo ResolveMethodInfo(UInt64) declare in UnityEditor.Profiling.FrameDataView
bool w_S_ssu4_tu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ssu4_tu8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef struct S_ssu4_ (*FuncToCall)(void*,uint64_t p0, const void* method);
    struct S_ssu4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.GlobalKeyword Create(System.String) declare in UnityEngine.Rendering.GlobalKeyword
bool w_S_su4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_su4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_su4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_su4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.SerializedLocation get_header() declare in UnityEditor.Build.Content.ObjectSerializedInfo
bool w_S_su8u8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_su8u8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_su8u8_ (*FuncToCall)(void*,const void* method);
    struct S_su8u8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Explicit(System.Data.SqlTypes.SqlInt16) declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1_S_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_bi2_ p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Equality(System.Data.SqlTypes.SqlInt16, System.Data.SqlTypes.SqlInt16) declare in System.Data.SqlTypes.SqlInt16
bool w_S_u1_S_bi2_S_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_bi2_S_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};
    // JSValToCSVal struct
    S_bi2_* pp1 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv1);
    S_bi2_ p1 = pp1 ? *pp1 : S_bi2_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_bi2_ p0, struct S_bi2_ p1, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Explicit(System.Data.SqlTypes.SqlInt32) declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1_S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_bi4_ p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Equality(System.Data.SqlTypes.SqlInt32, System.Data.SqlTypes.SqlInt32) declare in System.Data.SqlTypes.SqlInt32
bool w_S_u1_S_bi4_S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_bi4_S_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};
    // JSValToCSVal struct
    S_bi4_* pp1 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv1);
    S_bi4_ p1 = pp1 ? *pp1 : S_bi4_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_bi4_ p0, struct S_bi4_ p1, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Equality(System.Data.SqlTypes.SqlDateTime, System.Data.SqlTypes.SqlDateTime) declare in System.Data.SqlTypes.SqlDateTime
bool w_S_u1_S_bi4i4_S_bi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_bi4i4_S_bi4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4i4_* pp0 = DataTransfer::GetPointer<S_bi4i4_>(apis, env, _sv0);
    S_bi4i4_ p0 = pp0 ? *pp0 : S_bi4i4_ {};
    // JSValToCSVal struct
    S_bi4i4_* pp1 = DataTransfer::GetPointer<S_bi4i4_>(apis, env, _sv1);
    S_bi4i4_ p1 = pp1 ? *pp1 : S_bi4i4_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_bi4i4_ p0, struct S_bi4i4_ p1, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Explicit(System.Data.SqlTypes.SqlInt64) declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1_S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_bi8_ p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Equality(System.Data.SqlTypes.SqlInt64, System.Data.SqlTypes.SqlInt64) declare in System.Data.SqlTypes.SqlInt64
bool w_S_u1_S_bi8_S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_bi8_S_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};
    // JSValToCSVal struct
    S_bi8_* pp1 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv1);
    S_bi8_ p1 = pp1 ? *pp1 : S_bi8_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_bi8_ p0, struct S_bi8_ p1, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Explicit(System.Data.SqlTypes.SqlSingle) declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1_S_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_br4_ p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Equality(System.Data.SqlTypes.SqlSingle, System.Data.SqlTypes.SqlSingle) declare in System.Data.SqlTypes.SqlSingle
bool w_S_u1_S_br4_S_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_br4_S_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};
    // JSValToCSVal struct
    S_br4_* pp1 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv1);
    S_br4_ p1 = pp1 ? *pp1 : S_br4_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_br4_ p0, struct S_br4_ p1, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Explicit(System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1_S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_br8_ p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Equality(System.Data.SqlTypes.SqlDouble, System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlDouble
bool w_S_u1_S_br8_S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_br8_S_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};
    // JSValToCSVal struct
    S_br8_* pp1 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv1);
    S_br8_ p1 = pp1 ? *pp1 : S_br8_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_br8_ p0, struct S_br8_ p1, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Explicit(System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1_S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_bu1_ p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Equality(System.Data.SqlTypes.SqlByte, System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlByte
bool w_S_u1_S_bu1_S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_bu1_S_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};
    // JSValToCSVal struct
    S_bu1_* pp1 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv1);
    S_bu1_ p1 = pp1 ? *pp1 : S_bu1_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_bu1_ p0, struct S_bu1_ p1, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Equality(System.Data.SqlTypes.SqlBinary, System.Data.SqlTypes.SqlBinary) declare in System.Data.SqlTypes.SqlBinary
bool w_S_u1_S_o_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_o_S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_o_ p0, struct S_o_ p1, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Explicit(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1_S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_soi4i4b_ p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Equality(System.Data.SqlTypes.SqlString, System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlString
bool w_S_u1_S_soi4i4b_S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_soi4i4b_S_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};
    // JSValToCSVal struct
    S_soi4i4b_* pp1 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv1);
    S_soi4i4b_ p1 = pp1 ? *pp1 : S_soi4i4b_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_soi4i4b_ p0, struct S_soi4i4b_ p1, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_LogicalNot(System.Data.SqlTypes.SqlBoolean) declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1_S_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_u1_ p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_BitwiseAnd(System.Data.SqlTypes.SqlBoolean, System.Data.SqlTypes.SqlBoolean) declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1_S_u1_S_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_u1_S_u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};
    // JSValToCSVal struct
    S_u1_* pp1 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv1);
    S_u1_ p1 = pp1 ? *pp1 : S_u1_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_u1_ p0, struct S_u1_ p1, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Explicit(System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1_S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Equality(System.Data.SqlTypes.SqlDecimal, System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv1);
    S_u1u1u1u1u4u4u4u4_ p1 = pp1 ? *pp1 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_u1_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, struct S_u1u1u1u1u4u4u4u4_ p1, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean op_Implicit(Boolean) declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_u1_ (*FuncToCall)(bool p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean Parse(System.String) declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_u1_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AI.NavMeshBuildDebugSettings get_debug() declare in UnityEngine.AI.NavMeshBuildSettings
bool w_S_u1_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u1_ (*FuncToCall)(void*,const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean Adjust(System.Data.SqlTypes.SqlBoolean) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_u1_tS_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_tS_u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef struct S_u1_ (*FuncToCall)(void*,struct S_u1_ p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlBoolean GetSqlBoolean(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_u1_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u1_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// CheckAuthenticationParametersResult CheckAuthenticationParameters(System.String, System.String, System.String, System.String) declare in Codice.Client.Common.ClientConfigurationArguments
bool w_S_u1bs_ssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1bs_ssss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef struct S_u1bs_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    struct S_u1bs_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// CheckAuthenticationParametersResult CheckUserAndCredentialsParameters(Codice.CM.Common.SEIDWorkingMode, System.String, System.String, System.String) declare in Codice.Client.Common.ClientConfigurationArguments
bool w_S_u1bs_u1sss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1bs_u1sss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef struct S_u1bs_ (*FuncToCall)(uint8_t p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    struct S_u1bs_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.DepthState get_defaultValue() declare in UnityEngine.Rendering.DepthState
bool w_S_u1i1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1i1_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u1i1_ (*FuncToCall)(const void* method);
    struct S_u1i1_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.DepthState get_depthState() declare in UnityEngine.Rendering.RenderStateBlock
bool w_S_u1i1_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1i1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u1i1_ (*FuncToCall)(void*,const void* method);
    struct S_u1i1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.SearchValue ConvertPropertyValue(UnityEditor.SerializedProperty ByRef) declare in UnityEditor.Search.SearchValue
bool w_S_u1r8r4sS_r4r4r4r4_S_u1u1u1u1__Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1r8r4sS_r4r4r4r4_S_u1u1u1u1__Po");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        

    typedef struct S_u1r8r4sS_r4r4r4r4_S_u1u1u1u1__ (*FuncToCall)(Il2CppObject** p0, const void* method);
    struct S_u1r8r4sS_r4r4r4r4_S_u1u1u1u1__ ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Buffers.StandardFormat Parse(System.ReadOnlySpan`1[System.Char]) declare in System.Buffers.StandardFormat
bool w_S_u1u1_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef struct S_u1u1_ (*FuncToCall)(struct S_S_p_i4_ p0, const void* method);
    struct S_u1u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Buffers.StandardFormat op_Implicit(Char) declare in System.Buffers.StandardFormat
bool w_S_u1u1_c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1_c");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef struct S_u1u1_ (*FuncToCall)(Il2CppChar p0, const void* method);
    struct S_u1u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Buffers.StandardFormat Parse(System.String) declare in System.Buffers.StandardFormat
bool w_S_u1u1_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_u1u1_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_u1u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RenderTargetBlendState get_defaultValue() declare in UnityEngine.Rendering.RenderTargetBlendState
bool w_S_u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u1u1u1u1u1u1u1u1_ (*FuncToCall)(const void* method);
    struct S_u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RenderTargetBlendState get_blendState0() declare in UnityEngine.Rendering.BlendState
bool w_S_u1u1u1u1u1u1u1u1_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct S_u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.StencilState get_defaultValue() declare in UnityEngine.Rendering.StencilState
bool w_S_u1u1u1u1u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ (*FuncToCall)(const void* method);
    struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.StencilState get_stencilState() declare in UnityEngine.Rendering.RenderStateBlock
bool w_S_u1u1u1u1u1u1u1u1u1u1u1u1_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u1u1u1u1u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_Implicit(System.Data.SqlTypes.SqlInt16) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_bi2_ p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_Implicit(System.Data.SqlTypes.SqlInt32) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_bi4_ p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_Implicit(System.Data.SqlTypes.SqlInt64) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_bi8_ p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_Explicit(System.Data.SqlTypes.SqlSingle) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_br4_ p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_Explicit(System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_br8_ p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_Implicit(System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_bu1_ p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_Implicit(System.Decimal) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_Explicit(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_soi4i4b_ p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_Explicit(System.Data.SqlTypes.SqlBoolean) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_u1_ p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_UnaryNegation(System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_Addition(System.Data.SqlTypes.SqlDecimal, System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv1);
    S_u1u1u1u1u4u4u4u4_ p1 = pp1 ? *pp1 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, struct S_u1u1u1u1u4u4u4u4_ p1, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal Round(System.Data.SqlTypes.SqlDecimal, Int32) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, int32_t p1, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal AdjustScale(System.Data.SqlTypes.SqlDecimal, Int32, Boolean) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_i4b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, int32_t p1, bool p2, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal ConvertToPrecScale(System.Data.SqlTypes.SqlDecimal, Int32, Int32) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, int32_t p1, int32_t p2, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal Power(System.Data.SqlTypes.SqlDecimal, Double) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_S_u1u1u1u1u4u4u4u4_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, double p1, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_Implicit(Int64) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(int64_t p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal op_Explicit(Double) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(double p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal Parse(System.String) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_u1u1u1u1u4u4u4u4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal ToSqlDecimal() declare in System.Data.SqlTypes.SqlBoolean
bool w_S_u1u1u1u1u4u4u4u4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(void*,const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal Adjust(System.Data.SqlTypes.SqlDecimal) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_u1u1u1u1u4u4u4u4_tS_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_tS_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(void*,struct S_u1u1u1u1u4u4u4u4_ p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDecimal GetSqlDecimal(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_u1u1u1u1u4u4u4u4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u4u4u4u4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u1u1u1u1u4u4u4u4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_u1u1u1u1u4u4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Profiling.ProfilerCategoryInfo GetCategoryInfo(UInt16) declare in UnityEditor.Profiling.FrameDataView
bool w_S_u2S_i4u1u1u1u1_su2_tu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2S_i4u1u1u1u1_su2_tu2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef struct S_u2S_i4u1u1u1u1_su2_ (*FuncToCall)(void*,uint16_t p0, const void* method);
    struct S_u2S_i4u1u1u1u1_su2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Profiling.ProfilerCategory get_Render() declare in Unity.Profiling.ProfilerCategory
bool w_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u2_ (*FuncToCall)(const void* method);
    struct S_u2_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BitArray16 op_OnesComplement(UnityEngine.Rendering.BitArray16) declare in UnityEngine.Rendering.BitArray16
bool w_S_u2_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef struct S_u2_ (*FuncToCall)(struct S_u2_ p0, const void* method);
    struct S_u2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BitArray16 op_BitwiseOr(UnityEngine.Rendering.BitArray16, UnityEngine.Rendering.BitArray16) declare in UnityEngine.Rendering.BitArray16
bool w_S_u2_S_u2_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2_S_u2_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};

    typedef struct S_u2_ (*FuncToCall)(struct S_u2_ p0, struct S_u2_ p1, const void* method);
    struct S_u2_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half half(Single) declare in Unity.Mathematics.math
bool w_S_u2_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_u2_ (*FuncToCall)(float p0, const void* method);
    struct S_u2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half half(Double) declare in Unity.Mathematics.math
bool w_S_u2_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_u2_ (*FuncToCall)(double p0, const void* method);
    struct S_u2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Profiling.ProfilerCategory get_Category() declare in Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderDescription
bool w_S_u2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u2_ (*FuncToCall)(void*,const void* method);
    struct S_u2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half get_Item(Int32) declare in Unity.Mathematics.half2
bool w_S_u2_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u2_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_u2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Profiling.LowLevel.Unsafe.ProfilerCategoryDescription GetCategoryDescription(UInt16) declare in Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility
bool w_S_u2u2S_i4u1u1u1u1_i4i4Pv_u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2u2S_i4u1u1u1u1_i4i4Pv_u2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef struct S_u2u2S_i4u1u1u1u1_i4i4Pv_ (*FuncToCall)(uint16_t p0, const void* method);
    struct S_u2u2S_i4u1u1u1u1_i4i4Pv_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.TextCore.LowLevel.GlyphAdjustmentRecord get_firstAdjustmentRecord() declare in UnityEngine.TextCore.LowLevel.GlyphPairAdjustmentRecord
bool w_S_u4S_r4r4r4r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4S_r4r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u4S_r4r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_u4S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BitArray32 op_OnesComplement(UnityEngine.Rendering.BitArray32) declare in UnityEngine.Rendering.BitArray32
bool w_S_u4_S_u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_S_u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4_* pp0 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv0);
    S_u4_ p0 = pp0 ? *pp0 : S_u4_ {};

    typedef struct S_u4_ (*FuncToCall)(struct S_u4_ p0, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BitArray32 op_BitwiseOr(UnityEngine.Rendering.BitArray32, UnityEngine.Rendering.BitArray32) declare in UnityEngine.Rendering.BitArray32
bool w_S_u4_S_u4_S_u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_S_u4_S_u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4_* pp0 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv0);
    S_u4_ p0 = pp0 ? *pp0 : S_u4_ {};
    // JSValToCSVal struct
    S_u4_* pp1 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv1);
    S_u4_ p1 = pp1 ? *pp1 : S_u4_ {};

    typedef struct S_u4_ (*FuncToCall)(struct S_u4_ p0, struct S_u4_ p1, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Mono.Unix.Native.InAddr ToInAddr(System.Net.IPAddress) declare in Mono.Unix.Native.NativeConvert
bool w_S_u4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_u4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.GraphicsBufferHandle get_bufferHandle() declare in UnityEngine.GraphicsBuffer
bool w_S_u4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u4_ (*FuncToCall)(void*,const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BatchID AddBatch(Unity.Collections.NativeArray`1[UnityEngine.Rendering.MetadataValue], UnityEngine.GraphicsBufferHandle) declare in UnityEngine.Rendering.ThreadedBatchContext
bool w_S_u4_tS_Pvi4i4i4S_pi4i4_i4_S_u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_tS_Pvi4i4i4S_pi4i4_i4_S_u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_u4_* pp1 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv1);
    S_u4_ p1 = pp1 ? *pp1 : S_u4_ {};

    typedef struct S_u4_ (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_u4_ p1, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BatchID AddBatch(Unity.Collections.NativeArray`1[UnityEngine.Rendering.MetadataValue], UnityEngine.GraphicsBufferHandle, UInt32, UInt32) declare in UnityEngine.Rendering.ThreadedBatchContext
bool w_S_u4_tS_Pvi4i4i4S_pi4i4_i4_S_u4_u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_tS_Pvi4i4i4S_pi4i4_i4_S_u4_u4u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_u4_* pp1 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv1);
    S_u4_ p1 = pp1 ? *pp1 : S_u4_ {};
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);

    typedef struct S_u4_ (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_u4_ p1, uint32_t p2, uint32_t p3, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BatchMaterialID RegisterMaterial(Int32) declare in UnityEngine.Rendering.BatchRendererGroup
bool w_S_u4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BatchMaterialID RegisterMaterial(UnityEngine.Material) declare in UnityEngine.Rendering.BatchRendererGroup
bool w_S_u4_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_u4_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.GraphicsBufferHandle GetBuffer(System.String) declare in UnityEngine.Material
bool w_S_u4_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_u4_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.Random CreateFromIndex(UInt32) declare in Unity.Mathematics.Random
bool w_S_u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.TransformSceneHandle BindSceneTransform(UnityEngine.Animator, UnityEngine.Transform) declare in UnityEngine.Animations.AnimatorJobExtensions
bool w_S_u4i4_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_u4i4_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_u4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.PropertySceneHandle BindSceneProperty(UnityEngine.Animator, UnityEngine.Transform, System.Type, System.String) declare in UnityEngine.Animations.AnimatorJobExtensions
bool w_S_u4i4_toos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4_toos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef struct S_u4i4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    struct S_u4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.PropertySceneHandle BindSceneProperty(UnityEngine.Animator, UnityEngine.Transform, System.Type, System.String, Boolean) declare in UnityEngine.Animations.AnimatorJobExtensions
bool w_S_u4i4_toosb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4_toosb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef struct S_u4i4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, bool p3, const void* method);
    struct S_u4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.TransformStreamHandle BindStreamTransform(UnityEngine.Animator, UnityEngine.Transform) declare in UnityEngine.Animations.AnimatorJobExtensions
bool w_S_u4i4i4_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4i4_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_u4i4i4_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_u4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.PropertyStreamHandle BindStreamProperty(UnityEngine.Animator, UnityEngine.Transform, System.Type, System.String) declare in UnityEngine.Animations.AnimatorJobExtensions
bool w_S_u4i4i4i4_toos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4i4i4_toos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef struct S_u4i4i4i4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    struct S_u4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.PropertyStreamHandle BindStreamProperty(UnityEngine.Animator, UnityEngine.Transform, System.Type, System.String, Boolean) declare in UnityEngine.Animations.AnimatorJobExtensions
bool w_S_u4i4i4i4_toosb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4i4i4_toosb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef struct S_u4i4i4i4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, bool p3, const void* method);
    struct S_u4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.PropertyStreamHandle BindCustomStreamProperty(UnityEngine.Animator, System.String, UnityEngine.Animations.CustomStreamPropertyType) declare in UnityEngine.Animations.AnimatorJobExtensions
bool w_S_u4i4i4i4_tsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4i4i4_tsi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u4i4i4i4_ (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, const void* method);
    struct S_u4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.AnimationStream GetInputStream(Int32) declare in UnityEngine.Animations.AnimationStream
bool w_S_u4pppppp_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4pppppp_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4pppppp_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_u4pppppp_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.bool2x4) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_bb_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_bb_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb_S_bb__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_bb_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.bool2x3) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.bool2x2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_bb_S_bb__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.int2x4) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.int2x3) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.int2x2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.float2x4) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.float2x3) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.float2x2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.double2x4) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.double2x3) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.double2x2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.half2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_u2_S_u2__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.uint2x4) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 mul(Unity.Mathematics.uint2x4, Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, struct S_u4u4u4u4_ p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.uint2x3) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 mul(Unity.Mathematics.uint2x3, Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_u4u4_S_u4u4_S_u4u4__S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_u4u4_S_u4u4_S_u4u4__S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, struct S_u4u4u4_ p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.uint2x2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 mul(Unity.Mathematics.uint2x2, Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_S_u4u4_S_u4u4__S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_S_u4u4_S_u4u4__S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, struct S_u4u4_ p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_bb_ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_i4i4_ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 hashwide(Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_r8r8_ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 reversebits(Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4_ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 mul(Unity.Mathematics.uint2, Unity.Mathematics.uint2x2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_u4u4_S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4_S_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4_ p0, struct S_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 min(Unity.Mathematics.uint2, Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 select(Unity.Mathematics.uint2, Unity.Mathematics.uint2, Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_u4u4_S_u4u4_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4_S_u4u4_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal struct
    S_bb_* pp2 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv2);
    S_bb_ p2 = pp2 ? *pp2 : S_bb_ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, struct S_bb_ p2, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 mad(Unity.Mathematics.uint2, Unity.Mathematics.uint2, Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_u4u4_S_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4_S_u4u4_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv2);
    S_u4u4_ p2 = pp2 ? *pp2 : S_u4u4_ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, struct S_u4u4_ p2, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 select(Unity.Mathematics.uint2, Unity.Mathematics.uint2, Boolean) declare in Unity.Mathematics.math
bool w_S_u4u4_S_u4u4_S_u4u4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4_S_u4u4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, bool p2, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 shuffle(Unity.Mathematics.uint2, Unity.Mathematics.uint2, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_u4u4_S_u4u4_S_u4u4_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4_S_u4u4_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 rol(Unity.Mathematics.uint2, Int32) declare in Unity.Mathematics.math
bool w_S_u4u4_S_u4u4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4_ p0, int32_t p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 op_Multiply(Unity.Mathematics.uint2, UInt32) declare in Unity.Mathematics.uint2
bool w_S_u4u4_S_u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4_ p0, uint32_t p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 mul(Unity.Mathematics.uint3, Unity.Mathematics.uint3x2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_u4u4u4_S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4u4_S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 shuffle(Unity.Mathematics.uint3, Unity.Mathematics.uint3, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_u4u4_S_u4u4u4_S_u4u4u4_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4u4_S_u4u4u4_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 mul(Unity.Mathematics.uint4, Unity.Mathematics.uint4x2) declare in Unity.Mathematics.math
bool w_S_u4u4_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 shuffle(Unity.Mathematics.uint4, Unity.Mathematics.uint4, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_u4u4_S_u4u4u4u4_S_u4u4u4u4_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_S_u4u4u4u4_S_u4u4u4u4_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 uint2(Boolean) declare in Unity.Mathematics.math
bool w_S_u4u4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4_ (*FuncToCall)(bool p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 uint2(Int32) declare in Unity.Mathematics.math
bool w_S_u4u4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Codice.CM.Common.RepId DeserializeRepId(Codice.CM.Common.Serialization.PlasticBinaryReader) declare in Codice.CM.Common.Serialization.SerializedObjectManager
bool w_S_u4u4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_u4u4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 uint2(Single) declare in Unity.Mathematics.math
bool w_S_u4u4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4_ (*FuncToCall)(float p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 uint2(Double) declare in Unity.Mathematics.math
bool w_S_u4u4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4_ (*FuncToCall)(double p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Codice.CM.Common.RepId FromString(System.String) declare in Codice.Client.Common.RepIdParser
bool w_S_u4u4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RefreshRate get_refreshRateRatio() declare in UnityEngine.Resolution
bool w_S_u4u4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u4u4_ (*FuncToCall)(void*,const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 NextUInt2(Unity.Mathematics.uint2) declare in Unity.Mathematics.Random
bool w_S_u4u4_tS_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_tS_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};

    typedef struct S_u4u4_ (*FuncToCall)(void*,struct S_u4u4_ p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 NextUInt2(Unity.Mathematics.uint2, Unity.Mathematics.uint2) declare in Unity.Mathematics.Random
bool w_S_u4u4_tS_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_tS_u4u4_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef struct S_u4u4_ (*FuncToCall)(void*,struct S_u4u4_ p0, struct S_u4u4_ p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.BlendShapeBufferRange GetBlendShapeBufferRange(Int32) declare in UnityEngine.Mesh
bool w_S_u4u4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 uint2(UInt32) declare in Unity.Mathematics.math
bool w_S_u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 op_Multiply(UInt32, Unity.Mathematics.uint2) declare in Unity.Mathematics.uint2
bool w_S_u4u4_u4S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_u4S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef struct S_u4u4_ (*FuncToCall)(uint32_t p0, struct S_u4u4_ p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2 uint2(UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_u4u4_u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_u4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u4u4_ (*FuncToCall)(uint32_t p0, uint32_t p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.VFX.VFXParticleSystemInfo GetParticleSystemInfo(Int32) declare in UnityEngine.VFX.VisualEffect
bool w_S_u4u4bS_S_r4r4r4_S_r4r4r4___ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4bS_S_r4r4r4_S_r4r4r4___ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4bS_S_r4r4r4_S_r4r4r4___ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_u4u4bS_S_r4r4r4_S_r4r4r4___ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.VFX.VFXParticleSystemInfo GetParticleSystemInfo(System.String) declare in UnityEngine.VFX.VisualEffect
bool w_S_u4u4bS_S_r4r4r4_S_r4r4r4___ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4bS_S_r4r4r4_S_r4r4r4___ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4bS_S_r4r4r4_S_r4r4r4___ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_u4u4bS_S_r4r4r4_S_r4r4r4___ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.bool3x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_bbb_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_bbb_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.bool3x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.bool3x2) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_bbb_S_bbb__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.int3x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.int3x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.int3x2) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.float3x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.float3x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.float3x2) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.double3x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.double3x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.double3x2) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.half3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_u2_S_u2_S_u2__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.uint3x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 mul(Unity.Mathematics.uint3x4, Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, struct S_u4u4u4u4_ p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.uint3x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 mul(Unity.Mathematics.uint3x3, Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, struct S_u4u4u4_ p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.uint3x2) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 mul(Unity.Mathematics.uint3x2, Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_S_u4u4u4_S_u4u4u4__S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_S_u4u4u4_S_u4u4u4__S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, struct S_u4u4_ p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_bbb_ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_i4i4i4_ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 hashwide(Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_r8r8r8_ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 mul(Unity.Mathematics.uint2, Unity.Mathematics.uint2x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4_S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4_S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4_ p0, struct S_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 shuffle(Unity.Mathematics.uint2, Unity.Mathematics.uint2, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4_S_u4u4_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4_S_u4u4_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 uint3(Unity.Mathematics.uint2, UInt32) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4_ p0, uint32_t p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 reversebits(Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 mul(Unity.Mathematics.uint3, Unity.Mathematics.uint3x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4u4_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4u4_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 min(Unity.Mathematics.uint3, Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4u4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4u4_S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 select(Unity.Mathematics.uint3, Unity.Mathematics.uint3, Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_bbb_* pp2 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv2);
    S_bbb_ p2 = pp2 ? *pp2 : S_bbb_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, struct S_bbb_ p2, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

}

