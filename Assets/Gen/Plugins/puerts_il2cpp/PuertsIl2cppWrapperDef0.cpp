// Auto Gen

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "PuertsValueType.h"
#if defined(__EMSCRIPTEN__)
#include "pesapi_webgl.h"
using namespace pesapi::webglimpl;
#endif

namespace puerts
{


// System.Nullable`1[System.DateTimeOffset] op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_N_bS_S_u8_i2__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_S_u8_i2__o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bS_S_u8_i2__ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bS_S_u8_i2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.DateTimeOffset] get_CreationDate() declare in System.Net.Http.Headers.ContentDispositionHeaderValue
bool w_N_bS_S_u8_i2__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_S_u8_i2__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bS_S_u8_i2__ (*FuncToCall)(void*,const void* method);
    struct N_bS_S_u8_i2__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions] get_Options() declare in System.Text.Json.Nodes.JsonNode
bool w_N_bS_b__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_b__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bS_b__ (*FuncToCall)(void*,const void* method);
    struct N_bS_b__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Guid] op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_N_bS_i4i2i2u1u1u1u1u1u1u1u1__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i4i2i2u1u1u1u1u1u1u1u1__o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bS_i4i2i2u1u1u1u1u1u1u1u1__ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bS_i4i2i2u1u1u1u1u1u1u1u1__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Guid] get_ProviderControlGuid() declare in System.Diagnostics.Eventing.Reader.EventLogConfiguration
bool w_N_bS_i4i2i2u1u1u1u1u1u1u1u1__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i4i2i2u1u1u1u1u1u1u1u1__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bS_i4i2i2u1u1u1u1u1u1u1u1__ (*FuncToCall)(void*,const void* method);
    struct N_bS_i4i2i2u1u1u1u1u1u1u1u1__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.ValueTuple`2[System.Int32,System.Int32]] get_Progress() declare in Bee.BeeDriver.ActiveBuildStatus
bool w_N_bS_i4i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i4i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bS_i4i4__ (*FuncToCall)(void*,const void* method);
    struct N_bS_i4i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Decimal] op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_N_bS_i4i4i4i4u8__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i4i4i4i4u8__o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bS_i4i4i4i4u8__ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bS_i4i4i4i4u8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Decimal] Sum(System.Linq.ParallelQuery`1[System.Nullable`1[System.Decimal]]) declare in System.Linq.ParallelEnumerable
bool w_N_bS_i4i4i4i4u8__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i4i4i4i4u8__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bS_i4i4i4i4u8__ (*FuncToCall)(void*,const void* method);
    struct N_bS_i4i4i4i4u8__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.TimeSpan] op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_N_bS_i8__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i8__o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bS_i8__ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bS_i8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.TimeSpan] get_MaxAge() declare in System.Net.Http.Headers.CacheControlHeaderValue
bool w_N_bS_i8__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i8__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bS_i8__ (*FuncToCall)(void*,const void* method);
    struct N_bS_i8__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[Bee.BinLog.NodeInfo] get_EnqueueingNode() declare in Bee.BinLog.NodeEnqueuedMessage
bool w_N_bS_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4____t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4____t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bS_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4____ (*FuncToCall)(void*,const void* method);
    struct N_bS_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4____ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Text.Json.JsonElement] get_Schema() declare in Microsoft.Extensions.AI.ChatResponseFormatJson
bool w_N_bS_oi4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_oi4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bS_oi4__ (*FuncToCall)(void*,const void* method);
    struct N_bS_oi4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Text.Json.JsonElement] GetOrCreateTransformedSchema(Microsoft.Extensions.AI.ChatResponseFormatJson) declare in Microsoft.Extensions.AI.AIJsonSchemaTransformCache
bool w_N_bS_oi4__to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_oi4__to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bS_oi4__ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct N_bS_oi4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[UnityEngine.Vector2] get_autoFocusPoint() declare in UnityEngine.WebCamTexture
bool w_N_bS_r4r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_r4r4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bS_r4r4__ (*FuncToCall)(void*,const void* method);
    struct N_bS_r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[Betalgo.Ranul.OpenAI.Contracts.Enums.Image.ImageBackground] get_Background() declare in Betalgo.Ranul.OpenAI.Contracts.Responses.Image.ImageResponse
bool w_N_bS_s__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_s__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bS_s__ (*FuncToCall)(void*,const void* method);
    struct N_bS_s__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.DateTime] op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_N_bS_u8__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_u8__o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bS_u8__ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bS_u8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.DateTime] get_datePublished() declare in UnityEditor.PackageManager.PackageInfo
bool w_N_bS_u8__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_u8__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bS_u8__ (*FuncToCall)(void*,const void* method);
    struct N_bS_u8__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Boolean] op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_N_bb_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bb_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bb_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Boolean] get_IsLogFull() declare in System.Diagnostics.Eventing.Reader.EventLogInformation
bool w_N_bb_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bb_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bb_ (*FuncToCall)(void*,const void* method);
    struct N_bb_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Boolean] IsCompatibilitySwitchSet(System.String) declare in System.AppDomain
bool w_N_bb_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bb_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct N_bb_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct N_bb_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Char] op_Explicit(System.Text.Json.Nodes.JsonNode) declare in System.Text.Json.Nodes.JsonNode
bool w_N_bc_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bc_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bc_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bc_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.SByte] op_Explicit(System.Text.Json.Nodes.JsonNode) declare in System.Text.Json.Nodes.JsonNode
bool w_N_bi1_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi1_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bi1_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bi1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Int16] op_Explicit(System.Text.Json.Nodes.JsonNode) declare in System.Text.Json.Nodes.JsonNode
bool w_N_bi2_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi2_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bi2_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Int16] get_Opcode() declare in System.Diagnostics.Eventing.Reader.EventLogRecord
bool w_N_bi2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bi2_ (*FuncToCall)(void*,const void* method);
    struct N_bi2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Int32] get_CurrentId() declare in System.Threading.Tasks.Task
bool w_N_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bi4_ (*FuncToCall)(const void* method);
    struct N_bi4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Int32] op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_N_bi4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bi4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Int32] get_InvalidCultureId() declare in System.Globalization.CultureNotFoundException
bool w_N_bi4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bi4_ (*FuncToCall)(void*,const void* method);
    struct N_bi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Int32] Read(System.Text.Json.Utf8JsonReader ByRef, System.Type, System.Text.Json.JsonSerializerOptions) declare in Betalgo.Ranul.OpenAI.ObjectModels.ResponseModels.FineTuningJobResponseModels.NEpochsConverter
bool w_N_bi4_tPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi4_tPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0 = DataTransfer::GetPointer<S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct N_bi4_ (*FuncToCall)(void*,struct S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct N_bi4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Int64] op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_N_bi8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi8_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bi8_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Int64] GetSecurityTimestamp(Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.Mount.MountPointId) declare in Codice.CM.WorkspaceServer.DataStore.Trees.LocalTreesStorage
bool w_N_bi8_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi8_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct N_bi8_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct N_bi8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Int64] get_LowestBreakIteration() declare in System.Threading.Tasks.ParallelLoopState
bool w_N_bi8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bi8_ (*FuncToCall)(void*,const void* method);
    struct N_bi8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Single] op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_N_br4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_br4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_br4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_br4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Single] Sum(System.Linq.ParallelQuery`1[System.Nullable`1[System.Single]]) declare in System.Linq.ParallelEnumerable
bool w_N_br4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_br4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_br4_ (*FuncToCall)(void*,const void* method);
    struct N_br4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Double] op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_N_br8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_br8_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_br8_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_br8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Double] Sum(System.Linq.ParallelQuery`1[System.Nullable`1[System.Double]]) declare in System.Linq.ParallelEnumerable
bool w_N_br8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_br8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_br8_ (*FuncToCall)(void*,const void* method);
    struct N_br8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Byte] op_Explicit(System.Text.Json.Nodes.JsonNode) declare in System.Text.Json.Nodes.JsonNode
bool w_N_bu1_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bu1_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bu1_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bu1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.Byte] get_Level() declare in System.Diagnostics.Eventing.Reader.EventLogRecord
bool w_N_bu1_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bu1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bu1_ (*FuncToCall)(void*,const void* method);
    struct N_bu1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.UInt16] op_Explicit(System.Text.Json.Nodes.JsonNode) declare in System.Text.Json.Nodes.JsonNode
bool w_N_bu2_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bu2_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bu2_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bu2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.UInt32] op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_N_bu4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bu4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bu4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bu4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.UInt32] get_Timestamp() declare in Mono.Cecil.ModuleParameters
bool w_N_bu4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bu4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct N_bu4_ (*FuncToCall)(void*,const void* method);
    struct N_bu4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Nullable`1[System.UInt64] op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_N_bu8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_N_bu8_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct N_bu8_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct N_bu8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyNullableValueType(apis, env, ret, TIret));
    return true;
}

// System.Object get_HostContext() declare in System.Runtime.Remoting.Messaging.CallContext
bool w_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_O");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef Il2CppObject* (*FuncToCall)(const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetObjectValue(System.Object) declare in System.Runtime.CompilerServices.RuntimeHelpers
bool w_OO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetComObjectData(System.Object, System.Object) declare in System.Runtime.InteropServices.Marshal
bool w_OOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ChangeType(System.Object, System.TypeCode) declare in System.Convert
bool w_OOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OOi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ChangeType(System.Object, System.TypeCode, System.IFormatProvider) declare in System.Convert
bool w_OOi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OOi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ChangeType(System.Object, System.Type) declare in System.Convert
bool w_OOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetEditor(System.Object, System.Type, Boolean) declare in System.ComponentModel.TypeDescriptor
bool w_OOob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OOob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ChangeType(System.Object, System.Type, System.IFormatProvider) declare in System.Convert
bool w_OOoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OOoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object VolatileRead(System.Object ByRef) declare in System.Threading.Thread
bool w_OPO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OPO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject** p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Exchange(System.Object ByRef, System.Object) declare in System.Threading.Interlocked
bool w_OPOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OPOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject** p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CompareExchange(System.Object ByRef, System.Object, System.Object) declare in System.Threading.Interlocked
bool w_OPOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OPOOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject** p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.Text.Json.Utf8JsonReader ByRef, System.Text.Json.Serialization.Metadata.JsonTypeInfo) declare in System.Text.Json.JsonSerializer
bool w_OPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0 = DataTransfer::GetPointer<S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.Text.Json.Utf8JsonReader ByRef, System.Type, System.Text.Json.JsonSerializerOptions) declare in System.Text.Json.JsonSerializer
bool w_OPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__oDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__oDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0 = DataTransfer::GetPointer<S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.Text.Json.Utf8JsonReader ByRef, System.Type, System.Text.Json.Serialization.JsonSerializerContext) declare in System.Text.Json.JsonSerializer
bool w_OPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0 = DataTransfer::GetPointer<S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetNativeOverlappedState(System.Threading.NativeOverlapped*) declare in System.Threading.ThreadPoolBoundHandle
bool w_OPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OPv");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Box(Void*, System.Type) declare in System.Reflection.Pointer
bool w_OPvo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OPvo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.ReadOnlySpan`1[System.Byte], System.Text.Json.Serialization.Metadata.JsonTypeInfo) declare in System.Text.Json.JsonSerializer
bool w_OS_S_p_i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OS_S_p_i4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.ReadOnlySpan`1[System.Byte], System.Type, System.Text.Json.JsonSerializerOptions) declare in System.Text.Json.JsonSerializer
bool w_OS_S_p_i4_oDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OS_S_p_i4_oDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.ReadOnlySpan`1[System.Byte], System.Type, System.Text.Json.Serialization.JsonSerializerContext) declare in System.Text.Json.JsonSerializer
bool w_OS_S_p_i4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OS_S_p_i4_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ToObject(TypedReference) declare in System.TypedReference
bool w_OS_S_p_pp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OS_S_p_pp_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_pp_* pp0 = DataTransfer::GetPointer<S_S_p_pp_>(apis, env, _sv0);
    S_S_p_pp_ p0 = pp0 ? *pp0 : S_S_p_pp_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_S_p_pp_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object RaySnap(UnityEngine.Ray) declare in UnityEditor.HandleUtility
bool w_OS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OS_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object IntersectRayTriangle(UnityEngine.Ray, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Boolean) declare in UnityEditor.MathUtils
bool w_OS_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4_S_r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OS_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4_S_r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetRuntimeInterfaceAsObject(System.Guid, System.Guid) declare in System.Runtime.InteropServices.RuntimeEnvironment
bool w_OS_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OS_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object WrapAsObject(JetBrains.Lifetimes.Lifetime) declare in JetBrains.Lifetimes.Lifetime
bool w_OS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_o_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetSelf(Int32, IntPtr) declare in Puerts.Utils
bool w_Oi4p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oi4p");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, void* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CharTranslator(Int32, IntPtr, Puerts.IGetValueFromJs, IntPtr, Boolean) declare in Puerts.GeneralGetterManager
bool w_Oi4popb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oi4popb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, void* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstance(System.Type) declare in System.Activator
bool w_Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetObject(System.Type, System.String) declare in UnityEngine.RemoteSettings
bool w_OoDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OoDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ToObject(System.Type, System.Object) declare in System.Enum
bool w_OoO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OoO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object InvokeMethod(System.Reflection.MethodInfo, System.Object, System.Object[]) declare in NUnit.Framework.Internal.Reflect
bool w_OoOVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OoOVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ExpandoTrySetValue(System.Dynamic.ExpandoObject, System.Object, Int32, System.Object, System.String, Boolean) declare in System.Runtime.CompilerServices.RuntimeOps
bool w_OoOi4Osb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OoOi4Osb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, Il2CppObject* p3, Il2CppString* p4, bool p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstance(System.Type, System.Object[]) declare in System.Activator
bool w_OoVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OoVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstance(System.Type, Boolean) declare in System.Activator
bool w_Oob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ToObject(System.Type, SByte) declare in System.Enum
bool w_Ooi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int8_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ToObject(System.Type, Int16) declare in System.Enum
bool w_Ooi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi2");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int16_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ToObject(System.Type, Int32) declare in System.Enum
bool w_Ooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstance(System.Type, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) declare in System.Activator
bool w_Ooi4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi4ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstance(System.Type, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo, System.Object[]) declare in System.Activator
bool w_Ooi4oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi4oooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ToObject(System.Type, Int64) declare in System.Enum
bool w_Ooi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateWithContext(System.Type, System.ComponentModel.LicenseContext) declare in System.ComponentModel.LicenseManager
bool w_Ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.IO.Stream, System.Type, System.Text.Json.JsonSerializerOptions) declare in System.Text.Json.JsonSerializer
bool w_OooDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OooDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstance(System.IServiceProvider, System.Type, System.Object[]) declare in Microsoft.Extensions.DependencyInjection.ActivatorUtilities
bool w_OooVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OooVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstance(System.Type, System.Object[], System.Object[]) declare in System.Activator
bool w_Oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstance(System.IServiceProvider, System.Type, System.Type[], System.Object[]) declare in System.ComponentModel.TypeDescriptor
bool w_Ooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Ooooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetObject(System.Type, System.String) declare in System.Activator
bool w_Oos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetObject(System.Type, System.String, System.Object) declare in System.Activator
bool w_OosO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OosO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Parse(System.Type, System.String, Boolean) declare in System.Enum
bool w_Oosb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oosb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ToObject(System.Type, Byte) declare in System.Enum
bool w_Oou1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oou1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, uint8_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ToObject(System.Type, UInt16) declare in System.Enum
bool w_Oou2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oou2");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, uint16_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ToObject(System.Type, UInt32) declare in System.Enum
bool w_Oou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oou4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, uint32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ToObject(System.Type, UInt64) declare in System.Enum
bool w_Oou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oou8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, uint64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object WrapIUnknownWithComObject(IntPtr) declare in System.Runtime.Remoting.Services.EnterpriseServicesHelper
bool w_Op(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Op");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetTypedObjectForIUnknown(IntPtr, System.Type) declare in System.Runtime.InteropServices.Marshal
bool w_Opo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Opo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetData(System.String) declare in System.AppContext
bool w_Os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetObject(System.String, System.Object) declare in UnityEngine.RemoteSettings
bool w_OsO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OsO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateFromName(System.String, System.Object[]) declare in System.Security.Cryptography.CryptoConfig
bool w_OsVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OsVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Execute(System.String, UnityEditor.CommandHint) declare in UnityEditor.CommandService
bool w_Osi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Osi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, int64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Execute(System.String, UnityEditor.CommandHint, System.Object[]) declare in UnityEditor.CommandService
bool w_Osi8VO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Osi8VO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, int64_t p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object FromJson(System.String, System.Type) declare in UnityEngine.JsonUtility
bool w_Oso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.String, System.Type, System.Text.Json.JsonSerializerOptions) declare in System.Text.Json.JsonSerializer
bool w_OsoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OsoDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object InstantiateByClassName(System.String, System.Type, System.Object) declare in log4net.Util.OptionConverter
bool w_OsoO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OsoO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object DeserializeObject(System.String, System.Type, Unity.Plastic.Newtonsoft.Json.JsonConverter[]) declare in Unity.Plastic.Newtonsoft.Json.JsonConvert
bool w_OsoVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OsoVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.String, System.Type, System.Text.Json.Serialization.JsonSerializerContext) declare in System.Text.Json.JsonSerializer
bool w_Osoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Osoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(System.String, System.String, System.Object) declare in Microsoft.Win32.Registry
bool w_OssO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OssO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Eval(System.String, System.String, System.String, System.Type[], System.Object[]) declare in UnityEditor.Macros.MethodEvaluator
bool w_Osssoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Osssoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Clone() declare in System.String
bool w_Ot(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Ot");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef Il2CppObject* (*FuncToCall)(void*,const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(System.String, UnityEditor.Search.SearchContext) declare in UnityEditor.Search.SearchItem
bool w_OtDsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtDsDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal string  with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 0);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object get_Item(System.Object) declare in System.Runtime.Remoting.Channels.BaseChannelObjectWithProperties
bool w_OtO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object DupTree(System.Object, System.Object) declare in Unity.Plastic.Antlr3.Runtime.Tree.BaseTreeAdaptor
bool w_OtOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Create(System.Object, System.Object, System.Xml.XmlNode) declare in System.Configuration.DictionarySectionHandler
bool w_OtOOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtOOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Invoke(System.Object, System.Object[]) declare in NUnit.Framework.Internal.MethodWrapper
bool w_OtOVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtOVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Downup(System.Object, Boolean) declare in Unity.Plastic.Antlr3.Runtime.Tree.TreeRewriter
bool w_OtOb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtOb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Convert(System.Object, System.TypeCode) declare in System.Runtime.Serialization.FormatterConverter
bool w_OtOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtOi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) declare in System.Reflection.Emit.ConstructorBuilder
bool w_OtOi4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtOi4ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Convert(System.Object, System.Type) declare in System.Runtime.Serialization.FormatterConverter
bool w_OtOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ChangeType(System.Object, System.Type, System.Xml.IXmlNamespaceResolver) declare in System.Xml.Schema.XmlSchemaDatatype
bool w_OtOoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtOoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object DupNode(System.Object, System.String) declare in Unity.Plastic.Antlr3.Runtime.Tree.BaseTreeAdaptor
bool w_OtOs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtOs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetRealObject(System.Runtime.Serialization.StreamingContext) declare in System.Runtime.Remoting.ObjRef
bool w_OtS_Oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtS_Oi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4_* pp0 = DataTransfer::GetPointer<S_Oi4_>(apis, env, _sv0);
    S_Oi4_ p0 = pp0 ? *pp0 : S_Oi4_ {};

    typedef Il2CppObject* (*FuncToCall)(void*,struct S_Oi4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValueDirect(TypedReference) declare in System.Reflection.FieldInfo
bool w_OtS_S_p_pp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtS_S_p_pp_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_pp_* pp0 = DataTransfer::GetPointer<S_S_p_pp_>(apis, env, _sv0);
    S_S_p_pp_ p0 = pp0 ? *pp0 : S_S_p_pp_ {};

    typedef Il2CppObject* (*FuncToCall)(void*,struct S_S_p_pp_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Construct(Puerts.JSCallInfo) declare in Puerts.OverloadReflectionWrap
bool w_OtS_pppi4ooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtS_pppi4ooo_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pppi4ooo_* pp0 = DataTransfer::GetPointer<S_pppi4ooo_>(apis, env, _sv0);
    S_pppi4ooo_ p0 = pp0 ? *pp0 : S_pppi4ooo_ {};

    typedef Il2CppObject* (*FuncToCall)(void*,struct S_pppi4ooo_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object DynamicInvoke(System.Object[]) declare in System.Delegate
bool w_OtVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
    }
    
    // JSValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, js_args_len, 0);
                

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(Int32[]) declare in System.Array
bool w_OtVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtVi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive params
    Il2CppArray* p0 = Params<int32_t>::PackPrimitive(apis, env, info, TIp0, js_args_len, 0);
                

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(Int64[]) declare in System.Array
bool w_OtVi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtVi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive params
    Il2CppArray* p0 = Params<int64_t>::PackPrimitive(apis, env, info, TIp0, js_args_len, 0);
                

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetKnownPositionElement(Boolean) declare in Unity.Plastic.Antlr3.Runtime.Tree.CommonTreeNodeStream
bool w_Otb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,bool p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(Int32) declare in System.Array
bool w_Oti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ChangeTypeXsltResult(Int32, System.Object) declare in System.Xml.Xsl.Runtime.XmlQueryRuntime
bool w_Oti4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4O");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ChangeTypeXsltArgument(Int32, System.Object, System.Type) declare in System.Xml.Xsl.Runtime.XmlQueryRuntime
bool w_Oti4Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4Oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object DupNode(Int32, System.Object, System.String) declare in Unity.Plastic.Antlr3.Runtime.Tree.BaseTreeAdaptor
bool w_Oti4Os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4Os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(Int32, Int32) declare in System.Array
bool w_Oti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(Int32, Int32, Int32) declare in System.Array
bool w_Oti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Create(Int32, Unity.Plastic.Antlr3.Runtime.IToken) declare in Unity.Plastic.Antlr3.Runtime.Tree.BaseTreeAdaptor
bool w_Oti4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Invoke(System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) declare in System.Reflection.Emit.ConstructorBuilder
bool w_Oti4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Create(Int32, Unity.Plastic.Antlr3.Runtime.IToken, System.String) declare in Unity.Plastic.Antlr3.Runtime.Tree.BaseTreeAdaptor
bool w_Oti4os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetSelf(Int32, IntPtr) declare in Puerts.GeneralGetterManager
bool w_Oti4p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4p");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object JSObjectTranslator(Int32, IntPtr, Puerts.IGetValueFromJs, IntPtr, Boolean) declare in Puerts.GeneralGetterManager
bool w_Oti4popb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4popb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p0, void* p1, Il2CppObject* p2, void* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Create(Int32, System.String) declare in Unity.Plastic.Antlr3.Runtime.Tree.BaseTreeAdaptor
bool w_Oti4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(Int64) declare in System.Array
bool w_Oti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,int64_t p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(Int64, Int64) declare in System.Array
bool w_Oti8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti8i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int64_t p0, int64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(Int64, Int64, Int64) declare in System.Array
bool w_Oti8i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oti8i8i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object SetHostExecutionContext(System.Threading.HostExecutionContext) declare in System.Threading.HostExecutionContextManager
bool w_Oto(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Oto");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetRequiredService(Microsoft.Extensions.AI.IChatClient, System.Type, System.Object) declare in Microsoft.Extensions.AI.ChatClientExtensions
bool w_OtoDO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtoDO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.Text.Json.JsonDocument, System.Type, System.Text.Json.JsonSerializerOptions) declare in System.Text.Json.JsonSerializer
bool w_OtoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtoDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetObject(System.Type, System.String) declare in UnityEngine.RemoteConfigSettings
bool w_OtoDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtoDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ValidateEndElement(System.Xml.Schema.XmlSchemaInfo, System.Object) declare in System.Xml.Schema.XmlSchemaValidator
bool w_OtoO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtoO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.Xml.XmlReader, System.Xml.Serialization.XmlDeserializationEvents) declare in System.Xml.Serialization.XmlSerializer
bool w_OtoS_ooooO_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtoS_ooooO_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_ooooO_* pp1 = DataTransfer::GetPointer<S_ooooO_>(apis, env, _sv1);
    S_ooooO_ p1 = pp1 ? *pp1 : S_ooooO_ {};

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, struct S_ooooO_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ReadObject(System.Xml.XmlReader, Boolean) declare in System.Runtime.Serialization.DataContractSerializer
bool w_Otob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ReadObject(System.Xml.XmlDictionaryReader, Boolean, System.Runtime.Serialization.DataContractResolver) declare in System.Runtime.Serialization.DataContractSerializer
bool w_Otobo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otobo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, bool p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object get_Item(System.Data.DataColumn, System.Data.DataRowVersion) declare in System.Data.DataRow
bool w_Otoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otoi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Match(Unity.Plastic.Antlr3.Runtime.IIntStream, Int32, Unity.Plastic.Antlr3.Runtime.BitSet) declare in Unity.Plastic.Antlr3.Runtime.BaseRecognizer
bool w_Otoi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otoi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.IO.Stream, System.Runtime.Remoting.Messaging.HeaderHandler) declare in System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
bool w_Otoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ConvertFrom(System.ComponentModel.ITypeDescriptorContext, System.Globalization.CultureInfo, System.Object) declare in System.UriTypeConverter
bool w_OtooO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtooO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ConvertTo(System.ComponentModel.ITypeDescriptorContext, System.Globalization.CultureInfo, System.Object, System.Type) declare in System.UriTypeConverter
bool w_OtooOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtooOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object DeserializeMethodResponse(System.IO.Stream, System.Runtime.Remoting.Messaging.HeaderHandler, System.Runtime.Remoting.Messaging.IMethodCallMessage) declare in System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
bool w_Otooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstance(System.IServiceProvider, System.Type, System.Type[], System.Object[]) declare in System.ComponentModel.TypeDescriptionProvider
bool w_Otoooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otoooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ConvertFromString(System.ComponentModel.ITypeDescriptorContext, System.Globalization.CultureInfo, System.String) declare in System.ComponentModel.TypeConverter
bool w_Otoos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otoos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ReadElementContentAs(System.Type, System.Xml.IXmlNamespaceResolver, System.String, System.String) declare in System.Xml.XmlReader
bool w_Otooss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otooss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ConvertFromInvariantString(System.ComponentModel.ITypeDescriptorContext, System.String) declare in System.ComponentModel.TypeConverter
bool w_Otos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(Microsoft.Extensions.Configuration.IConfiguration, System.Type, System.String, System.Object) declare in Microsoft.Extensions.Configuration.ConfigurationBinder
bool w_OtosO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtosO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetItemIdWithMountPointIdFromPath(Codice.CM.Common.WorkspaceInfo, System.String, Codice.CM.Common.Mount.MountPointId ByRef) declare in Codice.CM.WorkspaceServer.WorkspaceTreeHandler
bool w_OtosPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtosPo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, Il2CppObject** p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Deserialize(System.Xml.XmlReader, System.String, System.Xml.Serialization.XmlDeserializationEvents) declare in System.Xml.Serialization.XmlSerializer
bool w_OtosS_ooooO_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtosS_ooooO_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_ooooO_* pp2 = DataTransfer::GetPointer<S_ooooO_>(apis, env, _sv2);
    S_ooooO_ p2 = pp2 ? *pp2 : S_ooooO_ {};

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, struct S_ooooO_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ConvertAssemblyToTypeLib(System.Reflection.Assembly, System.String, System.Runtime.InteropServices.TypeLibExporterFlags, System.Runtime.InteropServices.ITypeLibExporterNotifySink) declare in System.Runtime.InteropServices.TypeLibConverter
bool w_Otosi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otosi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetEntity(System.Uri, System.String, System.Type) declare in System.Xml.XmlSecureResolver
bool w_Otoso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otoso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object Construct(IntPtr, IntPtr, Int32) declare in Puerts.DelegateConstructWrap
bool w_Otppi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otppi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(System.String) declare in Microsoft.Win32.RegistryKey
bool w_Ots(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Ots");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(System.String, System.Object) declare in Microsoft.Win32.RegistryKey
bool w_OtsO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtsO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(System.String, System.Object, Microsoft.Win32.RegistryValueOptions) declare in Microsoft.Win32.RegistryKey
bool w_OtsOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_OtsOi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetObject(System.String, Boolean) declare in System.Resources.ResourceSet
bool w_Otsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otsb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstance(System.String, Boolean, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo, System.Object[]) declare in System.Reflection.Assembly
bool w_Otsbi4oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otsbi4oooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, bool p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object get_Item(System.String, System.Data.DataRowVersion) declare in System.Data.DataRow
bool w_Otsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otsi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[]) declare in System.Type
bool w_Otsi4oOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otsi4oOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Globalization.CultureInfo) declare in System.Type
bool w_Otsi4oOoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otsi4oOoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Reflection.ParameterModifier[], System.Globalization.CultureInfo, System.String[]) declare in System.Reflection.TypeDelegator
bool w_Otsi4oOoooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otsi4oOoooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object GetValue(System.String, System.Type) declare in System.Runtime.Serialization.SerializationInfo
bool w_Otso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstanceAndUnwrap(System.String, System.String) declare in System.AppDomain
bool w_Otss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstanceAndUnwrap(System.String, System.String, Boolean, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo, System.Object[]) declare in System.AppDomain
bool w_Otssbi4oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otssbi4oooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, bool p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstanceAndUnwrap(System.String, System.String, Boolean, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo, System.Object[], System.Security.Policy.Evidence) declare in System.AppDomain
bool w_Otssbi4ooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otssbi4ooooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal o/O
    Il2CppObject* p8 = JsValueToCSRef(apis, TIp8, env, _sv8);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, bool p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, Il2CppObject* p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object CreateInstanceAndUnwrap(System.String, System.String, System.Object[]) declare in System.AppDomain
bool w_Otsso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otsso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ValidateAttribute(System.String, System.String, System.Xml.Schema.XmlValueGetter, System.Xml.Schema.XmlSchemaInfo) declare in System.Xml.Schema.XmlSchemaValidator
bool w_Otssoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otssoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object ValidateAttribute(System.String, System.String, System.String, System.Xml.Schema.XmlSchemaInfo) declare in System.Xml.Schema.XmlSchemaValidator
bool w_Otssso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Otssso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.ContactPairPoint& GetContactPoint(Int32) declare in UnityEngine.ContactPair
bool w_PS_S_r4r4r4_r4S_r4r4r4_u4S_r4r4r4_u4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_S_r4r4r4_r4S_r4r4r4_u4S_r4r4r4_u4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_r4S_r4r4r4_u4S_r4r4r4_u4_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_S_r4r4r4_r4S_r4r4r4_u4S_r4r4r4_u4_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.bool2& get_Item(Int32) declare in Unity.Mathematics.bool2x2
bool w_PS_bb_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_bb_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_bb_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_bb_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.bool3& get_Item(Int32) declare in Unity.Mathematics.bool3x2
bool w_PS_bbb_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_bbb_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_bbb_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_bbb_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.bool4& get_Item(Int32) declare in Unity.Mathematics.bool4x2
bool w_PS_bbbb_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_bbbb_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_bbbb_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_bbbb_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.int2& get_Item(Int32) declare in Unity.Mathematics.int2x2
bool w_PS_i4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4i4_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.int3& get_Item(Int32) declare in Unity.Mathematics.int3x2
bool w_PS_i4i4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4i4i4_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.int4& get_Item(Int32) declare in Unity.Mathematics.int4x2
bool w_PS_i4i4i4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_i4i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4i4i4i4_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// UnityEngine.ContactPair& GetContactPair(Int32) declare in UnityEngine.ContactPairHeader
bool w_PS_i4i4pu4u2u2S_r4r4r4__ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_i4i4pu4u2u2S_r4r4r4__ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4pu4u2u2S_r4r4r4__* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4i4pu4u2u2S_r4r4r4__* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Settings& get_taaSettings() declare in UnityEngine.Rendering.Universal.UniversalAdditionalCameraData
bool w_PS_i4r4r4r4r4r4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_i4r4r4r4r4r4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4r4r4r4r4r4i4i4_* (*FuncToCall)(void*,const void* method);
    struct S_i4r4r4r4r4r4i4i4_* ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// UnityEngine.NVIDIA.DLSSCommandExecutionData& get_executeData() declare in UnityEngine.NVIDIA.DLSSContext
bool w_PS_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_* (*FuncToCall)(void*,const void* method);
    struct S_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_* ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.float2& get_Item(Int32) declare in Unity.Mathematics.float2x2
bool w_PS_r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r4r4_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.float3& get_Item(Int32) declare in Unity.Mathematics.float3x2
bool w_PS_r4r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r4r4r4_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.float4& get_Item(Int32) declare in Unity.Mathematics.float4x2
bool w_PS_r4r4r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_r4r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r4r4r4r4_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r4r4r4r4_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.double2& get_Item(Int32) declare in Unity.Mathematics.double2x2
bool w_PS_r8r8_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_r8r8_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r8r8_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.double3& get_Item(Int32) declare in Unity.Mathematics.double3x2
bool w_PS_r8r8r8_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_r8r8r8_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8r8_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r8r8r8_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.double4& get_Item(Int32) declare in Unity.Mathematics.double4x2
bool w_PS_r8r8r8r8_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_r8r8r8r8_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_r8r8r8r8_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_r8r8r8r8_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.uint2& get_Item(Int32) declare in Unity.Mathematics.uint2x2
bool w_PS_u4u4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_u4u4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_u4u4_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.uint3& get_Item(Int32) declare in Unity.Mathematics.uint3x2
bool w_PS_u4u4u4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_u4u4u4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_u4u4u4_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Unity.Mathematics.uint4& get_Item(Int32) declare in Unity.Mathematics.uint4x2
bool w_PS_u4u4u4u4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_u4u4u4u4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4u4_* (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_u4u4u4u4_* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// UnityEngine.NVIDIA.DLSSCommandInitializationData& get_initData() declare in UnityEngine.NVIDIA.DLSSContext
bool w_PS_u4u4u4u4i4i4u4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PS_u4u4u4u4i4i4u4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u4u4u4u4i4i4u4_* (*FuncToCall)(void*,const void* method);
    struct S_u4u4u4u4i4i4u4_* ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Cysharp.Threading.Tasks.AutoResetUniTaskCompletionSource& get_NextNode() declare in Cysharp.Threading.Tasks.AutoResetUniTaskCompletionSource
bool w_Pot(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Pot");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef Il2CppObject** (*FuncToCall)(void*,const void* method);
    Il2CppObject** ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false)));
    return true;
}

// Void* Unbox(System.Object) declare in System.Reflection.Pointer
bool w_PvO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PvO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef void* (*FuncToCall)(Il2CppObject* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// Void* PinGCObjectAndGetAddress(System.Object, UInt64 ByRef) declare in Unity.Collections.LowLevel.Unsafe.UnsafeUtility
bool w_PvOPu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PvOPu8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    uint64_t up1 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv1);
    uint64_t* p1 = &up1;

    typedef void* (*FuncToCall)(Il2CppObject* p0, uint64_t* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint64_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// Void* CreateCounterValue(IntPtr ByRef, Char*, Int32, UInt16, Unity.Profiling.LowLevel.MarkerFlags, Byte, Byte, Int32, Unity.Profiling.ProfilerCounterOptions) declare in Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility
bool w_PvPpPvi4u2u2u1u1i4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PvPpPvi4u2u2u1u1i4u2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P not primitive
    void** p0 = nullptr;
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint16_t p3 = converter::Converter<uint16_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint16_t p4 = converter::Converter<uint16_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    uint8_t p6 = converter::Converter<uint8_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    uint16_t p8 = converter::Converter<uint16_t>::toCpp(apis, env, _sv8);

    typedef void* (*FuncToCall)(void** p0, void* p1, int32_t p2, uint16_t p3, uint16_t p4, uint8_t p5, uint8_t p6, int32_t p7, uint16_t p8, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    apis->update_boxed_value(env, _sv0, apis->create_binary(env, *p0, 0));
    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// Void* CreateCounterValue(IntPtr ByRef, System.String, UInt16, Unity.Profiling.LowLevel.MarkerFlags, Byte, Byte, Int32, Unity.Profiling.ProfilerCounterOptions) declare in Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility
bool w_PvPpsu2u2u1u1i4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PvPpsu2u2u1u1i4u2");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P not primitive
    void** p0 = nullptr;
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint16_t p3 = converter::Converter<uint16_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    uint16_t p7 = converter::Converter<uint16_t>::toCpp(apis, env, _sv7);

    typedef void* (*FuncToCall)(void** p0, Il2CppString* p1, uint16_t p2, uint16_t p3, uint8_t p4, uint8_t p5, int32_t p6, uint16_t p7, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    apis->update_boxed_value(env, _sv0, apis->create_binary(env, *p0, 0));
    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// Void* CompileUnsafeStaticMethod(System.RuntimeMethodHandle) declare in Unity.Burst.BurstCompiler
bool w_PvS_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PvS_p_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};

    typedef void* (*FuncToCall)(struct S_p_ p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// Void* Malloc(Int64, Int32, Unity.Collections.Allocator) declare in Unity.Collections.LowLevel.Unsafe.UnsafeUtility
bool w_Pvi8i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Pvi8i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void* (*FuncToCall)(int64_t p0, int32_t p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// Void* MallocTracked(Int64, Int32, Unity.Collections.Allocator, Int32) declare in Unity.Collections.LowLevel.Unsafe.UnsafeUtility
bool w_Pvi8i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Pvi8i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void* (*FuncToCall)(int64_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// Void* PinGCArrayAndGetDataAddress(System.Array, UInt64 ByRef) declare in Unity.Collections.LowLevel.Unsafe.UnsafeUtility
bool w_PvoPu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PvoPu8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    uint64_t up1 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv1);
    uint64_t* p1 = &up1;

    typedef void* (*FuncToCall)(Il2CppObject* p0, uint64_t* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint64_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// Void* op_Explicit(IntPtr) declare in System.IntPtr
bool w_Pvp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Pvp");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// Void* GetILPPMethodFunctionPointer2(IntPtr, System.RuntimeMethodHandle, System.RuntimeTypeHandle) declare in Unity.Burst.BurstCompiler
bool w_PvpS_p_S_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PvpS_p_S_p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(apis, env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
    // JSValToCSVal struct
    S_p_* pp2 = DataTransfer::GetPointer<S_p_>(apis, env, _sv2);
    S_p_ p2 = pp2 ? *pp2 : S_p_ {};

    typedef void* (*FuncToCall)(void* p0, struct S_p_ p1, struct S_p_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// Byte* GetUTF8LiteralPointer(System.String, Int32 ByRef) declare in Unity.Burst.BurstRuntime
bool w_PvsPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PvsPi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef void* (*FuncToCall)(Il2CppString* p0, int32_t* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// Void* ToPointer() declare in System.IntPtr
bool w_Pvt(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Pvt");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// Void* GetCounterValuePtr(Int32) declare in UnityEditor.Profiling.FrameDataView
bool w_Pvti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Pvti4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// System.Threading.NativeOverlapped* AllocateNativeOverlapped(System.Threading.PreAllocatedOverlapped) declare in System.Threading.ThreadPoolBoundHandle
bool w_Pvto(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_Pvto");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef void* (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// System.Threading.NativeOverlapped* Pack(System.Threading.IOCompletionCallback, System.Object) declare in System.Threading.Overlapped
bool w_PvtoO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PvtoO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// System.Threading.NativeOverlapped* AllocateNativeOverlapped(System.Threading.IOCompletionCallback, System.Object, System.Object) declare in System.Threading.ThreadPoolBoundHandle
bool w_PvtoOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_PvtoOO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, apis->create_binary(env, ret, 0));
    return true;
}

// System.Collections.DictionaryEntry get_Entry() declare in log4net.Util.NullDictionaryEnumerator
bool w_S_OO_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_OO_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_OO_ (*FuncToCall)(void*,const void* method);
    struct S_OO_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask`1[System.Object] DeserializeAsync(System.IO.Stream, System.Text.Json.Serialization.Metadata.JsonTypeInfo, System.Threading.CancellationToken) declare in System.Text.Json.JsonSerializer
bool w_S_OOi2b_ooDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi2b_ooDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal valuetype  with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_OOi2b_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_o_ p2, const void* method);
    struct S_OOi2b_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask`1[System.Object] DeserializeAsync(System.IO.Stream, System.Type, System.Text.Json.JsonSerializerOptions, System.Threading.CancellationToken) declare in System.Text.Json.JsonSerializer
bool w_S_OOi2b_ooDoDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi2b_ooDoDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                
    // JSValToCSVal valuetype  with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_OOi2b_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, struct S_o_ p3, const void* method);
    struct S_OOi2b_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask`1[System.Object] DeserializeAsync(System.IO.Stream, System.Type, System.Text.Json.Serialization.JsonSerializerContext, System.Threading.CancellationToken) declare in System.Text.Json.JsonSerializer
bool w_S_OOi2b_oooDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi2b_oooDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal valuetype  with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_OOi2b_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, struct S_o_ p3, const void* method);
    struct S_OOi2b_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask`1[System.Object] InvokeAsync(Microsoft.Extensions.AI.AIFunctionArguments, System.Threading.CancellationToken) declare in Microsoft.Extensions.AI.AIFunction
bool w_S_OOi2b_tDoDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi2b_tDoDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal ref  with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 0, TIp0);
                
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_OOi2b_ (*FuncToCall)(void*,Il2CppObject* p0, struct S_o_ p1, const void* method);
    struct S_OOi2b_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Buffers.ReadOnlySequence`1[System.Byte] get_ValueSequence() declare in System.Text.Json.Utf8JsonReader
bool w_S_OOi4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_OOi4i4_ (*FuncToCall)(void*,const void* method);
    struct S_OOi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask`1[System.IO.Pipelines.ReadResult] ReadAtLeastAsync(Int32, System.Threading.CancellationToken) declare in System.IO.Pipelines.PipeReader
bool w_S_OS_S_OOi4i4_u1_i2b_ti4DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_OS_S_OOi4i4_u1_i2b_ti4DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_OS_S_OOi4i4_u1_i2b_ (*FuncToCall)(void*,int32_t p0, struct S_o_ p1, const void* method);
    struct S_OS_S_OOi4i4_u1_i2b_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask`1[System.IO.Pipelines.FlushResult] WriteAsync(System.ReadOnlyMemory`1[System.Byte], System.Threading.CancellationToken) declare in System.IO.Pipelines.PipeWriter
bool w_S_OS_u1_i2b_tS_Oi4i4_DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_OS_u1_i2b_tS_Oi4i4_DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_OS_u1_i2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p0, struct S_o_ p1, const void* method);
    struct S_OS_u1_i2b_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask`1[System.Net.WebSockets.ValueWebSocketReceiveResult] ReceiveAsync(System.Memory`1[System.Byte], System.Threading.CancellationToken) declare in System.Net.WebSockets.ClientWebSocket
bool w_S_OS_u4i4_i2b_tS_Oi4i4_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_OS_u4i4_i2b_tS_Oi4i4_S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};

    typedef struct S_OS_u4i4_i2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p0, struct S_o_ p1, const void* method);
    struct S_OS_u4i4_i2b_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Microsoft.Extensions.Primitives.StringValues Concat(Microsoft.Extensions.Primitives.StringValues ByRef, System.String) declare in Microsoft.Extensions.Primitives.StringValues
bool w_S_O_PS_O_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_O_PS_O_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_O_* p0 = DataTransfer::GetPointer<S_O_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_O_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_O_));
        p0 = &up0;
    }
        
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_O_ (*FuncToCall)(struct S_O_* p0, Il2CppString* p1, const void* method);
    struct S_O_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Microsoft.Extensions.Primitives.StringValues Concat(Microsoft.Extensions.Primitives.StringValues, Microsoft.Extensions.Primitives.StringValues) declare in Microsoft.Extensions.Primitives.StringValues
bool w_S_O_S_O_S_O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_O_S_O_S_O_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_O_* pp0 = DataTransfer::GetPointer<S_O_>(apis, env, _sv0);
    S_O_ p0 = pp0 ? *pp0 : S_O_ {};
    // JSValToCSVal struct
    S_O_* pp1 = DataTransfer::GetPointer<S_O_>(apis, env, _sv1);
    S_O_ p1 = pp1 ? *pp1 : S_O_ {};

    typedef struct S_O_ (*FuncToCall)(struct S_O_ p0, struct S_O_ p1, const void* method);
    struct S_O_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Microsoft.Extensions.Primitives.StringValues op_Implicit(System.String[]) declare in Microsoft.Extensions.Primitives.StringValues
bool w_S_O_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_O_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_O_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_O_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Microsoft.Extensions.Primitives.StringValues op_Implicit(System.String) declare in Microsoft.Extensions.Primitives.StringValues
bool w_S_O_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_O_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_O_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_O_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Microsoft.Extensions.Primitives.StringValues Concat(System.String, Microsoft.Extensions.Primitives.StringValues ByRef) declare in Microsoft.Extensions.Primitives.StringValues
bool w_S_O_sPS_O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_O_sPS_O_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_O_* p1 = DataTransfer::GetPointer<S_O_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_O_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_O_));
        p1 = &up1;
    }
        

    typedef struct S_O_ (*FuncToCall)(Il2CppString* p0, struct S_O_* p1, const void* method);
    struct S_O_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask op_Implicit(Cysharp.Threading.Tasks.UniTask ByRef) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_Oi2b_PS_oi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi2b_PS_oi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_oi2_* p0 = DataTransfer::GetPointer<S_oi2_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oi2_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_oi2_));
        p0 = &up0;
    }
        

    typedef struct S_Oi2b_ (*FuncToCall)(struct S_oi2_* p0, const void* method);
    struct S_Oi2b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask DisposeAsync() declare in System.Threading.CancellationTokenRegistration
bool w_S_Oi2b_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi2b_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_Oi2b_ (*FuncToCall)(void*,const void* method);
    struct S_Oi2b_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask CompleteAsync(System.Exception) declare in System.IO.Pipelines.PipeReader
bool w_S_Oi2b_tDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi2b_tDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal ref  with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 0, TIp0);
                

    typedef struct S_Oi2b_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_Oi2b_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory`1[System.Byte], System.Threading.CancellationToken) declare in System.IO.MemoryStream
bool w_S_Oi2b_tS_Oi4i4_DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi2b_tS_Oi4i4_DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_Oi2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p0, struct S_o_ p1, const void* method);
    struct S_Oi2b_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory`1[System.Byte], System.Threading.CancellationToken) declare in System.Net.Sockets.NetworkStream
bool w_S_Oi2b_tS_Oi4i4_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi2b_tS_Oi4i4_S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};

    typedef struct S_Oi2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p0, struct S_o_ p1, const void* method);
    struct S_Oi2b_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask SendAsync(System.ReadOnlyMemory`1[System.Byte], System.Net.WebSockets.WebSocketMessageType, Boolean, System.Threading.CancellationToken) declare in System.Net.WebSockets.ClientWebSocket
bool w_S_Oi2b_tS_Oi4i4_i4bS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi2b_tS_Oi4i4_i4bS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_o_* pp3 = DataTransfer::GetPointer<S_o_>(apis, env, _sv3);
    S_o_ p3 = pp3 ? *pp3 : S_o_ {};

    typedef struct S_Oi2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p0, int32_t p1, bool p2, struct S_o_ p3, const void* method);
    struct S_Oi2b_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.Serialization.StreamingContext get_StreamingContext() declare in System.Runtime.Serialization.SafeSerializationEventArgs
bool w_S_Oi4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_Oi4_ (*FuncToCall)(void*,const void* method);
    struct S_Oi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask`1[System.Int32] ReadAsync(System.Memory`1[System.Byte], System.Threading.CancellationToken) declare in System.IO.MemoryStream
bool w_S_Oi4i2b_tS_Oi4i4_DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i2b_tS_Oi4i4_DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_Oi4i2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p0, struct S_o_ p1, const void* method);
    struct S_Oi4i2b_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask`1[System.Int32] ReadAsync(System.Memory`1[System.Byte], System.Threading.CancellationToken) declare in System.Net.Sockets.NetworkStream
bool w_S_Oi4i2b_tS_Oi4i4_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i2b_tS_Oi4i4_S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};

    typedef struct S_Oi4i2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p0, struct S_o_ p1, const void* method);
    struct S_Oi4i2b_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask`1[System.Int32] SendAsync(System.Net.Sockets.Socket, System.ReadOnlyMemory`1[System.Byte], System.Net.Sockets.SocketFlags, System.Threading.CancellationToken) declare in System.Net.Sockets.SocketTaskExtensions
bool w_S_Oi4i2b_tS_Oi4i4_i4DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i2b_tS_Oi4i4_i4DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal valuetype  with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_Oi4i2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p0, int32_t p1, struct S_o_ p2, const void* method);
    struct S_Oi4i2b_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlyMemory`1[System.Char] op_Implicit(Microsoft.Extensions.Primitives.StringSegment) declare in Microsoft.Extensions.Primitives.StringSegment
bool w_S_Oi4i4_S_si4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_S_si4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_si4i4_* pp0 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv0);
    S_si4i4_ p0 = pp0 ? *pp0 : S_si4i4_ {};

    typedef struct S_Oi4i4_ (*FuncToCall)(struct S_si4i4_ p0, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlyMemory`1[System.Char] AsMemory(System.String) declare in System.MemoryExtensions
bool w_S_Oi4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_Oi4i4_ (*FuncToCall)(void*,const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlyMemory`1[System.Char] AsMemory(System.String, System.Range) declare in System.MemoryExtensions
bool w_S_Oi4i4_tS_S_i4_S_i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_tS_S_i4_S_i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4_S_i4__* pp0 = DataTransfer::GetPointer<S_S_i4_S_i4__>(apis, env, _sv0);
    S_S_i4_S_i4__ p0 = pp0 ? *pp0 : S_S_i4_S_i4__ {};

    typedef struct S_Oi4i4_ (*FuncToCall)(void*,struct S_S_i4_S_i4__ p0, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlyMemory`1[System.Char] AsMemory(System.String, System.Index) declare in System.MemoryExtensions
bool w_S_Oi4i4_tS_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_tS_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};

    typedef struct S_Oi4i4_ (*FuncToCall)(void*,struct S_i4_ p0, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlyMemory`1[System.Char] AsMemory(System.String, Int32) declare in System.MemoryExtensions
bool w_S_Oi4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_Oi4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlyMemory`1[System.Char] AsMemory(System.String, Int32, Int32) declare in System.MemoryExtensions
bool w_S_Oi4i4_ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_Oi4i4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask`1[System.Data.Common.DbTransaction] BeginTransactionAsync(System.Threading.CancellationToken) declare in System.Data.Common.DbConnection
bool w_S_Ooi2b_tDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Ooi2b_tDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_Ooi2b_ (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    struct S_Ooi2b_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ValueTask`1[System.Data.Common.DbTransaction] BeginTransactionAsync(System.Data.IsolationLevel, System.Threading.CancellationToken) declare in System.Data.Common.DbConnection
bool w_S_Ooi2b_ti4DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Ooi2b_ti4DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_Ooi2b_ (*FuncToCall)(void*,int32_t p0, struct S_o_ p1, const void* method);
    struct S_Ooi2b_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Rendering.TimedScope FromRef(Double ByRef) declare in UnityEditor.Rendering.TimedScope
bool w_S_Pv_Pr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pv_Pr8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    double up0 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv0);
    double* p0 = &up0;

    typedef struct S_Pv_ (*FuncToCall)(double* p0, const void* method);
    struct S_Pv_ ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<double>::toScript(apis, env, *p0));
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Rendering.TimedScope FromPtr(Double*) declare in UnityEditor.Rendering.TimedScope
bool w_S_Pv_Pv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pv_Pv");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef struct S_Pv_ (*FuncToCall)(void* p0, const void* method);
    struct S_Pv_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// ReadOnly get_nativeData() declare in UnityEngine.Networking.DownloadHandler
bool w_S_Pvi4S_pi4i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pvi4S_pi4i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_Pvi4S_pi4i4__ (*FuncToCall)(void*,const void* method);
    struct S_Pvi4S_pi4i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// MeshDataArray AllocateWritableMeshData(Int32) declare in UnityEngine.Mesh
bool w_S_Pvi4i4i4S_pi4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pvi4i4i4S_pi4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_Pvi4i4i4S_pi4i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_Pvi4i4i4S_pi4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// MeshDataArray AcquireReadOnlyMeshData(UnityEngine.Mesh) declare in UnityEngine.Mesh
bool w_S_Pvi4i4i4S_pi4i4__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pvi4i4i4S_pi4i4__o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_Pvi4i4i4S_pi4i4__ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_Pvi4i4i4S_pi4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Collections.NativeArray`1[System.Byte] GetDirectByteBuffer(IntPtr) declare in UnityEngine.AndroidJNI
bool w_S_Pvi4i4i4S_pi4i4_i4_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pvi4i4i4S_pi4i4_i4_p");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef struct S_Pvi4i4i4S_pi4i4_i4_ (*FuncToCall)(void* p0, const void* method);
    struct S_Pvi4i4i4S_pi4i4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Collections.NativeArray`1[System.Byte] get_RawImageDataReference() declare in Unity.Profiling.DebugScreenCapture
bool w_S_Pvi4i4i4S_pi4i4_i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pvi4i4i4S_pi4i4_i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_Pvi4i4i4S_pi4i4_i4_ (*FuncToCall)(void*,const void* method);
    struct S_Pvi4i4i4S_pi4i4_i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Collections.NativeArray`1[System.Int32] GetLightIndexMap(Unity.Collections.Allocator) declare in UnityEngine.Rendering.CullingResults
bool w_S_Pvi4i4i4S_pi4i4_i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pvi4i4i4S_pi4i4_i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_Pvi4i4i4S_pi4i4_i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_Pvi4i4i4S_pi4i4_i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.CompilerServices.ValueTaskAwaiter GetAwaiter() declare in System.Threading.Tasks.ValueTask
bool w_S_S_Oi2b__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Oi2b__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_Oi2b__ (*FuncToCall)(void*,const void* method);
    struct S_S_Oi2b__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable ConfigureAwait(Boolean) declare in System.Threading.Tasks.ValueTask
bool w_S_S_Oi2b__tb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Oi2b__tb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_Oi2b__ (*FuncToCall)(void*,bool p0, const void* method);
    struct S_S_Oi2b__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Net.Security.SslApplicationProtocol get_NegotiatedApplicationProtocol() declare in System.Net.Security.SslStream
bool w_S_S_Oi4i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Oi4i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_Oi4i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_Oi4i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.PickingIncludeExcludeList GetPickingIncludeExcludeList(Unity.Collections.Allocator) declare in UnityEditor.HandleUtility
bool w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__Di4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.ParticleSystemJobs.ParticleSystemNativeArray4 get_customData1() declare in UnityEngine.ParticleSystemJobs.ParticleSystemJobData
bool w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.ParticleSystemJobs.ParticleSystemNativeArray3 get_positions() declare in UnityEngine.ParticleSystemJobs.ParticleSystemJobData
bool w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.ObjectChangeEventStream Clone(Unity.Collections.Allocator) declare in UnityEditor.ObjectChangeEventStream
bool w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.CompilerServices.AsyncIteratorMethodBuilder Create() declare in System.Runtime.CompilerServices.AsyncIteratorMethodBuilder
bool w_S_S_S_S_oo_o___(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_S_oo_o___");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_S_S_oo_o___ (*FuncToCall)(const void* method);
    struct S_S_S_S_oo_o___ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder Create() declare in System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder
bool w_S_S_S_S_oo_o__bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_S_oo_o__bb_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_S_S_oo_o__bb_ (*FuncToCall)(const void* method);
    struct S_S_S_S_oo_o__bb_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// AssetDatabaseCounters get_counters() declare in UnityEditor.Experimental.AssetDatabaseExperimental
bool w_S_S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8__S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8___(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8__S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8___");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8__S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8___ (*FuncToCall)(const void* method);
    struct S_S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8__S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8___ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.CompilerServices.AsyncTaskMethodBuilder Create() declare in System.Runtime.CompilerServices.AsyncTaskMethodBuilder
bool w_S_S_S_oo_o__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_oo_o__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_S_oo_o__ (*FuncToCall)(const void* method);
    struct S_S_S_oo_o__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleTransformOrigin op_Implicit(UnityEngine.UIElements.TransformOrigin) declare in UnityEngine.UIElements.StyleTransformOrigin
bool w_S_S_S_r4i4_S_r4i4_r4_i4_S_S_r4i4_S_r4i4_r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4i4_S_r4i4_r4_i4_S_S_r4i4_S_r4i4_r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4i4_S_r4i4_r4_* pp0 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4_>(apis, env, _sv0);
    S_S_r4i4_S_r4i4_r4_ p0 = pp0 ? *pp0 : S_S_r4i4_S_r4i4_r4_ {};

    typedef struct S_S_S_r4i4_S_r4i4_r4_i4_ (*FuncToCall)(struct S_S_r4i4_S_r4i4_r4_ p0, const void* method);
    struct S_S_S_r4i4_S_r4i4_r4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleTransformOrigin op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleTransformOrigin
bool w_S_S_S_r4i4_S_r4i4_r4_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4i4_S_r4i4_r4_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_S_r4i4_S_r4i4_r4_i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_S_r4i4_S_r4i4_r4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleTranslate op_Implicit(UnityEngine.UIElements.Translate) declare in UnityEngine.UIElements.StyleTranslate
bool w_S_S_S_r4i4_S_r4i4_r4b_i4_S_S_r4i4_S_r4i4_r4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4i4_S_r4i4_r4b_i4_S_S_r4i4_S_r4i4_r4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4i4_S_r4i4_r4b_* pp0 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4b_>(apis, env, _sv0);
    S_S_r4i4_S_r4i4_r4b_ p0 = pp0 ? *pp0 : S_S_r4i4_S_r4i4_r4b_ {};

    typedef struct S_S_S_r4i4_S_r4i4_r4b_i4_ (*FuncToCall)(struct S_S_r4i4_S_r4i4_r4b_ p0, const void* method);
    struct S_S_S_r4i4_S_r4i4_r4b_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleTranslate op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleTranslate
bool w_S_S_S_r4i4_S_r4i4_r4b_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4i4_S_r4i4_r4b_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_S_r4i4_S_r4i4_r4b_i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_S_r4i4_S_r4i4_r4b_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleRotate op_Implicit(UnityEngine.UIElements.Rotate) declare in UnityEngine.UIElements.StyleRotate
bool w_S_S_S_r4i4_S_r4r4r4_b_i4_S_S_r4i4_S_r4r4r4_b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4i4_S_r4r4r4_b_i4_S_S_r4i4_S_r4r4r4_b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4i4_S_r4r4r4_b_* pp0 = DataTransfer::GetPointer<S_S_r4i4_S_r4r4r4_b_>(apis, env, _sv0);
    S_S_r4i4_S_r4r4r4_b_ p0 = pp0 ? *pp0 : S_S_r4i4_S_r4r4r4_b_ {};

    typedef struct S_S_S_r4i4_S_r4r4r4_b_i4_ (*FuncToCall)(struct S_S_r4i4_S_r4r4r4_b_ p0, const void* method);
    struct S_S_S_r4i4_S_r4r4r4_b_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleRotate op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleRotate
bool w_S_S_S_r4i4_S_r4r4r4_b_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4i4_S_r4r4r4_b_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_S_r4i4_S_r4r4r4_b_i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_S_r4i4_S_r4r4r4_b_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.SubMeshDescriptor GetSubMesh(Int32) declare in UnityEngine.Mesh
bool w_S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleScale op_Implicit(UnityEngine.UIElements.Scale) declare in UnityEngine.UIElements.StyleScale
bool w_S_S_S_r4r4r4_b_i4_S_S_r4r4r4_b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4_b_i4_S_S_r4r4r4_b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_b_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_b_>(apis, env, _sv0);
    S_S_r4r4r4_b_ p0 = pp0 ? *pp0 : S_S_r4r4r4_b_ {};

    typedef struct S_S_S_r4r4r4_b_i4_ (*FuncToCall)(struct S_S_r4r4r4_b_ p0, const void* method);
    struct S_S_S_r4r4r4_b_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleScale op_Implicit(UnityEngine.Vector2) declare in UnityEngine.UIElements.StyleScale
bool w_S_S_S_r4r4r4_b_i4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4_b_i4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_S_S_r4r4r4_b_i4_ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_S_S_r4r4r4_b_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleScale op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleScale
bool w_S_S_S_r4r4r4_b_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4_b_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_S_r4r4r4_b_i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_S_r4r4r4_b_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.RigidTransform inverse(Unity.Mathematics.RigidTransform) declare in Unity.Mathematics.math
bool w_S_S_S_r4r4r4r4__S_r4r4r4__S_S_S_r4r4r4r4__S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4__S_r4r4r4__S_S_S_r4r4r4r4__S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4r4r4r4__S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_S_r4r4r4r4__S_r4r4r4__>(apis, env, _sv0);
    S_S_S_r4r4r4r4__S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_S_r4r4r4r4__S_r4r4r4__ {};

    typedef struct S_S_S_r4r4r4r4__S_r4r4r4__ (*FuncToCall)(struct S_S_S_r4r4r4r4__S_r4r4r4__ p0, const void* method);
    struct S_S_S_r4r4r4r4__S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.RigidTransform mul(Unity.Mathematics.RigidTransform, Unity.Mathematics.RigidTransform) declare in Unity.Mathematics.math
bool w_S_S_S_r4r4r4r4__S_r4r4r4__S_S_S_r4r4r4r4__S_r4r4r4__S_S_S_r4r4r4r4__S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4__S_r4r4r4__S_S_S_r4r4r4r4__S_r4r4r4__S_S_S_r4r4r4r4__S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4r4r4r4__S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_S_r4r4r4r4__S_r4r4r4__>(apis, env, _sv0);
    S_S_S_r4r4r4r4__S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_S_r4r4r4r4__S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_S_r4r4r4r4__S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_S_r4r4r4r4__S_r4r4r4__>(apis, env, _sv1);
    S_S_S_r4r4r4r4__S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_S_r4r4r4r4__S_r4r4r4__ {};

    typedef struct S_S_S_r4r4r4r4__S_r4r4r4__ (*FuncToCall)(struct S_S_S_r4r4r4r4__S_r4r4r4__ p0, struct S_S_S_r4r4r4r4__S_r4r4r4__ p1, const void* method);
    struct S_S_S_r4r4r4r4__S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.RigidTransform RigidTransform(Unity.Mathematics.float3x3, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_S_S_r4r4r4r4__S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4__S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_S_S_r4r4r4r4__S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_S_S_r4r4r4r4__S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.RigidTransform RigidTransform(Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_S_S_S_r4r4r4r4__S_r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4__S_r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_S_r4r4r4r4__S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_S_r4r4r4r4__S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.RigidTransform RigidTransform(Unity.Mathematics.quaternion, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_S_S_r4r4r4r4__S_r4r4r4__S_S_r4r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4__S_r4r4r4__S_S_r4r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_S_S_r4r4r4r4__S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_S_S_r4r4r4r4__S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.RigidTransform EulerXYZ(Unity.Mathematics.float3) declare in Unity.Mathematics.RigidTransform
bool w_S_S_S_r4r4r4r4__S_r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4__S_r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_S_S_r4r4r4r4__S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_S_S_r4r4r4r4__S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.RigidTransform Euler(Unity.Mathematics.float3, RotationOrder) declare in Unity.Mathematics.RigidTransform
bool w_S_S_S_r4r4r4r4__S_r4r4r4__S_r4r4r4_Du1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4__S_r4r4r4__S_r4r4r4_Du1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    uint8_t p1 = OptionalParameter<uint8_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_S_S_r4r4r4r4__S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, uint8_t p1, const void* method);
    struct S_S_S_r4r4r4r4__S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.RigidTransform AxisAngle(Unity.Mathematics.float3, Single) declare in Unity.Mathematics.RigidTransform
bool w_S_S_S_r4r4r4r4__S_r4r4r4__S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4__S_r4r4r4__S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_S_r4r4r4r4__S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, float p1, const void* method);
    struct S_S_S_r4r4r4r4__S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.RigidTransform RotateX(Single) declare in Unity.Mathematics.RigidTransform
bool w_S_S_S_r4r4r4r4__S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4__S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_S_r4r4r4r4__S_r4r4r4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_S_r4r4r4r4__S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.RigidTransform EulerXYZ(Single, Single, Single) declare in Unity.Mathematics.RigidTransform
bool w_S_S_S_r4r4r4r4__S_r4r4r4__r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4__S_r4r4r4__r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_S_S_r4r4r4r4__S_r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, const void* method);
    struct S_S_S_r4r4r4r4__S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.RigidTransform Euler(Single, Single, Single, RotationOrder) declare in Unity.Mathematics.RigidTransform
bool w_S_S_S_r4r4r4r4__S_r4r4r4__r4r4r4Du1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4__S_r4r4r4__r4r4r4Du1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    uint8_t p3 = OptionalParameter<uint8_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_S_S_r4r4r4r4__S_r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, uint8_t p3, const void* method);
    struct S_S_S_r4r4r4r4__S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.DrawingSettings CreateDrawingSettings(UnityEngine.Rendering.ShaderTagId, UnityEngine.Rendering.Universal.RenderingData ByRef, UnityEngine.Rendering.SortingCriteria) declare in UnityEngine.Rendering.Universal.RenderingUtils
bool w_S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_i4_PS_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_i4_PS_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal Pstruct
    S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_* p1 = DataTransfer::GetPointer<S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(struct S_i4_ p0, struct S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_* p1, int32_t p2, const void* method);
    struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.DrawingSettings CreateDrawingSettings(System.Collections.Generic.List`1[UnityEngine.Rendering.ShaderTagId], UnityEngine.Rendering.Universal.RenderingData ByRef, UnityEngine.Rendering.SortingCriteria) declare in UnityEngine.Rendering.Universal.RenderingUtils
bool w_S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_oPS_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_oPS_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_* p1 = DataTransfer::GetPointer<S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(Il2CppObject* p0, struct S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_* p1, int32_t p2, const void* method);
    struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.DrawingSettings CreateDrawingSettings(UnityEngine.Rendering.ShaderTagId, UnityEngine.Rendering.Universal.RenderingData ByRef, UnityEngine.Rendering.SortingCriteria) declare in UnityEngine.Rendering.Universal.ScriptableRenderPass
bool w_S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_tS_i4_PS_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_tS_i4_PS_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal Pstruct
    S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_* p1 = DataTransfer::GetPointer<S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(void*,struct S_i4_ p0, struct S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_* p1, int32_t p2, const void* method);
    struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.DrawingSettings CreateDrawingSettings(System.Collections.Generic.List`1[UnityEngine.Rendering.ShaderTagId], UnityEngine.Rendering.Universal.RenderingData ByRef, UnityEngine.Rendering.SortingCriteria) declare in UnityEngine.Rendering.Universal.ScriptableRenderPass
bool w_S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_toPS_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_toPS_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_* p1 = DataTransfer::GetPointer<S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(void*,Il2CppObject* p0, struct S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_* p1, int32_t p2, const void* method);
    struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LogicalNot(Unity.Mathematics.bool2x4) declare in Unity.Mathematics.bool2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_Equality(Unity.Mathematics.bool2x4, Unity.Mathematics.bool2x4) declare in Unity.Mathematics.bool2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb_S_bb__ {};
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp1 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv1);
    S_S_bb_S_bb_S_bb_S_bb__ p1 = pp1 ? *pp1 : S_S_bb_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb_S_bb__ p0, struct S_S_bb_S_bb_S_bb_S_bb__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_Equality(Unity.Mathematics.bool2x4, Boolean) declare in Unity.Mathematics.bool2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb_S_bb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb_S_bb__b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb_S_bb__ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb_S_bb__ p0, bool p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 transpose(Unity.Mathematics.bool4x2) declare in Unity.Mathematics.math
bool w_S_S_bb_S_bb_S_bb_S_bb__S_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb__ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LessThan(Unity.Mathematics.int2x4, Unity.Mathematics.int2x4) declare in Unity.Mathematics.int2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LessThan(Unity.Mathematics.int2x4, Int32) declare in Unity.Mathematics.int2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, int32_t p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LessThan(Unity.Mathematics.float2x4, Unity.Mathematics.float2x4) declare in Unity.Mathematics.float2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LessThan(Unity.Mathematics.float2x4, Single) declare in Unity.Mathematics.float2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, float p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LessThan(Unity.Mathematics.double2x4, Unity.Mathematics.double2x4) declare in Unity.Mathematics.double2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LessThan(Unity.Mathematics.double2x4, Double) declare in Unity.Mathematics.double2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, double p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LessThan(Unity.Mathematics.uint2x4, Unity.Mathematics.uint2x4) declare in Unity.Mathematics.uint2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LessThan(Unity.Mathematics.uint2x4, UInt32) declare in Unity.Mathematics.uint2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 bool2x4(Unity.Mathematics.bool2, Unity.Mathematics.bool2, Unity.Mathematics.bool2, Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_S_bb_S_bb_S_bb_S_bb__S_bb_S_bb_S_bb_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__S_bb_S_bb_S_bb_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp2 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv2);
    S_bb_ p2 = pp2 ? *pp2 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp3 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv3);
    S_bb_ p3 = pp3 ? *pp3 : S_bb_ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_bb_ p0, struct S_bb_ p1, struct S_bb_ p2, struct S_bb_ p3, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 bool2x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_bb_S_bb_S_bb_S_bb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_Equality(Boolean, Unity.Mathematics.bool2x4) declare in Unity.Mathematics.bool2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__bS_S_bb_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__bS_S_bb_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp1 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv1);
    S_S_bb_S_bb_S_bb_S_bb__ p1 = pp1 ? *pp1 : S_S_bb_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(bool p0, struct S_S_bb_S_bb_S_bb_S_bb__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 bool2x4(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_S_bb_S_bb_S_bb_S_bb__bbbbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__bbbbbbbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LessThan(Int32, Unity.Mathematics.int2x4) declare in Unity.Mathematics.int2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__i4S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__i4S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(int32_t p0, struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LessThan(Single, Unity.Mathematics.float2x4) declare in Unity.Mathematics.float2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__r4S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__r4S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(float p0, struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LessThan(Double, Unity.Mathematics.double2x4) declare in Unity.Mathematics.double2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__r8S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__r8S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(double p0, struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x4 op_LessThan(UInt32, Unity.Mathematics.uint2x4) declare in Unity.Mathematics.uint2x4
bool w_S_S_bb_S_bb_S_bb_S_bb__u4S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb_S_bb__u4S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_bb_S_bb_S_bb_S_bb__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LogicalNot(Unity.Mathematics.bool2x3) declare in Unity.Mathematics.bool2x3
bool w_S_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_Equality(Unity.Mathematics.bool2x3, Unity.Mathematics.bool2x3) declare in Unity.Mathematics.bool2x3
bool w_S_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb__ {};
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp1 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv1);
    S_S_bb_S_bb_S_bb__ p1 = pp1 ? *pp1 : S_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb__ p0, struct S_S_bb_S_bb_S_bb__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_Equality(Unity.Mathematics.bool2x3, Boolean) declare in Unity.Mathematics.bool2x3
bool w_S_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_S_bb_S_bb_S_bb__b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb__ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb__ p0, bool p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 transpose(Unity.Mathematics.bool3x2) declare in Unity.Mathematics.math
bool w_S_S_bb_S_bb_S_bb__S_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb__ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LessThan(Unity.Mathematics.int2x3, Unity.Mathematics.int2x3) declare in Unity.Mathematics.int2x3
bool w_S_S_bb_S_bb_S_bb__S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, struct S_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LessThan(Unity.Mathematics.int2x3, Int32) declare in Unity.Mathematics.int2x3
bool w_S_S_bb_S_bb_S_bb__S_S_i4i4_S_i4i4_S_i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_S_i4i4_S_i4i4_S_i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, int32_t p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LessThan(Unity.Mathematics.float2x3, Unity.Mathematics.float2x3) declare in Unity.Mathematics.float2x3
bool w_S_S_bb_S_bb_S_bb__S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, struct S_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LessThan(Unity.Mathematics.float2x3, Single) declare in Unity.Mathematics.float2x3
bool w_S_S_bb_S_bb_S_bb__S_S_r4r4_S_r4r4_S_r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_S_r4r4_S_r4r4_S_r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, float p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LessThan(Unity.Mathematics.double2x3, Unity.Mathematics.double2x3) declare in Unity.Mathematics.double2x3
bool w_S_S_bb_S_bb_S_bb__S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, struct S_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LessThan(Unity.Mathematics.double2x3, Double) declare in Unity.Mathematics.double2x3
bool w_S_S_bb_S_bb_S_bb__S_S_r8r8_S_r8r8_S_r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_S_r8r8_S_r8r8_S_r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, double p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LessThan(Unity.Mathematics.uint2x3, Unity.Mathematics.uint2x3) declare in Unity.Mathematics.uint2x3
bool w_S_S_bb_S_bb_S_bb__S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, struct S_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LessThan(Unity.Mathematics.uint2x3, UInt32) declare in Unity.Mathematics.uint2x3
bool w_S_S_bb_S_bb_S_bb__S_S_u4u4_S_u4u4_S_u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_S_u4u4_S_u4u4_S_u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 bool2x3(Unity.Mathematics.bool2, Unity.Mathematics.bool2, Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_S_bb_S_bb_S_bb__S_bb_S_bb_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__S_bb_S_bb_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp2 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv2);
    S_bb_ p2 = pp2 ? *pp2 : S_bb_ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(struct S_bb_ p0, struct S_bb_ p1, struct S_bb_ p2, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 bool2x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_bb_S_bb_S_bb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_Equality(Boolean, Unity.Mathematics.bool2x3) declare in Unity.Mathematics.bool2x3
bool w_S_S_bb_S_bb_S_bb__bS_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__bS_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp1 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv1);
    S_S_bb_S_bb_S_bb__ p1 = pp1 ? *pp1 : S_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(bool p0, struct S_S_bb_S_bb_S_bb__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 bool2x3(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_S_bb_S_bb_S_bb__bbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__bbbbbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LessThan(Int32, Unity.Mathematics.int2x3) declare in Unity.Mathematics.int2x3
bool w_S_S_bb_S_bb_S_bb__i4S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__i4S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(int32_t p0, struct S_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LessThan(Single, Unity.Mathematics.float2x3) declare in Unity.Mathematics.float2x3
bool w_S_S_bb_S_bb_S_bb__r4S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__r4S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(float p0, struct S_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LessThan(Double, Unity.Mathematics.double2x3) declare in Unity.Mathematics.double2x3
bool w_S_S_bb_S_bb_S_bb__r8S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__r8S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(double p0, struct S_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x3 op_LessThan(UInt32, Unity.Mathematics.uint2x3) declare in Unity.Mathematics.uint2x3
bool w_S_S_bb_S_bb_S_bb__u4S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb_S_bb__u4S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_bb_S_bb_S_bb__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_bb_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 transpose(Unity.Mathematics.bool2x2) declare in Unity.Mathematics.math
bool w_S_S_bb_S_bb__S_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__S_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb__ {};

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(struct S_S_bb_S_bb__ p0, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_Equality(Unity.Mathematics.bool2x2, Unity.Mathematics.bool2x2) declare in Unity.Mathematics.bool2x2
bool w_S_S_bb_S_bb__S_S_bb_S_bb__S_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__S_S_bb_S_bb__S_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb__ {};
    // JSValToCSVal struct
    S_S_bb_S_bb__* pp1 = DataTransfer::GetPointer<S_S_bb_S_bb__>(apis, env, _sv1);
    S_S_bb_S_bb__ p1 = pp1 ? *pp1 : S_S_bb_S_bb__ {};

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(struct S_S_bb_S_bb__ p0, struct S_S_bb_S_bb__ p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_Equality(Unity.Mathematics.bool2x2, Boolean) declare in Unity.Mathematics.bool2x2
bool w_S_S_bb_S_bb__S_S_bb_S_bb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__S_S_bb_S_bb__b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb__ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(struct S_S_bb_S_bb__ p0, bool p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_LessThan(Unity.Mathematics.int2x2, Unity.Mathematics.int2x2) declare in Unity.Mathematics.int2x2
bool w_S_S_bb_S_bb__S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4__ {};

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, struct S_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_LessThan(Unity.Mathematics.int2x2, Int32) declare in Unity.Mathematics.int2x2
bool w_S_S_bb_S_bb__S_S_i4i4_S_i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__S_S_i4i4_S_i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, int32_t p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_LessThan(Unity.Mathematics.float2x2, Unity.Mathematics.float2x2) declare in Unity.Mathematics.float2x2
bool w_S_S_bb_S_bb__S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4__ {};

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, struct S_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_LessThan(Unity.Mathematics.float2x2, Single) declare in Unity.Mathematics.float2x2
bool w_S_S_bb_S_bb__S_S_r4r4_S_r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__S_S_r4r4_S_r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, float p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_LessThan(Unity.Mathematics.double2x2, Unity.Mathematics.double2x2) declare in Unity.Mathematics.double2x2
bool w_S_S_bb_S_bb__S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8__ {};

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, struct S_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_LessThan(Unity.Mathematics.double2x2, Double) declare in Unity.Mathematics.double2x2
bool w_S_S_bb_S_bb__S_S_r8r8_S_r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__S_S_r8r8_S_r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, double p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_LessThan(Unity.Mathematics.uint2x2, Unity.Mathematics.uint2x2) declare in Unity.Mathematics.uint2x2
bool w_S_S_bb_S_bb__S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4__ {};

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, struct S_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_LessThan(Unity.Mathematics.uint2x2, UInt32) declare in Unity.Mathematics.uint2x2
bool w_S_S_bb_S_bb__S_S_u4u4_S_u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__S_S_u4u4_S_u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 bool2x2(Unity.Mathematics.bool2, Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_S_bb_S_bb__S_bb_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__S_bb_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(struct S_bb_ p0, struct S_bb_ p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 bool2x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_bb_S_bb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_Equality(Boolean, Unity.Mathematics.bool2x2) declare in Unity.Mathematics.bool2x2
bool w_S_S_bb_S_bb__bS_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__bS_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_bb_S_bb__* pp1 = DataTransfer::GetPointer<S_S_bb_S_bb__>(apis, env, _sv1);
    S_S_bb_S_bb__ p1 = pp1 ? *pp1 : S_S_bb_S_bb__ {};

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(bool p0, struct S_S_bb_S_bb__ p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 bool2x2(Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_S_bb_S_bb__bbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__bbbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(bool p0, bool p1, bool p2, bool p3, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_LessThan(Int32, Unity.Mathematics.int2x2) declare in Unity.Mathematics.int2x2
bool w_S_S_bb_S_bb__i4S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__i4S_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4__ {};

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(int32_t p0, struct S_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_LessThan(Single, Unity.Mathematics.float2x2) declare in Unity.Mathematics.float2x2
bool w_S_S_bb_S_bb__r4S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__r4S_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4__ {};

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(float p0, struct S_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_LessThan(Double, Unity.Mathematics.double2x2) declare in Unity.Mathematics.double2x2
bool w_S_S_bb_S_bb__r8S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__r8S_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8__ {};

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(double p0, struct S_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2x2 op_LessThan(UInt32, Unity.Mathematics.uint2x2) declare in Unity.Mathematics.uint2x2
bool w_S_S_bb_S_bb__u4S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bb_S_bb__u4S_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4__ {};

    typedef struct S_S_bb_S_bb__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_bb_S_bb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LogicalNot(Unity.Mathematics.bool3x4) declare in Unity.Mathematics.bool3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_Equality(Unity.Mathematics.bool3x4, Unity.Mathematics.bool3x4) declare in Unity.Mathematics.bool3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp1 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv1);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p1 = pp1 ? *pp1 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p0, struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_Equality(Unity.Mathematics.bool3x4, Boolean) declare in Unity.Mathematics.bool3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb_S_bbb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb_S_bbb__b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p0, bool p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 transpose(Unity.Mathematics.bool4x3) declare in Unity.Mathematics.math
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LessThan(Unity.Mathematics.int3x4, Unity.Mathematics.int3x4) declare in Unity.Mathematics.int3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LessThan(Unity.Mathematics.int3x4, Int32) declare in Unity.Mathematics.int3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, int32_t p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LessThan(Unity.Mathematics.float3x4, Unity.Mathematics.float3x4) declare in Unity.Mathematics.float3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LessThan(Unity.Mathematics.float3x4, Single) declare in Unity.Mathematics.float3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, float p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LessThan(Unity.Mathematics.double3x4, Unity.Mathematics.double3x4) declare in Unity.Mathematics.double3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LessThan(Unity.Mathematics.double3x4, Double) declare in Unity.Mathematics.double3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, double p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LessThan(Unity.Mathematics.uint3x4, Unity.Mathematics.uint3x4) declare in Unity.Mathematics.uint3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LessThan(Unity.Mathematics.uint3x4, UInt32) declare in Unity.Mathematics.uint3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 bool3x4(Unity.Mathematics.bool3, Unity.Mathematics.bool3, Unity.Mathematics.bool3, Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_bbb_S_bbb_S_bbb_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__S_bbb_S_bbb_S_bbb_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp2 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv2);
    S_bbb_ p2 = pp2 ? *pp2 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp3 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv3);
    S_bbb_ p3 = pp3 ? *pp3 : S_bbb_ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_bbb_ p0, struct S_bbb_ p1, struct S_bbb_ p2, struct S_bbb_ p3, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 bool3x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_Equality(Boolean, Unity.Mathematics.bool3x4) declare in Unity.Mathematics.bool3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__bS_S_bbb_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__bS_S_bbb_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp1 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv1);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p1 = pp1 ? *pp1 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(bool p0, struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 bool3x4(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__bbbbbbbbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__bbbbbbbbbbbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    bool p10 = converter::Converter<bool>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    bool p11 = converter::Converter<bool>::toCpp(apis, env, _sv11);

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LessThan(Int32, Unity.Mathematics.int3x4) declare in Unity.Mathematics.int3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__i4S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__i4S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(int32_t p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LessThan(Single, Unity.Mathematics.float3x4) declare in Unity.Mathematics.float3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__r4S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__r4S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(float p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LessThan(Double, Unity.Mathematics.double3x4) declare in Unity.Mathematics.double3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__r8S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__r8S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(double p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x4 op_LessThan(UInt32, Unity.Mathematics.uint3x4) declare in Unity.Mathematics.uint3x4
bool w_S_S_bbb_S_bbb_S_bbb_S_bbb__u4S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb_S_bbb__u4S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 transpose(Unity.Mathematics.bool3x3) declare in Unity.Mathematics.math
bool w_S_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_Equality(Unity.Mathematics.bool3x3, Unity.Mathematics.bool3x3) declare in Unity.Mathematics.bool3x3
bool w_S_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb__ {};
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb__* pp1 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb__>(apis, env, _sv1);
    S_S_bbb_S_bbb_S_bbb__ p1 = pp1 ? *pp1 : S_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb__ p0, struct S_S_bbb_S_bbb_S_bbb__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_Equality(Unity.Mathematics.bool3x3, Boolean) declare in Unity.Mathematics.bool3x3
bool w_S_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__S_S_bbb_S_bbb_S_bbb__b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb__ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb__ p0, bool p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_LessThan(Unity.Mathematics.int3x3, Unity.Mathematics.int3x3) declare in Unity.Mathematics.int3x3
bool w_S_S_bbb_S_bbb_S_bbb__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_LessThan(Unity.Mathematics.int3x3, Int32) declare in Unity.Mathematics.int3x3
bool w_S_S_bbb_S_bbb_S_bbb__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, int32_t p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_LessThan(Unity.Mathematics.float3x3, Unity.Mathematics.float3x3) declare in Unity.Mathematics.float3x3
bool w_S_S_bbb_S_bbb_S_bbb__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_LessThan(Unity.Mathematics.float3x3, Single) declare in Unity.Mathematics.float3x3
bool w_S_S_bbb_S_bbb_S_bbb__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, float p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_LessThan(Unity.Mathematics.double3x3, Unity.Mathematics.double3x3) declare in Unity.Mathematics.double3x3
bool w_S_S_bbb_S_bbb_S_bbb__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_LessThan(Unity.Mathematics.double3x3, Double) declare in Unity.Mathematics.double3x3
bool w_S_S_bbb_S_bbb_S_bbb__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, double p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_LessThan(Unity.Mathematics.uint3x3, Unity.Mathematics.uint3x3) declare in Unity.Mathematics.uint3x3
bool w_S_S_bbb_S_bbb_S_bbb__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_LessThan(Unity.Mathematics.uint3x3, UInt32) declare in Unity.Mathematics.uint3x3
bool w_S_S_bbb_S_bbb_S_bbb__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 bool3x3(Unity.Mathematics.bool3, Unity.Mathematics.bool3, Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_S_bbb_S_bbb_S_bbb__S_bbb_S_bbb_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__S_bbb_S_bbb_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp2 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv2);
    S_bbb_ p2 = pp2 ? *pp2 : S_bbb_ {};

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(struct S_bbb_ p0, struct S_bbb_ p1, struct S_bbb_ p2, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 bool3x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_bbb_S_bbb_S_bbb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_Equality(Boolean, Unity.Mathematics.bool3x3) declare in Unity.Mathematics.bool3x3
bool w_S_S_bbb_S_bbb_S_bbb__bS_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__bS_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb__* pp1 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb__>(apis, env, _sv1);
    S_S_bbb_S_bbb_S_bbb__ p1 = pp1 ? *pp1 : S_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(bool p0, struct S_S_bbb_S_bbb_S_bbb__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 bool3x3(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_S_bbb_S_bbb_S_bbb__bbbbbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__bbbbbbbbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_LessThan(Int32, Unity.Mathematics.int3x3) declare in Unity.Mathematics.int3x3
bool w_S_S_bbb_S_bbb_S_bbb__i4S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__i4S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(int32_t p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_LessThan(Single, Unity.Mathematics.float3x3) declare in Unity.Mathematics.float3x3
bool w_S_S_bbb_S_bbb_S_bbb__r4S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__r4S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(float p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_LessThan(Double, Unity.Mathematics.double3x3) declare in Unity.Mathematics.double3x3
bool w_S_S_bbb_S_bbb_S_bbb__r8S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__r8S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(double p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x3 op_LessThan(UInt32, Unity.Mathematics.uint3x3) declare in Unity.Mathematics.uint3x3
bool w_S_S_bbb_S_bbb_S_bbb__u4S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb_S_bbb__u4S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_bbb_S_bbb_S_bbb__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_bbb_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 transpose(Unity.Mathematics.bool2x3) declare in Unity.Mathematics.math
bool w_S_S_bbb_S_bbb__S_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LogicalNot(Unity.Mathematics.bool3x2) declare in Unity.Mathematics.bool3x2
bool w_S_S_bbb_S_bbb__S_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb__ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_Equality(Unity.Mathematics.bool3x2, Unity.Mathematics.bool3x2) declare in Unity.Mathematics.bool3x2
bool w_S_S_bbb_S_bbb__S_S_bbb_S_bbb__S_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_S_bbb_S_bbb__S_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb__ {};
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp1 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv1);
    S_S_bbb_S_bbb__ p1 = pp1 ? *pp1 : S_S_bbb_S_bbb__ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_bbb_S_bbb__ p0, struct S_S_bbb_S_bbb__ p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_Equality(Unity.Mathematics.bool3x2, Boolean) declare in Unity.Mathematics.bool3x2
bool w_S_S_bbb_S_bbb__S_S_bbb_S_bbb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_S_bbb_S_bbb__b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb__ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_bbb_S_bbb__ p0, bool p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LessThan(Unity.Mathematics.int3x2, Unity.Mathematics.int3x2) declare in Unity.Mathematics.int3x2
bool w_S_S_bbb_S_bbb__S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LessThan(Unity.Mathematics.int3x2, Int32) declare in Unity.Mathematics.int3x2
bool w_S_S_bbb_S_bbb__S_S_i4i4i4_S_i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_S_i4i4i4_S_i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, int32_t p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LessThan(Unity.Mathematics.float3x2, Unity.Mathematics.float3x2) declare in Unity.Mathematics.float3x2
bool w_S_S_bbb_S_bbb__S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LessThan(Unity.Mathematics.float3x2, Single) declare in Unity.Mathematics.float3x2
bool w_S_S_bbb_S_bbb__S_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LessThan(Unity.Mathematics.double3x2, Unity.Mathematics.double3x2) declare in Unity.Mathematics.double3x2
bool w_S_S_bbb_S_bbb__S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LessThan(Unity.Mathematics.double3x2, Double) declare in Unity.Mathematics.double3x2
bool w_S_S_bbb_S_bbb__S_S_r8r8r8_S_r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_S_r8r8r8_S_r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, double p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LessThan(Unity.Mathematics.uint3x2, Unity.Mathematics.uint3x2) declare in Unity.Mathematics.uint3x2
bool w_S_S_bbb_S_bbb__S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LessThan(Unity.Mathematics.uint3x2, UInt32) declare in Unity.Mathematics.uint3x2
bool w_S_S_bbb_S_bbb__S_S_u4u4u4_S_u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_S_u4u4u4_S_u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 bool3x2(Unity.Mathematics.bool3, Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_S_bbb_S_bbb__S_bbb_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__S_bbb_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(struct S_bbb_ p0, struct S_bbb_ p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 bool3x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_bbb_S_bbb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_Equality(Boolean, Unity.Mathematics.bool3x2) declare in Unity.Mathematics.bool3x2
bool w_S_S_bbb_S_bbb__bS_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__bS_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp1 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv1);
    S_S_bbb_S_bbb__ p1 = pp1 ? *pp1 : S_S_bbb_S_bbb__ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(bool p0, struct S_S_bbb_S_bbb__ p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 bool3x2(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_S_bbb_S_bbb__bbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__bbbbbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LessThan(Int32, Unity.Mathematics.int3x2) declare in Unity.Mathematics.int3x2
bool w_S_S_bbb_S_bbb__i4S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__i4S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(int32_t p0, struct S_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LessThan(Single, Unity.Mathematics.float3x2) declare in Unity.Mathematics.float3x2
bool w_S_S_bbb_S_bbb__r4S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__r4S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(float p0, struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LessThan(Double, Unity.Mathematics.double3x2) declare in Unity.Mathematics.double3x2
bool w_S_S_bbb_S_bbb__r8S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__r8S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(double p0, struct S_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3x2 op_LessThan(UInt32, Unity.Mathematics.uint3x2) declare in Unity.Mathematics.uint3x2
bool w_S_S_bbb_S_bbb__u4S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbb_S_bbb__u4S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_bbb_S_bbb__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_bbb_S_bbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 transpose(Unity.Mathematics.bool4x4) declare in Unity.Mathematics.math
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_Equality(Unity.Mathematics.bool4x4, Unity.Mathematics.bool4x4) declare in Unity.Mathematics.bool4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ {};
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__* pp1 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv1);
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p1 = pp1 ? *pp1 : S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0, struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_Equality(Unity.Mathematics.bool4x4, Boolean) declare in Unity.Mathematics.bool4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0, bool p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_LessThan(Unity.Mathematics.int4x4, Unity.Mathematics.int4x4) declare in Unity.Mathematics.int4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_LessThan(Unity.Mathematics.int4x4, Int32) declare in Unity.Mathematics.int4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, int32_t p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_LessThan(Unity.Mathematics.float4x4, Unity.Mathematics.float4x4) declare in Unity.Mathematics.float4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_LessThan(Unity.Mathematics.float4x4, Single) declare in Unity.Mathematics.float4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, float p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_LessThan(Unity.Mathematics.double4x4, Unity.Mathematics.double4x4) declare in Unity.Mathematics.double4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_LessThan(Unity.Mathematics.double4x4, Double) declare in Unity.Mathematics.double4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, double p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_LessThan(Unity.Mathematics.uint4x4, Unity.Mathematics.uint4x4) declare in Unity.Mathematics.uint4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_LessThan(Unity.Mathematics.uint4x4, UInt32) declare in Unity.Mathematics.uint4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 bool4x4(Unity.Mathematics.bool4, Unity.Mathematics.bool4, Unity.Mathematics.bool4, Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_bbbb_S_bbbb_S_bbbb_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__S_bbbb_S_bbbb_S_bbbb_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp1 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv1);
    S_bbbb_ p1 = pp1 ? *pp1 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp2 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv2);
    S_bbbb_ p2 = pp2 ? *pp2 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp3 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv3);
    S_bbbb_ p3 = pp3 ? *pp3 : S_bbbb_ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_bbbb_ p0, struct S_bbbb_ p1, struct S_bbbb_ p2, struct S_bbbb_ p3, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 bool4x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_Equality(Boolean, Unity.Mathematics.bool4x4) declare in Unity.Mathematics.bool4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__bS_S_bbbb_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__bS_S_bbbb_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__* pp1 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv1);
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p1 = pp1 ? *pp1 : S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(bool p0, struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 bool4x4(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__bbbbbbbbbbbbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__bbbbbbbbbbbbbbbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);

    if (checkJSArgument) {
        if (js_args_len != 16) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv11)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv12)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv13)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv14)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv15)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    bool p10 = converter::Converter<bool>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    bool p11 = converter::Converter<bool>::toCpp(apis, env, _sv11);
    // JSValToCSVal P any
    bool p12 = converter::Converter<bool>::toCpp(apis, env, _sv12);
    // JSValToCSVal P any
    bool p13 = converter::Converter<bool>::toCpp(apis, env, _sv13);
    // JSValToCSVal P any
    bool p14 = converter::Converter<bool>::toCpp(apis, env, _sv14);
    // JSValToCSVal P any
    bool p15 = converter::Converter<bool>::toCpp(apis, env, _sv15);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_LessThan(Int32, Unity.Mathematics.int4x4) declare in Unity.Mathematics.int4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__i4S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__i4S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(int32_t p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_LessThan(Single, Unity.Mathematics.float4x4) declare in Unity.Mathematics.float4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__r4S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__r4S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(float p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_LessThan(Double, Unity.Mathematics.double4x4) declare in Unity.Mathematics.double4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__r8S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__r8S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(double p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x4 op_LessThan(UInt32, Unity.Mathematics.uint4x4) declare in Unity.Mathematics.uint4x4
bool w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__u4S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__u4S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 transpose(Unity.Mathematics.bool3x4) declare in Unity.Mathematics.math
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_S_bbb_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_S_bbb_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LogicalNot(Unity.Mathematics.bool4x3) declare in Unity.Mathematics.bool4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_Equality(Unity.Mathematics.bool4x3, Unity.Mathematics.bool4x3) declare in Unity.Mathematics.bool4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb__ {};
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp1 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv1);
    S_S_bbbb_S_bbbb_S_bbbb__ p1 = pp1 ? *pp1 : S_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb__ p0, struct S_S_bbbb_S_bbbb_S_bbbb__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_Equality(Unity.Mathematics.bool4x3, Boolean) declare in Unity.Mathematics.bool4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb_S_bbbb__b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb__ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb__ p0, bool p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LessThan(Unity.Mathematics.int4x3, Unity.Mathematics.int4x3) declare in Unity.Mathematics.int4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LessThan(Unity.Mathematics.int4x3, Int32) declare in Unity.Mathematics.int4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, int32_t p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LessThan(Unity.Mathematics.float4x3, Unity.Mathematics.float4x3) declare in Unity.Mathematics.float4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LessThan(Unity.Mathematics.float4x3, Single) declare in Unity.Mathematics.float4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, float p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LessThan(Unity.Mathematics.double4x3, Unity.Mathematics.double4x3) declare in Unity.Mathematics.double4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LessThan(Unity.Mathematics.double4x3, Double) declare in Unity.Mathematics.double4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, double p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LessThan(Unity.Mathematics.uint4x3, Unity.Mathematics.uint4x3) declare in Unity.Mathematics.uint4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LessThan(Unity.Mathematics.uint4x3, UInt32) declare in Unity.Mathematics.uint4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 bool4x3(Unity.Mathematics.bool4, Unity.Mathematics.bool4, Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_S_S_bbbb_S_bbbb_S_bbbb__S_bbbb_S_bbbb_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__S_bbbb_S_bbbb_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp1 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv1);
    S_bbbb_ p1 = pp1 ? *pp1 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp2 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv2);
    S_bbbb_ p2 = pp2 ? *pp2 : S_bbbb_ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_bbbb_ p0, struct S_bbbb_ p1, struct S_bbbb_ p2, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 bool4x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_bbbb_S_bbbb_S_bbbb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_Equality(Boolean, Unity.Mathematics.bool4x3) declare in Unity.Mathematics.bool4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__bS_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__bS_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp1 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv1);
    S_S_bbbb_S_bbbb_S_bbbb__ p1 = pp1 ? *pp1 : S_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(bool p0, struct S_S_bbbb_S_bbbb_S_bbbb__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 bool4x3(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_S_bbbb_S_bbbb_S_bbbb__bbbbbbbbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__bbbbbbbbbbbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    bool p10 = converter::Converter<bool>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    bool p11 = converter::Converter<bool>::toCpp(apis, env, _sv11);

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LessThan(Int32, Unity.Mathematics.int4x3) declare in Unity.Mathematics.int4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__i4S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__i4S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(int32_t p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LessThan(Single, Unity.Mathematics.float4x3) declare in Unity.Mathematics.float4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__r4S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__r4S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(float p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LessThan(Double, Unity.Mathematics.double4x3) declare in Unity.Mathematics.double4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__r8S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__r8S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(double p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x3 op_LessThan(UInt32, Unity.Mathematics.uint4x3) declare in Unity.Mathematics.uint4x3
bool w_S_S_bbbb_S_bbbb_S_bbbb__u4S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb_S_bbbb__u4S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_bbbb_S_bbbb_S_bbbb__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 transpose(Unity.Mathematics.bool2x4) declare in Unity.Mathematics.math
bool w_S_S_bbbb_S_bbbb__S_S_bb_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_S_bb_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LogicalNot(Unity.Mathematics.bool4x2) declare in Unity.Mathematics.bool4x2
bool w_S_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb__ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_Equality(Unity.Mathematics.bool4x2, Unity.Mathematics.bool4x2) declare in Unity.Mathematics.bool4x2
bool w_S_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb__ {};
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp1 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv1);
    S_S_bbbb_S_bbbb__ p1 = pp1 ? *pp1 : S_S_bbbb_S_bbbb__ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_bbbb_S_bbbb__ p0, struct S_S_bbbb_S_bbbb__ p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_Equality(Unity.Mathematics.bool4x2, Boolean) declare in Unity.Mathematics.bool4x2
bool w_S_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_S_bbbb_S_bbbb__b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb__ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_bbbb_S_bbbb__ p0, bool p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LessThan(Unity.Mathematics.int4x2, Unity.Mathematics.int4x2) declare in Unity.Mathematics.int4x2
bool w_S_S_bbbb_S_bbbb__S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LessThan(Unity.Mathematics.int4x2, Int32) declare in Unity.Mathematics.int4x2
bool w_S_S_bbbb_S_bbbb__S_S_i4i4i4i4_S_i4i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_S_i4i4i4i4_S_i4i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, int32_t p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LessThan(Unity.Mathematics.float4x2, Unity.Mathematics.float4x2) declare in Unity.Mathematics.float4x2
bool w_S_S_bbbb_S_bbbb__S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LessThan(Unity.Mathematics.float4x2, Single) declare in Unity.Mathematics.float4x2
bool w_S_S_bbbb_S_bbbb__S_S_r4r4r4r4_S_r4r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_S_r4r4r4r4_S_r4r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, float p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LessThan(Unity.Mathematics.double4x2, Unity.Mathematics.double4x2) declare in Unity.Mathematics.double4x2
bool w_S_S_bbbb_S_bbbb__S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LessThan(Unity.Mathematics.double4x2, Double) declare in Unity.Mathematics.double4x2
bool w_S_S_bbbb_S_bbbb__S_S_r8r8r8r8_S_r8r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_S_r8r8r8r8_S_r8r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, double p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LessThan(Unity.Mathematics.uint4x2, Unity.Mathematics.uint4x2) declare in Unity.Mathematics.uint4x2
bool w_S_S_bbbb_S_bbbb__S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LessThan(Unity.Mathematics.uint4x2, UInt32) declare in Unity.Mathematics.uint4x2
bool w_S_S_bbbb_S_bbbb__S_S_u4u4u4u4_S_u4u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_S_u4u4u4u4_S_u4u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 bool4x2(Unity.Mathematics.bool4, Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_S_S_bbbb_S_bbbb__S_bbbb_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__S_bbbb_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp1 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv1);
    S_bbbb_ p1 = pp1 ? *pp1 : S_bbbb_ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(struct S_bbbb_ p0, struct S_bbbb_ p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 bool4x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_bbbb_S_bbbb__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_Equality(Boolean, Unity.Mathematics.bool4x2) declare in Unity.Mathematics.bool4x2
bool w_S_S_bbbb_S_bbbb__bS_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__bS_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp1 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv1);
    S_S_bbbb_S_bbbb__ p1 = pp1 ? *pp1 : S_S_bbbb_S_bbbb__ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(bool p0, struct S_S_bbbb_S_bbbb__ p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 bool4x2(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_S_bbbb_S_bbbb__bbbbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__bbbbbbbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LessThan(Int32, Unity.Mathematics.int4x2) declare in Unity.Mathematics.int4x2
bool w_S_S_bbbb_S_bbbb__i4S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__i4S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(int32_t p0, struct S_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LessThan(Single, Unity.Mathematics.float4x2) declare in Unity.Mathematics.float4x2
bool w_S_S_bbbb_S_bbbb__r4S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__r4S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(float p0, struct S_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LessThan(Double, Unity.Mathematics.double4x2) declare in Unity.Mathematics.double4x2
bool w_S_S_bbbb_S_bbbb__r8S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__r8S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(double p0, struct S_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4x2 op_LessThan(UInt32, Unity.Mathematics.uint4x2) declare in Unity.Mathematics.uint4x2
bool w_S_S_bbbb_S_bbbb__u4S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_bbbb_S_bbbb__u4S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_bbbb_S_bbbb__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_bbbb_S_bbbb__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleBackgroundSize op_Implicit(UnityEngine.UIElements.BackgroundSize) declare in UnityEngine.UIElements.StyleBackgroundSize
bool w_S_S_i4S_r4i4_S_r4i4__i4_S_i4S_r4i4_S_r4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4S_r4i4_S_r4i4__i4_S_i4S_r4i4_S_r4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_r4i4_S_r4i4__* pp0 = DataTransfer::GetPointer<S_i4S_r4i4_S_r4i4__>(apis, env, _sv0);
    S_i4S_r4i4_S_r4i4__ p0 = pp0 ? *pp0 : S_i4S_r4i4_S_r4i4__ {};

    typedef struct S_S_i4S_r4i4_S_r4i4__i4_ (*FuncToCall)(struct S_i4S_r4i4_S_r4i4__ p0, const void* method);
    struct S_S_i4S_r4i4_S_r4i4__i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleBackgroundSize op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleBackgroundSize
bool w_S_S_i4S_r4i4_S_r4i4__i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4S_r4i4_S_r4i4__i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4S_r4i4_S_r4i4__i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4S_r4i4_S_r4i4__i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleBackgroundPosition op_Implicit(UnityEngine.UIElements.BackgroundPosition) declare in UnityEngine.UIElements.StyleBackgroundPosition
bool w_S_S_i4S_r4i4__i4_S_i4S_r4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4S_r4i4__i4_S_i4S_r4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_r4i4__* pp0 = DataTransfer::GetPointer<S_i4S_r4i4__>(apis, env, _sv0);
    S_i4S_r4i4__ p0 = pp0 ? *pp0 : S_i4S_r4i4__ {};

    typedef struct S_S_i4S_r4i4__i4_ (*FuncToCall)(struct S_i4S_r4i4__ p0, const void* method);
    struct S_S_i4S_r4i4__i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleBackgroundPosition op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleBackgroundPosition
bool w_S_S_i4S_r4i4__i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4S_r4i4__i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4S_r4i4__i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4S_r4i4__i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Range get_All() declare in System.Range
bool w_S_S_i4_S_i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4_S_i4__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_i4_S_i4__ (*FuncToCall)(const void* method);
    struct S_S_i4_S_i4__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Range StartAt(System.Index) declare in System.Range
bool w_S_S_i4_S_i4__S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4_S_i4__S_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};

    typedef struct S_S_i4_S_i4__ (*FuncToCall)(struct S_i4_ p0, const void* method);
    struct S_S_i4_S_i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RTHandleProperties get_rtHandleProperties() declare in UnityEngine.Rendering.RTHandles
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4_S_r4r4r4r4__ (*FuncToCall)(const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RTHandleProperties get_rtHandleProperties() declare in UnityEngine.Rendering.BufferedRTHandleSystem
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4_S_r4r4r4r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4_S_r4r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4_S_r4r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 int2x4(Unity.Mathematics.bool2x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_bb_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_bb_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 op_Increment(Unity.Mathematics.int2x4) declare in Unity.Mathematics.int2x4
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 op_Multiply(Unity.Mathematics.int2x4, Unity.Mathematics.int2x4) declare in Unity.Mathematics.int2x4
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 mul(Unity.Mathematics.int2x4, Unity.Mathematics.int4x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 op_Multiply(Unity.Mathematics.int2x4, Int32) declare in Unity.Mathematics.int2x4
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, int32_t p1, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 mul(Unity.Mathematics.int2x3, Unity.Mathematics.int3x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 mul(Unity.Mathematics.int2x2, Unity.Mathematics.int2x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 transpose(Unity.Mathematics.int4x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 int2x4(Unity.Mathematics.float2x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 int2x4(Unity.Mathematics.double2x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 int2x4(Unity.Mathematics.uint2x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 int2x4(Unity.Mathematics.int2, Unity.Mathematics.int2, Unity.Mathematics.int2, Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_i4i4_S_i4i4_S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_i4i4_S_i4i4_S_i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv3);
    S_i4i4_ p3 = pp3 ? *pp3 : S_i4i4_ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, struct S_i4i4_ p2, struct S_i4i4_ p3, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 int2x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 int2x4(Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 op_Multiply(Int32, Unity.Mathematics.int2x4) declare in Unity.Mathematics.int2x4
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__i4S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__i4S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(int32_t p0, struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 int2x4(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__i4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__i4i4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 int2x4(Single) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 int2x4(Double) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x4 int2x4(UInt32) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 int2x3(Unity.Mathematics.bool2x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__S_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__S_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 mul(Unity.Mathematics.int2x4, Unity.Mathematics.int4x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 op_Increment(Unity.Mathematics.int2x3) declare in Unity.Mathematics.int2x3
bool w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 op_Multiply(Unity.Mathematics.int2x3, Unity.Mathematics.int2x3) declare in Unity.Mathematics.int2x3
bool w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, struct S_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 mul(Unity.Mathematics.int2x3, Unity.Mathematics.int3x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 op_Multiply(Unity.Mathematics.int2x3, Int32) declare in Unity.Mathematics.int2x3
bool w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, int32_t p1, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 mul(Unity.Mathematics.int2x2, Unity.Mathematics.int2x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, struct S_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 transpose(Unity.Mathematics.int3x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 int2x3(Unity.Mathematics.float2x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 int2x3(Unity.Mathematics.double2x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 int2x3(Unity.Mathematics.uint2x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 int2x3(Unity.Mathematics.int2, Unity.Mathematics.int2, Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__S_i4i4_S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__S_i4i4_S_i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, struct S_i4i4_ p2, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 int2x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 int2x3(Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 op_Multiply(Int32, Unity.Mathematics.int2x3) declare in Unity.Mathematics.int2x3
bool w_S_S_i4i4_S_i4i4_S_i4i4__i4S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__i4S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(int32_t p0, struct S_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 int2x3(Int32, Int32, Int32, Int32, Int32, Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 int2x3(Single) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 int2x3(Double) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// PositionEnumerator get_allPositionsWithin() declare in UnityEngine.RectInt
bool w_S_S_i4i4_S_i4i4_S_i4i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x3 int2x3(UInt32) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4_S_i4i4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 int2x2(Unity.Mathematics.bool2x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__S_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__S_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb__ {};

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_bb_S_bb__ p0, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 mul(Unity.Mathematics.int2x4, Unity.Mathematics.int4x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 mul(Unity.Mathematics.int2x3, Unity.Mathematics.int3x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4_S_i4i4__S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 transpose(Unity.Mathematics.int2x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 mul(Unity.Mathematics.int2x2, Unity.Mathematics.int2x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, struct S_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 op_Multiply(Unity.Mathematics.int2x2, Int32) declare in Unity.Mathematics.int2x2
bool w_S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__S_S_i4i4_S_i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, int32_t p1, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 int2x2(Unity.Mathematics.float2x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__S_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 int2x2(Unity.Mathematics.double2x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__S_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 int2x2(Unity.Mathematics.uint2x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__S_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 int2x2(Unity.Mathematics.int2, Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__S_i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 int2x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 int2x2(Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 op_Multiply(Int32, Unity.Mathematics.int2x2) declare in Unity.Mathematics.int2x2
bool w_S_S_i4i4_S_i4i4__i4S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__i4S_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(int32_t p0, struct S_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 int2x2(Int32, Int32, Int32, Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 int2x2(Single) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 int2x2(Double) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2x2 int2x2(UInt32) declare in Unity.Mathematics.math
bool w_S_S_i4i4_S_i4i4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_S_i4i4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleBackgroundRepeat op_Implicit(UnityEngine.UIElements.BackgroundRepeat) declare in UnityEngine.UIElements.StyleBackgroundRepeat
bool w_S_S_i4i4_i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef struct S_S_i4i4_i4_ (*FuncToCall)(struct S_i4i4_ p0, const void* method);
    struct S_S_i4i4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleBackgroundRepeat op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleBackgroundRepeat
bool w_S_S_i4i4_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4_i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4i4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.FilteringSettings get_defaultValue() declare in UnityEngine.Rendering.FilteringSettings
bool w_S_S_i4i4_i4u4i4S_i2i2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_i4u4i4S_i2i2__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_i4i4_i4u4i4S_i2i2__ (*FuncToCall)(const void* method);
    struct S_S_i4i4_i4u4i4S_i2i2__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 int3x4(Unity.Mathematics.bool3x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_bbb_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_bbb_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 op_Increment(Unity.Mathematics.int3x4) declare in Unity.Mathematics.int3x4
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 op_Multiply(Unity.Mathematics.int3x4, Unity.Mathematics.int3x4) declare in Unity.Mathematics.int3x4
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 mul(Unity.Mathematics.int3x4, Unity.Mathematics.int4x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 op_Multiply(Unity.Mathematics.int3x4, Int32) declare in Unity.Mathematics.int3x4
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, int32_t p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 mul(Unity.Mathematics.int3x3, Unity.Mathematics.int3x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 mul(Unity.Mathematics.int3x2, Unity.Mathematics.int2x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 transpose(Unity.Mathematics.int4x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 int3x4(Unity.Mathematics.float3x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 int3x4(Unity.Mathematics.double3x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 int3x4(Unity.Mathematics.uint3x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 int3x4(Unity.Mathematics.int3, Unity.Mathematics.int3, Unity.Mathematics.int3, Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv3);
    S_i4i4i4_ p3 = pp3 ? *pp3 : S_i4i4i4_ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, struct S_i4i4i4_ p2, struct S_i4i4i4_ p3, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 int3x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 int3x4(Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 op_Multiply(Int32, Unity.Mathematics.int3x4) declare in Unity.Mathematics.int3x4
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(int32_t p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 int3x4(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4i4i4i4i4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4i4i4i4i4i4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, int32_t p10, int32_t p11, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 int3x4(Single) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 int3x4(Double) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x4 int3x4(UInt32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 int3x3(Unity.Mathematics.bool3x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 mul(Unity.Mathematics.int3x4, Unity.Mathematics.int4x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 transpose(Unity.Mathematics.int3x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 mul(Unity.Mathematics.int3x3, Unity.Mathematics.int3x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 op_Multiply(Unity.Mathematics.int3x3, Int32) declare in Unity.Mathematics.int3x3
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, int32_t p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 mul(Unity.Mathematics.int3x2, Unity.Mathematics.int2x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 int3x3(Unity.Mathematics.float3x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 int3x3(Unity.Mathematics.double3x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 int3x3(Unity.Mathematics.uint3x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 int3x3(Unity.Mathematics.int3, Unity.Mathematics.int3, Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_i4i4i4_S_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_i4i4i4_S_i4i4i4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, struct S_i4i4i4_ p2, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 int3x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 int3x3(Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 op_Multiply(Int32, Unity.Mathematics.int3x3) declare in Unity.Mathematics.int3x3
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(int32_t p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 int3x3(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4i4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__i4i4i4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 int3x3(Single) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 int3x3(Double) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// PositionEnumerator get_allPositionsWithin() declare in UnityEngine.BoundsInt
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x3 int3x3(UInt32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 int3x2(Unity.Mathematics.bool3x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__S_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 transpose(Unity.Mathematics.int2x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 mul(Unity.Mathematics.int3x4, Unity.Mathematics.int4x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 mul(Unity.Mathematics.int3x3, Unity.Mathematics.int3x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 op_Increment(Unity.Mathematics.int3x2) declare in Unity.Mathematics.int3x2
bool w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 mul(Unity.Mathematics.int3x2, Unity.Mathematics.int2x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__S_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 op_Multiply(Unity.Mathematics.int3x2, Unity.Mathematics.int3x2) declare in Unity.Mathematics.int3x2
bool w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.BoundsInt BoundsIntField(UnityEngine.BoundsInt, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, Il2CppArray* p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 op_Multiply(Unity.Mathematics.int3x2, Int32) declare in Unity.Mathematics.int3x2
bool w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, int32_t p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 int3x2(Unity.Mathematics.float3x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 int3x2(Unity.Mathematics.double3x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 int3x2(Unity.Mathematics.uint3x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 int3x2(Unity.Mathematics.int3, Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__S_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_i4i4i4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.BoundsInt BoundsIntField(UnityEngine.Rect, UnityEngine.BoundsInt) declare in UnityEditor.EditorGUI
bool w_S_S_i4i4i4_S_i4i4i4__S_r4r4r4r4_S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_r4r4r4r4_S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.BoundsInt BoundsIntField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.BoundsInt) declare in UnityEditor.EditorGUI
bool w_S_S_i4i4i4_S_i4i4i4__S_r4r4r4r4_oS_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_r4r4r4r4_oS_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp2 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv2);
    S_S_i4i4i4_S_i4i4i4__ p2 = pp2 ? *pp2 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, struct S_S_i4i4i4_S_i4i4i4__ p2, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.BoundsInt BoundsIntField(UnityEngine.Rect, System.String, UnityEngine.BoundsInt) declare in UnityEditor.EditorGUI
bool w_S_S_i4i4i4_S_i4i4i4__S_r4r4r4r4_sS_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_r4r4r4r4_sS_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp2 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv2);
    S_S_i4i4i4_S_i4i4i4__ p2 = pp2 ? *pp2 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, struct S_S_i4i4i4_S_i4i4i4__ p2, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 int3x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 int3x2(Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 op_Multiply(Int32, Unity.Mathematics.int3x2) declare in Unity.Mathematics.int3x2
bool w_S_S_i4i4i4_S_i4i4i4__i4S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__i4S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(int32_t p0, struct S_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 int3x2(Int32, Int32, Int32, Int32, Int32, Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.BoundsInt BoundsIntField(UnityEngine.GUIContent, UnityEngine.BoundsInt, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_S_i4i4i4_S_i4i4i4__oS_S_i4i4i4_S_i4i4i4__Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__oS_S_i4i4i4_S_i4i4i4__Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(Il2CppObject* p0, struct S_S_i4i4i4_S_i4i4i4__ p1, Il2CppArray* p2, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 int3x2(Single) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 int3x2(Double) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.BoundsInt BoundsIntField(System.String, UnityEngine.BoundsInt, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_S_i4i4i4_S_i4i4i4__sS_S_i4i4i4_S_i4i4i4__Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__sS_S_i4i4i4_S_i4i4i4__Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(Il2CppString* p0, struct S_S_i4i4i4_S_i4i4i4__ p1, Il2CppArray* p2, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.BoundsInt get_cellBounds() declare in UnityEngine.Tilemaps.ITilemap
bool w_S_S_i4i4i4_S_i4i4i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3x2 int3x2(UInt32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4_S_i4i4i4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 int4x4(Unity.Mathematics.bool4x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 transpose(Unity.Mathematics.int4x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 mul(Unity.Mathematics.int4x4, Unity.Mathematics.int4x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 op_Multiply(Unity.Mathematics.int4x4, Int32) declare in Unity.Mathematics.int4x4
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, int32_t p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 mul(Unity.Mathematics.int4x3, Unity.Mathematics.int3x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 mul(Unity.Mathematics.int4x2, Unity.Mathematics.int2x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 int4x4(Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 int4x4(Unity.Mathematics.double4x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 int4x4(Unity.Mathematics.uint4x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 int4x4(Unity.Mathematics.int4, Unity.Mathematics.int4, Unity.Mathematics.int4, Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv2);
    S_i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv3);
    S_i4i4i4i4_ p3 = pp3 ? *pp3 : S_i4i4i4i4_ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, struct S_i4i4i4i4_ p2, struct S_i4i4i4i4_ p3, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 int4x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 int4x4(Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 op_Multiply(Int32, Unity.Mathematics.int4x4) declare in Unity.Mathematics.int4x4
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(int32_t p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 int4x4(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);

    if (checkJSArgument) {
        if (js_args_len != 16) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv12)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv13)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv14)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv15)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);
    // JSValToCSVal P any
    int32_t p12 = converter::Converter<int32_t>::toCpp(apis, env, _sv12);
    // JSValToCSVal P any
    int32_t p13 = converter::Converter<int32_t>::toCpp(apis, env, _sv13);
    // JSValToCSVal P any
    int32_t p14 = converter::Converter<int32_t>::toCpp(apis, env, _sv14);
    // JSValToCSVal P any
    int32_t p15 = converter::Converter<int32_t>::toCpp(apis, env, _sv15);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, int32_t p10, int32_t p11, int32_t p12, int32_t p13, int32_t p14, int32_t p15, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 int4x4(Single) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 int4x4(Double) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x4 int4x4(UInt32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 int4x3(Unity.Mathematics.bool4x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 transpose(Unity.Mathematics.int3x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 mul(Unity.Mathematics.int4x4, Unity.Mathematics.int4x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 op_Increment(Unity.Mathematics.int4x3) declare in Unity.Mathematics.int4x3
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 mul(Unity.Mathematics.int4x3, Unity.Mathematics.int3x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 op_Multiply(Unity.Mathematics.int4x3, Unity.Mathematics.int4x3) declare in Unity.Mathematics.int4x3
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 op_Multiply(Unity.Mathematics.int4x3, Int32) declare in Unity.Mathematics.int4x3
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, int32_t p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 mul(Unity.Mathematics.int4x2, Unity.Mathematics.int2x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 int4x3(Unity.Mathematics.float4x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 int4x3(Unity.Mathematics.double4x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 int4x3(Unity.Mathematics.uint4x3) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 int4x3(Unity.Mathematics.int4, Unity.Mathematics.int4, Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv2);
    S_i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4_ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, struct S_i4i4i4i4_ p2, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 int4x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 int4x3(Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 op_Multiply(Int32, Unity.Mathematics.int4x3) declare in Unity.Mathematics.int4x3
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(int32_t p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 int4x3(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4i4i4i4i4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__i4i4i4i4i4i4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, int32_t p10, int32_t p11, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 int4x3(Single) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 int4x3(Double) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x3 int4x3(UInt32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 int4x2(Unity.Mathematics.bool4x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 transpose(Unity.Mathematics.int2x4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 mul(Unity.Mathematics.int4x4, Unity.Mathematics.int4x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 mul(Unity.Mathematics.int4x3, Unity.Mathematics.int3x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 op_Increment(Unity.Mathematics.int4x2) declare in Unity.Mathematics.int4x2
bool w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 mul(Unity.Mathematics.int4x2, Unity.Mathematics.int2x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 op_Multiply(Unity.Mathematics.int4x2, Unity.Mathematics.int4x2) declare in Unity.Mathematics.int4x2
bool w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 op_Multiply(Unity.Mathematics.int4x2, Int32) declare in Unity.Mathematics.int4x2
bool w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_i4i4i4i4_S_i4i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, int32_t p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 int4x2(Unity.Mathematics.float4x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 int4x2(Unity.Mathematics.double4x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 int4x2(Unity.Mathematics.uint4x2) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 int4x2(Unity.Mathematics.int4, Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__S_i4i4i4i4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__S_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 int4x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 int4x2(Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 op_Multiply(Int32, Unity.Mathematics.int4x2) declare in Unity.Mathematics.int4x2
bool w_S_S_i4i4i4i4_S_i4i4i4i4__i4S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__i4S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(int32_t p0, struct S_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 int4x2(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__i4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__i4i4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 int4x2(Single) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 int4x2(Double) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4x2 int4x2(UInt32) declare in Unity.Mathematics.math
bool w_S_S_i4i4i4i4_S_i4i4i4i4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4i4_S_i4i4i4i4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4i4i4i4_S_i4i4i4i4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_i4i4i4i4_S_i4i4i4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath FromKey(System.Object) declare in Unity.Properties.PropertyPath
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_O");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath Pop(Unity.Properties.PropertyPath ByRef) declare in Unity.Properties.PropertyPath
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_));
        p0 = &up0;
    }
        

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath AppendKey(Unity.Properties.PropertyPath ByRef, System.Object) declare in Unity.Properties.PropertyPath
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_O");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0, Il2CppObject* p1, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath Combine(Unity.Properties.PropertyPath ByRef, Unity.Properties.PropertyPath ByRef) declare in Unity.Properties.PropertyPath
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p1 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_));
        p1 = &up1;
    }
        

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0, struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p1, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath AppendPart(Unity.Properties.PropertyPath ByRef, Unity.Properties.PropertyPathPart ByRef) declare in Unity.Properties.PropertyPath
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_i4si4O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_i4si4O_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_i4si4O_* p1 = DataTransfer::GetPointer<S_i4si4O_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4si4O_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4si4O_));
        p1 = &up1;
    }
        

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0, struct S_i4si4O_* p1, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath AppendIndex(Unity.Properties.PropertyPath ByRef, Int32) declare in Unity.Properties.PropertyPath
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0, int32_t p1, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath SubPath(Unity.Properties.PropertyPath ByRef, Int32, Int32) declare in Unity.Properties.PropertyPath
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0, int32_t p1, int32_t p2, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath AppendProperty(Unity.Properties.PropertyPath ByRef, Unity.Properties.IProperty) declare in Unity.Properties.PropertyPath
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0, Il2CppObject* p1, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath Combine(Unity.Properties.PropertyPath ByRef, System.String) declare in Unity.Properties.PropertyPath
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_));
        p0 = &up0;
    }
        
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p0, Il2CppString* p1, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath FromPart(Unity.Properties.PropertyPathPart ByRef) declare in Unity.Properties.PropertyPath
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_i4si4O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_i4si4O_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4si4O_* p0 = DataTransfer::GetPointer<S_i4si4O_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4si4O_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4si4O_));
        p0 = &up0;
    }
        

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(struct S_i4si4O_* p0, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath FromIndex(Int32) declare in Unity.Properties.PropertyPath
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath FromName(System.String) declare in Unity.Properties.PropertyPath
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPath get_Path() declare in Unity.Properties.PathVisitor
bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(void*,const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Awaiter GetAwaiter(UnityEngine.Rendering.AsyncGPUReadbackRequest) declare in Cysharp.Threading.Tasks.UnityAsyncExtensions
bool w_S_S_oS_pi4_i2__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oS_pi4_i2__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_oS_pi4_i2__ (*FuncToCall)(void*,const void* method);
    struct S_S_oS_pi4_i2__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleCursor op_Implicit(UnityEngine.UIElements.Cursor) declare in UnityEngine.UIElements.StyleCursor
bool w_S_S_oS_r4r4_i4_i4_S_oS_r4r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oS_r4r4_i4_i4_S_oS_r4r4_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oS_r4r4_i4_* pp0 = DataTransfer::GetPointer<S_oS_r4r4_i4_>(apis, env, _sv0);
    S_oS_r4r4_i4_ p0 = pp0 ? *pp0 : S_oS_r4r4_i4_ {};

    typedef struct S_S_oS_r4r4_i4_i4_ (*FuncToCall)(struct S_oS_r4r4_i4_ p0, const void* method);
    struct S_S_oS_r4r4_i4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleCursor op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleCursor
bool w_S_S_oS_r4r4_i4_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oS_r4r4_i4_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_oS_r4r4_i4_i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_oS_r4r4_i4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Lifetimes.OuterLifetime op_Implicit(JetBrains.Lifetimes.Lifetime) declare in JetBrains.Lifetimes.OuterLifetime
bool w_S_S_o__S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_o__S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_S_o__ (*FuncToCall)(struct S_o_ p0, const void* method);
    struct S_S_o__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Lifetimes.OuterLifetime op_Implicit(JetBrains.Lifetimes.LifetimeDefinition) declare in JetBrains.Lifetimes.OuterLifetime
bool w_S_S_o__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_o__o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_S_o__ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_S_o__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.CancellationTokenAwaitable WaitUntilCanceled(System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.CancellationTokenExtensions
bool w_S_S_o__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_o__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_o__ (*FuncToCall)(void*,const void* method);
    struct S_S_o__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(Boolean) declare in System.Threading.Tasks.Task
bool w_S_S_ob__tb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_ob__tb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_ob__ (*FuncToCall)(void*,bool p0, const void* method);
    struct S_S_ob__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ValueTuple`2[Cysharp.Threading.Tasks.UniTask,System.Threading.CancellationTokenRegistration] ToUniTask(System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.CancellationTokenExtensions
bool w_S_S_oi2_S_oS_oi4___t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oi2_S_oS_oi4___t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_oi2_S_oS_oi4___ (*FuncToCall)(void*,const void* method);
    struct S_S_oi2_S_oS_oi4___ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Awaiter GetAwaiter() declare in Cysharp.Threading.Tasks.AsyncLazy
bool w_S_S_oi2__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oi2__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_oi2__ (*FuncToCall)(void*,const void* method);
    struct S_S_oi2__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// ArrayEnumerator EnumerateArray() declare in System.Text.Json.JsonElement
bool w_S_S_oi4_i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oi4_i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_oi4_i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_oi4_i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Enumerator GetEnumerator() declare in UnityEngine.UIElements.StylePropertyNameCollection
bool w_S_S_oi4i4S_i4s___t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oi4i4S_i4s___t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_oi4i4S_i4s___ (*FuncToCall)(void*,const void* method);
    struct S_S_oi4i4S_i4s___ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Enumerator GetEnumerator() declare in System.Diagnostics.ActivityTagsCollection
bool w_S_S_oi4i4S_sO___t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oi4i4S_sO___t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_oi4i4S_sO___ (*FuncToCall)(void*,const void* method);
    struct S_S_oi4i4S_sO___ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Security.Cryptography.ECParameters ExportParameters() declare in System.Security.Cryptography.ECDiffieHellmanPublicKey
bool w_S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ (*FuncToCall)(void*,const void* method);
    struct S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Security.Cryptography.ECParameters ExportParameters(Boolean) declare in System.Security.Cryptography.ECDiffieHellman
bool w_S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__tb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__tb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ (*FuncToCall)(void*,bool p0, const void* method);
    struct S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleBackground op_Implicit(UnityEngine.UIElements.Background) declare in UnityEngine.UIElements.StyleBackground
bool w_S_S_oooo_i4_S_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oooo_i4_S_oooo_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oooo_* pp0 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv0);
    S_oooo_ p0 = pp0 ? *pp0 : S_oooo_ {};

    typedef struct S_S_oooo_i4_ (*FuncToCall)(struct S_oooo_ p0, const void* method);
    struct S_S_oooo_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleBackground op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleBackground
bool w_S_S_oooo_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oooo_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_oooo_i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_oooo_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleBackground op_Implicit(UnityEngine.Texture2D) declare in UnityEngine.UIElements.StyleBackground
bool w_S_S_oooo_i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oooo_i4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_S_oooo_i4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_S_oooo_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.SearchExpressionContext get_current() declare in UnityEditor.Search.SearchExpressionRuntime
bool w_S_S_oooo_ooi4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oooo_ooi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_oooo_ooi4_ (*FuncToCall)(void*,const void* method);
    struct S_S_oooo_ooi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RendererListParams ConvertToParameters(UnityEngine.Rendering.RendererUtils.RendererListDesc ByRef) declare in UnityEngine.Rendering.RendererUtils.RendererListDesc
bool w_S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___PS_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___PS_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_* p0 = DataTransfer::GetPointer<S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_));
        p0 = &up0;
    }
        

    typedef struct S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ (*FuncToCall)(struct S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_* p0, const void* method);
    struct S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.ScopedSubPass BeginScopedSubPass(Unity.Collections.NativeArray`1[System.Int32], Boolean) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_S_pS_pi4i4___ (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, bool p1, const void* method);
    struct S_S_pS_pi4i4___ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.ScopedSubPass BeginScopedSubPass(Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[System.Int32], Boolean) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_S_pS_pi4i4___ (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, bool p2, const void* method);
    struct S_S_pS_pi4i4___ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.ScopedSubPass BeginScopedSubPass(Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[System.Int32], Boolean, Boolean) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_bb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef struct S_S_pS_pi4i4___ (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, bool p2, bool p3, const void* method);
    struct S_S_pS_pi4i4___ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.ScopedSubPass BeginScopedSubPass(Unity.Collections.NativeArray`1[System.Int32], Boolean, Boolean) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_bb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_S_pS_pi4i4___ (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, bool p1, bool p2, const void* method);
    struct S_S_pS_pi4i4___ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.ScopedRenderPass BeginScopedRenderPass(Int32, Int32, Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.AttachmentDescriptor], Int32) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_S_S_pS_pi4i4___ti4i4i4S_Pvi4i4i4S_pi4i4_i4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pS_pi4i4___ti4i4i4S_Pvi4i4i4S_pi4i4_i4_Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv3);
    S_Pvi4i4i4S_pi4i4_i4_ p3 = pp3 ? *pp3 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef struct S_S_pS_pi4i4___ (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, int32_t p4, const void* method);
    struct S_S_pS_pi4i4___ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlySpan`1[UnityEngine.Vector4] GetCustomBakeResultsNoCopy() declare in UnityEditor.Experimental.Lightmapping
bool w_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_p_i4_ (*FuncToCall)(const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlySpan`1[System.Char] GetDirectoryName(System.ReadOnlySpan`1[System.Char]) declare in System.IO.Path
bool w_S_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef struct S_S_p_i4_ (*FuncToCall)(struct S_S_p_i4_ p0, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlySpan`1[System.Byte] GetRawUtf8Value(System.Text.Json.JsonElement) declare in System.Runtime.InteropServices.JsonMarshal
bool w_S_S_p_i4_S_oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_S_oi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oi4_* pp0 = DataTransfer::GetPointer<S_oi4_>(apis, env, _sv0);
    S_oi4_ p0 = pp0 ? *pp0 : S_oi4_ {};

    typedef struct S_S_p_i4_ (*FuncToCall)(struct S_oi4_ p0, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlySpan`1[System.Char] op_Implicit(Microsoft.Extensions.Primitives.StringSegment) declare in Microsoft.Extensions.Primitives.StringSegment
bool w_S_S_p_i4_S_si4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_S_si4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_si4i4_* pp0 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv0);
    S_si4i4_ p0 = pp0 ? *pp0 : S_si4i4_ {};

    typedef struct S_S_p_i4_ (*FuncToCall)(struct S_si4i4_ p0, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlySpan`1[System.Char] op_Implicit(System.String) declare in System.String
bool w_S_S_p_i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_S_p_i4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlySpan`1[System.Char] AsSpan(System.String) declare in System.MemoryExtensions
bool w_S_S_p_i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_p_i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlySpan`1[System.Char] Trim(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char]) declare in System.MemoryExtensions
bool w_S_S_p_i4_tS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_tS_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef struct S_S_p_i4_ (*FuncToCall)(void*,struct S_S_p_i4_ p0, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlySpan`1[System.Char] Trim(System.ReadOnlySpan`1[System.Char], Char) declare in System.MemoryExtensions
bool w_S_S_p_i4_tc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_tc");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef struct S_S_p_i4_ (*FuncToCall)(void*,Il2CppChar p0, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlySpan`1[System.Char] AsSpan(System.String, Int32) declare in System.MemoryExtensions
bool w_S_S_p_i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_p_i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ReadOnlySpan`1[System.Char] AsSpan(System.String, Int32, Int32) declare in System.MemoryExtensions
bool w_S_S_p_i4_ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_p_i4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// TypedReference MakeTypedReference(System.Object, System.Reflection.FieldInfo[]) declare in System.TypedReference
bool w_S_S_p_pp_Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_pp_Oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_S_p_pp_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_S_p_pp_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// TypedReference GetNextArg() declare in System.ArgIterator
bool w_S_S_p_pp_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_pp_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_p_pp_ (*FuncToCall)(void*,const void* method);
    struct S_S_p_pp_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// TypedReference GetNextArg(System.RuntimeTypeHandle) declare in System.ArgIterator
bool w_S_S_p_pp_tS_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_pp_tS_p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};

    typedef struct S_S_p_pp_ (*FuncToCall)(void*,struct S_p_ p0, const void* method);
    struct S_S_p_pp_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.LocalKeyword FindKeyword(System.String) declare in UnityEngine.Rendering.LocalKeywordSpace
bool w_S_S_p_su4_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_su4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_S_p_su4_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_S_p_su4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.AnimationLayerMixerPlayable get_Null() declare in UnityEngine.Animations.AnimationLayerMixerPlayable
bool w_S_S_pu4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_pu4__ (*FuncToCall)(const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.Playable op_Implicit(UnityEngine.Animations.AnimationClipPlayable) declare in UnityEngine.Animations.AnimationClipPlayable
bool w_S_S_pu4__S_S_pu4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_S_pu4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_pu4__* pp0 = DataTransfer::GetPointer<S_S_pu4__>(apis, env, _sv0);
    S_S_pu4__ p0 = pp0 ? *pp0 : S_S_pu4__ {};

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_S_pu4__ p0, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Playables.TextureMixerPlayable Create(UnityEngine.Playables.PlayableGraph) declare in UnityEngine.Experimental.Playables.TextureMixerPlayable
bool w_S_S_pu4__S_pu4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.AnimationLayerMixerPlayable Create(UnityEngine.Playables.PlayableGraph, Int32) declare in UnityEngine.Animations.AnimationLayerMixerPlayable
bool w_S_S_pu4__S_pu4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, int32_t p1, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Audio.AudioMixerPlayable Create(UnityEngine.Playables.PlayableGraph, Int32, Boolean) declare in UnityEngine.Audio.AudioMixerPlayable
bool w_S_S_pu4__S_pu4_Di4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_Di4Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, int32_t p1, bool p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.AnimationLayerMixerPlayable Create(UnityEngine.Playables.PlayableGraph, Int32, Boolean) declare in UnityEngine.Animations.AnimationLayerMixerPlayable
bool w_S_S_pu4__S_pu4_i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_i4b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, int32_t p1, bool p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.AnimationClipPlayable Create(UnityEngine.Playables.PlayableGraph, UnityEngine.AnimationClip) declare in UnityEngine.Animations.AnimationClipPlayable
bool w_S_S_pu4__S_pu4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, Il2CppObject* p1, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Playables.MaterialEffectPlayable Create(UnityEngine.Playables.PlayableGraph, UnityEngine.Material, Int32) declare in UnityEngine.Experimental.Playables.MaterialEffectPlayable
bool w_S_S_pu4__S_pu4_oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_oDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, Il2CppObject* p1, int32_t p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Audio.AudioClipPlayable Create(UnityEngine.Playables.PlayableGraph, UnityEngine.AudioClip, Boolean) declare in UnityEngine.Audio.AudioClipPlayable
bool w_S_S_pu4__S_pu4_ob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_ob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, Il2CppObject* p1, bool p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.ScriptPlayable`1[UnityEngine.Timeline.ActivationControlPlayable] Create(UnityEngine.Playables.PlayableGraph, UnityEngine.GameObject, PostPlaybackState) declare in UnityEngine.Timeline.ActivationControlPlayable
bool w_S_S_pu4__S_pu4_oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_oi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, Il2CppObject* p1, int32_t p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.ScriptPlayable`1[UnityEngine.Timeline.PrefabControlPlayable] Create(UnityEngine.Playables.PlayableGraph, UnityEngine.GameObject, UnityEngine.Transform) declare in UnityEngine.Timeline.PrefabControlPlayable
bool w_S_S_pu4__S_pu4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.ScriptPlayable`1[UnityEngine.Timeline.TimelinePlayable] Create(UnityEngine.Playables.PlayableGraph, System.Collections.Generic.IEnumerable`1[UnityEngine.Timeline.TrackAsset], UnityEngine.GameObject, Boolean, Boolean) declare in UnityEngine.Timeline.TimelinePlayable
bool w_S_S_pu4__S_pu4_oobb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_oobb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, bool p4, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.ScriptPlayable`1[UnityEngine.Timeline.ParticleControlPlayable] Create(UnityEngine.Playables.PlayableGraph, UnityEngine.ParticleSystem, UInt32) declare in UnityEngine.Timeline.ParticleControlPlayable
bool w_S_S_pu4__S_pu4_ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_ou4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, Il2CppObject* p1, uint32_t p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.ScriptPlayable`1[UnityEngine.Timeline.TimeNotificationBehaviour] Create(UnityEngine.Playables.PlayableGraph, Double, UnityEngine.Playables.DirectorWrapMode) declare in UnityEngine.Timeline.TimeNotificationBehaviour
bool w_S_S_pu4__S_pu4_r8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_r8i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, double p1, int32_t p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.ScriptPlayableOutput Create(UnityEngine.Playables.PlayableGraph, System.String) declare in UnityEngine.Playables.ScriptPlayableOutput
bool w_S_S_pu4__S_pu4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, Il2CppString* p1, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.AnimationPlayableOutput Create(UnityEngine.Playables.PlayableGraph, System.String, UnityEngine.Animator) declare in UnityEngine.Animations.AnimationPlayableOutput
bool w_S_S_pu4__S_pu4_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.AnimationMixerPlayable PlayMixer(UnityEngine.Animator, Int32, UnityEngine.Playables.PlayableGraph ByRef) declare in UnityEngine.Playables.AnimationPlayableUtilities
bool w_S_S_pu4__oi4PS_pu4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__oi4PS_pu4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_pu4_* p2 = DataTransfer::GetPointer<S_pu4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_pu4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_pu4_));
        p2 = &up2;
    }
        

    typedef struct S_S_pu4__ (*FuncToCall)(Il2CppObject* p0, int32_t p1, struct S_pu4_* p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Animations.AnimationClipPlayable PlayClip(UnityEngine.Animator, UnityEngine.AnimationClip, UnityEngine.Playables.PlayableGraph ByRef) declare in UnityEngine.Playables.AnimationPlayableUtilities
bool w_S_S_pu4__ooPS_pu4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__ooPS_pu4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Pstruct
    S_pu4_* p2 = DataTransfer::GetPointer<S_pu4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_pu4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_pu4_));
        p2 = &up2;
    }
        

    typedef struct S_S_pu4__ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_pu4_* p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.PlayableOutput get_output() declare in UnityEngine.Playables.FrameData
bool w_S_S_pu4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_pu4__ (*FuncToCall)(void*,const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.Playable CreatePlayable(UnityEngine.Playables.PlayableGraph, UnityEngine.GameObject) declare in UnityEngine.Timeline.AnimationPlayableAsset
bool w_S_S_pu4__tS_pu4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__tS_pu4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_S_pu4__ (*FuncToCall)(void*,struct S_pu4_ p0, Il2CppObject* p1, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.Playable CreateTrackMixer(UnityEngine.Playables.PlayableGraph, UnityEngine.GameObject, Int32) declare in UnityEngine.Timeline.ActivationTrack
bool w_S_S_pu4__tS_pu4_oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__tS_pu4_oi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_S_pu4__ (*FuncToCall)(void*,struct S_pu4_ p0, Il2CppObject* p1, int32_t p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Playables.Playable GetRootPlayable(Int32) declare in UnityEngine.Playables.PlayableGraph
bool w_S_S_pu4__ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_pu4__ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.ArticulationReducedSpace get_jointPosition() declare in UnityEngine.ArticulationBody
bool w_S_S_r4_i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4_i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4_i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4_i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.ArticulationReducedSpace GetJointForcesForAcceleration(UnityEngine.ArticulationReducedSpace) declare in UnityEngine.ArticulationBody
bool w_S_S_r4_i4_tS_S_r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4_i4_tS_S_r4_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4_i4_* pp0 = DataTransfer::GetPointer<S_S_r4_i4_>(apis, env, _sv0);
    S_S_r4_i4_ p0 = pp0 ? *pp0 : S_S_r4_i4_ {};

    typedef struct S_S_r4_i4_ (*FuncToCall)(void*,struct S_S_r4_i4_ p0, const void* method);
    struct S_S_r4_i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.TransformOrigin Initial() declare in UnityEngine.UIElements.TransformOrigin
bool w_S_S_r4i4_S_r4i4_r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_S_r4i4_r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4i4_S_r4i4_r4_ (*FuncToCall)(const void* method);
    struct S_S_r4i4_S_r4i4_r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.TransformOrigin get_value() declare in UnityEngine.UIElements.StyleTransformOrigin
bool w_S_S_r4i4_S_r4i4_r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_S_r4i4_r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4i4_S_r4i4_r4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4i4_S_r4i4_r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Translate None() declare in UnityEngine.UIElements.Translate
bool w_S_S_r4i4_S_r4i4_r4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_S_r4i4_r4b_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4i4_S_r4i4_r4b_ (*FuncToCall)(const void* method);
    struct S_S_r4i4_S_r4i4_r4b_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Translate get_value() declare in UnityEngine.UIElements.StyleTranslate
bool w_S_S_r4i4_S_r4i4_r4b_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_S_r4i4_r4b_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4i4_S_r4i4_r4b_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4i4_S_r4i4_r4b_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Rotate None() declare in UnityEngine.UIElements.Rotate
bool w_S_S_r4i4_S_r4r4r4_b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_S_r4r4r4_b_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4i4_S_r4r4r4_b_ (*FuncToCall)(const void* method);
    struct S_S_r4i4_S_r4r4r4_b_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Rotate get_value() declare in UnityEngine.UIElements.StyleRotate
bool w_S_S_r4i4_S_r4r4r4_b_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_S_r4r4r4_b_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4i4_S_r4r4r4_b_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4i4_S_r4r4r4_b_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleLength op_Implicit(UnityEngine.UIElements.Length) declare in UnityEngine.UIElements.StyleLength
bool w_S_S_r4i4_i4_S_r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_i4_S_r4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4i4_* pp0 = DataTransfer::GetPointer<S_r4i4_>(apis, env, _sv0);
    S_r4i4_ p0 = pp0 ? *pp0 : S_r4i4_ {};

    typedef struct S_S_r4i4_i4_ (*FuncToCall)(struct S_r4i4_ p0, const void* method);
    struct S_S_r4i4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleLength op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleLength
bool w_S_S_r4i4_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4i4_i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r4i4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleLength op_Implicit(Single) declare in UnityEngine.UIElements.StyleLength
bool w_S_S_r4i4_i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_i4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4i4_i4_ (*FuncToCall)(float p0, const void* method);
    struct S_S_r4i4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.TerrainTools.BrushTransform FromRect(UnityEngine.Rect) declare in UnityEngine.TerrainTools.BrushTransform
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.TerrainTools.BrushTransform CalculateBrushTransform(UnityEngine.Terrain, UnityEngine.Vector2, Single, Single) declare in UnityEngine.TerrainTools.TerrainPaintUtility
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__oS_r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__oS_r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, float p2, float p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 float2x4(Unity.Mathematics.bool2x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_bb_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_bb_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 float2x4(Unity.Mathematics.int2x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 op_Increment(Unity.Mathematics.float2x4) declare in Unity.Mathematics.float2x4
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 op_Multiply(Unity.Mathematics.float2x4, Unity.Mathematics.float2x4) declare in Unity.Mathematics.float2x4
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 mul(Unity.Mathematics.float2x4, Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 op_Multiply(Unity.Mathematics.float2x4, Single) declare in Unity.Mathematics.float2x4
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, float p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 mul(Unity.Mathematics.float2x3, Unity.Mathematics.float3x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 mul(Unity.Mathematics.float2x2, Unity.Mathematics.float2x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 transpose(Unity.Mathematics.float4x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 float2x4(Unity.Mathematics.double2x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 float2x4(Unity.Mathematics.uint2x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 float2x4(Unity.Mathematics.float2, Unity.Mathematics.float2, Unity.Mathematics.float2, Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_r4r4_S_r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_r4r4_S_r4r4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 float2x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 float2x4(Int32) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 float2x4(Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 op_Multiply(Single, Unity.Mathematics.float2x4) declare in Unity.Mathematics.float2x4
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__r4S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__r4S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(float p0, struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 float2x4(Single, Single, Single, Single, Single, Single, Single, Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__r4r4r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__r4r4r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 float2x4(Double) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x4 float2x4(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 float2x3(Unity.Mathematics.bool2x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__S_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__S_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 float2x3(Unity.Mathematics.int2x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 mul(Unity.Mathematics.float2x4, Unity.Mathematics.float4x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 op_Increment(Unity.Mathematics.float2x3) declare in Unity.Mathematics.float2x3
bool w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 op_Multiply(Unity.Mathematics.float2x3, Unity.Mathematics.float2x3) declare in Unity.Mathematics.float2x3
bool w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, struct S_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 mul(Unity.Mathematics.float2x3, Unity.Mathematics.float3x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 op_Multiply(Unity.Mathematics.float2x3, Single) declare in Unity.Mathematics.float2x3
bool w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, float p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 mul(Unity.Mathematics.float2x2, Unity.Mathematics.float2x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, struct S_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 transpose(Unity.Mathematics.float3x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 float2x3(Unity.Mathematics.double2x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 float2x3(Unity.Mathematics.uint2x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 float2x3(Unity.Mathematics.float2, Unity.Mathematics.float2, Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__S_r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__S_r4r4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 float2x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 float2x3(Int32) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 float2x3(Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 op_Multiply(Single, Unity.Mathematics.float2x3) declare in Unity.Mathematics.float2x3
bool w_S_S_r4r4_S_r4r4_S_r4r4__r4S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__r4S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(float p0, struct S_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 float2x3(Single, Single, Single, Single, Single, Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 float2x3(Double) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x3 float2x3(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4_S_r4r4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.ColliderDistance2D Distance(UnityEngine.Collider2D, UnityEngine.Collider2D) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4i4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4i4_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4i4_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.ColliderDistance2D Distance(UnityEngine.Collider2D) declare in UnityEngine.Rigidbody2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4i4_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4i4_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4i4_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D GetRayIntersection(UnityEngine.Ray) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D GetRayIntersection(UnityEngine.Ray, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D GetRayIntersection(UnityEngine.Ray, Single, Int32) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_S_r4r4r4_S_r4r4r4__r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_S_r4r4r4_S_r4r4r4__r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, int32_t p2, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D Linecast(UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D Linecast(UnityEngine.Vector2, UnityEngine.Vector2, Int32) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D Linecast(UnityEngine.Vector2, UnityEngine.Vector2, Int32, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, float p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, Int32) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, float p5, int32_t p6, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, Int32, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, float p5, int32_t p6, float p7, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, float p5, int32_t p6, float p7, float p8, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D Linecast(UnityEngine.Vector2, UnityEngine.Vector2, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, float p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, int32_t p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, int32_t p5, float p6, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, int32_t p5, float p6, float p7, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, Int32) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, int32_t p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, Int32, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, int32_t p3, float p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, int32_t p3, float p4, float p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, float p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, float p3, int32_t p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, float p3, int32_t p4, float p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, float p3, int32_t p4, float p5, float p6, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D GetRayIntersection(UnityEngine.Ray, Single, Int32) declare in UnityEngine.PhysicsScene2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_S_r4r4r4_S_r4r4r4__r4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_S_r4r4r4_S_r4r4r4__r4Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, int32_t p2, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D Linecast(UnityEngine.Vector2, UnityEngine.Vector2, Int32) declare in UnityEngine.PhysicsScene2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D Linecast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.ContactFilter2D) declare in UnityEngine.PhysicsScene2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, Int32) declare in UnityEngine.PhysicsScene2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_i4r4S_r4r4_r4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_i4r4S_r4r4_r4Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, float p5, int32_t p6, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D) declare in UnityEngine.PhysicsScene2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_i4r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_i4r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv6);
    S_bbbbbbS_i4_r4r4r4r4_ p6 = pp6 ? *pp6 : S_bbbbbbS_i4_r4r4r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, float p5, struct S_bbbbbbS_i4_r4r4r4r4_ p6, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, Int32) declare in UnityEngine.PhysicsScene2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, int32_t p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D) declare in UnityEngine.PhysicsScene2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv3);
    S_bbbbbbS_i4_r4r4r4r4_ p3 = pp3 ? *pp3 : S_bbbbbbS_i4_r4r4r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_bbbbbbS_i4_r4r4r4r4_ p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32) declare in UnityEngine.PhysicsScene2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4S_r4r4_r4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4S_r4r4_r4Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, int32_t p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D) declare in UnityEngine.PhysicsScene2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv5);
    S_bbbbbbS_i4_r4r4r4r4_ p5 = pp5 ? *pp5 : S_bbbbbbS_i4_r4r4r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, struct S_bbbbbbS_i4_r4r4r4r4_ p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32) declare in UnityEngine.PhysicsScene2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_r4S_r4r4_r4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_r4S_r4r4_r4Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, float p3, int32_t p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D) declare in UnityEngine.PhysicsScene2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv4);
    S_bbbbbbS_i4_r4r4r4r4_ p4 = pp4 ? *pp4 : S_bbbbbbS_i4_r4r4r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, float p3, struct S_bbbbbbS_i4_r4r4r4r4_ p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.ContactPoint2D GetContact(Int32) declare in UnityEngine.Collision2D
bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4r4i4i4i4i4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4r4i4i4i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4r4i4i4i4i4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4r4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 float2x2(Unity.Mathematics.bool2x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__S_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__S_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb__ {};

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_bb_S_bb__ p0, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 float2x2(Unity.Mathematics.int2x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__S_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 mul(Unity.Mathematics.float2x4, Unity.Mathematics.float4x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 mul(Unity.Mathematics.float2x3, Unity.Mathematics.float3x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4_S_r4r4__S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 transpose(Unity.Mathematics.float2x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 mul(Unity.Mathematics.float2x2, Unity.Mathematics.float2x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, struct S_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 op_Multiply(Unity.Mathematics.float2x2, Single) declare in Unity.Mathematics.float2x2
bool w_S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__S_S_r4r4_S_r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, float p1, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 float2x2(Unity.Mathematics.double2x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__S_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 float2x2(Unity.Mathematics.uint2x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__S_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 Scale(Unity.Mathematics.float2) declare in Unity.Mathematics.float2x2
bool w_S_S_r4r4_S_r4r4__S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 float2x2(Unity.Mathematics.float2, Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 float2x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 float2x2(Int32) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 float2x2(Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 op_Multiply(Single, Unity.Mathematics.float2x2) declare in Unity.Mathematics.float2x2
bool w_S_S_r4r4_S_r4r4__r4S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__r4S_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(float p0, struct S_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 Scale(Single, Single) declare in Unity.Mathematics.float2x2
bool w_S_S_r4r4_S_r4r4__r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(float p0, float p1, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 float2x2(Single, Single, Single, Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 float2x2(Double) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float2x2 float2x2(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r4r4_S_r4r4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.PenData GetLastPenContactEvent() declare in UnityEngine.Input
bool w_S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__ (*FuncToCall)(const void* method);
    struct S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.PenData GetPenEvent(Int32) declare in UnityEngine.Input
bool w_S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.ShaderDebugPrintInput Get() declare in UnityEngine.Rendering.ShaderDebugPrintInputProducer
bool w_S_S_r4r4_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4_bbb_ (*FuncToCall)(const void* method);
    struct S_S_r4r4_bbb_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.TextShadow get_value() declare in UnityEngine.UIElements.StyleTextShadow
bool w_S_S_r4r4_r4S_r4r4r4r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_r4S_r4r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4_r4S_r4r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4_r4S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// TMPro.TMP_Vertex get_zero() declare in TMPro.TMP_Vertex
bool w_S_S_r4r4r4_S_r4r4_S_r4r4_S_r4r4_S_i4u1u1u1u1__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4_S_r4r4_S_r4r4_S_i4u1u1u1u1__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4_S_r4r4_S_r4r4_S_r4r4_S_i4u1u1u1u1__ (*FuncToCall)(const void* method);
    struct S_S_r4r4r4_S_r4r4_S_r4r4_S_r4r4_S_i4u1u1u1u1__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 float3x4(Unity.Mathematics.bool3x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_bbb_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_bbb_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 float3x4(Unity.Mathematics.int3x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 fastinverse(Unity.Mathematics.float3x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 op_Multiply(Unity.Mathematics.float3x4, Unity.Mathematics.float3x4) declare in Unity.Mathematics.float3x4
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 mul(Unity.Mathematics.float3x4, Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 op_Multiply(Unity.Mathematics.float3x4, Single) declare in Unity.Mathematics.float3x4
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, float p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 mul(Unity.Mathematics.float3x3, Unity.Mathematics.float3x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 mul(Unity.Mathematics.float3x2, Unity.Mathematics.float2x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 transpose(Unity.Mathematics.float4x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 float3x4(Unity.Mathematics.double3x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 float3x4(Unity.Mathematics.uint3x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 float3x4(Unity.Mathematics.float3, Unity.Mathematics.float3, Unity.Mathematics.float3, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 float3x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 float3x4(Int32) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 float3x4(Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 op_Multiply(Single, Unity.Mathematics.float3x4) declare in Unity.Mathematics.float3x4
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(float p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 float3x4(Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4r4r4r4r4r4r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4r4r4r4r4r4r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    float p9 = converter::Converter<float>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    float p10 = converter::Converter<float>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    float p11 = converter::Converter<float>::toCpp(apis, env, _sv11);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 float3x4(Double) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x4 float3x4(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(Unity.Mathematics.bool3x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(Unity.Mathematics.int3x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 mul(Unity.Mathematics.float3x4, Unity.Mathematics.float4x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 transpose(Unity.Mathematics.float3x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 mul(Unity.Mathematics.float3x3, Unity.Mathematics.float3x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 op_Multiply(Unity.Mathematics.float3x3, Single) declare in Unity.Mathematics.float3x3
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, float p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 mul(Unity.Mathematics.float3x2, Unity.Mathematics.float2x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(Unity.Mathematics.quaternion) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(Unity.Mathematics.double3x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(Unity.Mathematics.uint3x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 EulerXYZ(Unity.Mathematics.float3) declare in Unity.Mathematics.float3x3
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 Euler(Unity.Mathematics.float3, RotationOrder) declare in Unity.Mathematics.float3x3
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_Du1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_Du1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    uint8_t p1 = OptionalParameter<uint8_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, uint8_t p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 LookRotation(Unity.Mathematics.float3, Unity.Mathematics.float3) declare in Unity.Mathematics.float3x3
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(Unity.Mathematics.float3, Unity.Mathematics.float3, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 AxisAngle(Unity.Mathematics.float3, Single) declare in Unity.Mathematics.float3x3
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, float p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(Int32) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 op_Multiply(Single, Unity.Mathematics.float3x3) declare in Unity.Mathematics.float3x3
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(float p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 EulerXYZ(Single, Single, Single) declare in Unity.Mathematics.float3x3
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 Euler(Single, Single, Single, RotationOrder) declare in Unity.Mathematics.float3x3
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4r4r4Du1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4r4r4Du1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    uint8_t p3 = OptionalParameter<uint8_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, uint8_t p3, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(Single, Single, Single, Single, Single, Single, Single, Single, Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4r4r4r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r4r4r4r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(Double) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x3 float3x3(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.ContactPoint GetContact(Int32) declare in UnityEngine.Collision
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_i4i4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_i4i4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_i4i4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_i4i4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.SketchUpImportCamera GetDefaultCamera() declare in UnityEditor.SketchUpImporter
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4r4r4b_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4r4r4b_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4r4r4b_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4r4r4b_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 float3x2(Unity.Mathematics.bool3x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__S_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 float3x2(Unity.Mathematics.int3x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 transpose(Unity.Mathematics.float2x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 mul(Unity.Mathematics.float3x4, Unity.Mathematics.float4x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 mul(Unity.Mathematics.float3x3, Unity.Mathematics.float3x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 op_Increment(Unity.Mathematics.float3x2) declare in Unity.Mathematics.float3x2
bool w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 mul(Unity.Mathematics.float3x2, Unity.Mathematics.float2x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__S_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 op_Multiply(Unity.Mathematics.float3x2, Unity.Mathematics.float3x2) declare in Unity.Mathematics.float3x2
bool w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// DG.Tweening.Plugins.Core.PathCore.ControlPoint op_Addition(DG.Tweening.Plugins.Core.PathCore.ControlPoint, UnityEngine.Vector3) declare in DG.Tweening.Plugins.Core.PathCore.ControlPoint
bool w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds BoundsField(UnityEngine.Bounds, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, Il2CppArray* p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds TransformBounds(UnityEngine.Bounds, UnityEngine.Transform) declare in UnityEditorInternal.InternalEditorUtility
bool w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, Il2CppObject* p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 op_Multiply(Unity.Mathematics.float3x2, Single) declare in Unity.Mathematics.float3x2
bool w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 float3x2(Unity.Mathematics.double3x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 float3x2(Unity.Mathematics.uint3x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Ray GUIPointToWorldRay(UnityEngine.Vector2) declare in UnityEditor.HandleUtility
bool w_S_S_r4r4r4_S_r4r4r4__S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 float3x2(Unity.Mathematics.float3, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds BoundsField(UnityEngine.Rect, UnityEngine.Bounds) declare in UnityEditor.EditorGUI
bool w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds BoundsField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Bounds) declare in UnityEditor.EditorGUI
bool w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_oS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_oS_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv2);
    S_S_r4r4r4_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, struct S_S_r4r4r4_S_r4r4r4__ p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds BoundsField(UnityEngine.Rect, System.String, UnityEngine.Bounds) declare in UnityEditor.EditorGUI
bool w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_sS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_sS_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv2);
    S_S_r4r4r4_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, struct S_S_r4r4r4_S_r4r4r4__ p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 float3x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds CalculateSelectionBounds(Boolean, Boolean) declare in UnityEditorInternal.InternalEditorUtility
bool w_S_S_r4r4r4_S_r4r4r4__bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__bb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(bool p0, bool p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds CalculateSelectionBounds(Boolean, Boolean, Boolean) declare in UnityEditorInternal.InternalEditorUtility
bool w_S_S_r4r4r4_S_r4r4r4__bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__bbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(bool p0, bool p1, bool p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 float3x2(Int32) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds CalculateRelativeRectTransformBounds(UnityEngine.Transform) declare in UnityEngine.RectTransformUtility
bool w_S_S_r4r4r4_S_r4r4r4__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds BoundsField(UnityEngine.GUIContent, UnityEngine.Bounds, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_S_r4r4r4_S_r4r4r4__oS_S_r4r4r4_S_r4r4r4__Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__oS_S_r4r4r4_S_r4r4r4__Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p0, struct S_S_r4r4r4_S_r4r4r4__ p1, Il2CppArray* p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Ray ScreenPointToRay(UnityEngine.Camera, UnityEngine.Vector2) declare in UnityEngine.RectTransformUtility
bool w_S_S_r4r4r4_S_r4r4r4__oS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds CalculateBounds(UnityEngine.Vector3[], UnityEngine.Matrix4x4) declare in UnityEngine.GeometryUtility
bool w_S_S_r4r4r4_S_r4r4r4__oS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__oS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds CalculateRelativeRectTransformBounds(UnityEngine.Transform, UnityEngine.Transform) declare in UnityEngine.RectTransformUtility
bool w_S_S_r4r4r4_S_r4r4r4__oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 float3x2(Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 op_Multiply(Single, Unity.Mathematics.float3x2) declare in Unity.Mathematics.float3x2
bool w_S_S_r4r4r4_S_r4r4r4__r4S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__r4S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(float p0, struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 float3x2(Single, Single, Single, Single, Single, Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 float3x2(Double) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds BoundsField(System.String, UnityEngine.Bounds, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_S_r4r4r4_S_r4r4r4__sS_S_r4r4r4_S_r4r4r4__Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__sS_S_r4r4r4_S_r4r4r4__Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppString* p0, struct S_S_r4r4r4_S_r4r4r4__ p1, Il2CppArray* p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds get_sourceBounds() declare in UnityEngine.AI.NavMeshData
bool w_S_S_r4r4r4_S_r4r4r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds GetBoundsLocal(UnityEngine.Vector3Int) declare in UnityEngine.GridLayout
bool w_S_S_r4r4r4_S_r4r4r4__tS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__tS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,struct S_i4i4i4_ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Ray ViewportPointToRay(UnityEngine.Vector3) declare in UnityEngine.Camera
bool w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,struct S_r4r4r4_ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Bounds GetBoundsLocal(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.GridLayout
bool w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Ray ViewportPointToRay(UnityEngine.Vector3, MonoOrStereoscopicEye) declare in UnityEngine.Camera
bool w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,struct S_r4r4r4_ p0, int32_t p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float3x2 float3x2(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4_S_r4r4r4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Pose get_identity() declare in UnityEngine.Pose
bool w_S_S_r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4_S_r4r4r4r4__ (*FuncToCall)(const void* method);
    struct S_S_r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Pose GetTransformedBy(UnityEngine.Pose) declare in UnityEngine.Pose
bool w_S_S_r4r4r4_S_r4r4r4r4__tS_S_r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4r4__tS_S_r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4_S_r4r4r4r4__ (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Pose GetTransformedBy(UnityEngine.Transform) declare in UnityEngine.Pose
bool w_S_S_r4r4r4_S_r4r4r4r4__to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4r4__to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_S_r4r4r4_S_r4r4r4r4__ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_S_r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Scale None() declare in UnityEngine.UIElements.Scale
bool w_S_S_r4r4r4_b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_b_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4_b_ (*FuncToCall)(const void* method);
    struct S_S_r4r4r4_b_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Scale op_Implicit(UnityEngine.Vector2) declare in UnityEngine.UIElements.Scale
bool w_S_S_r4r4r4_b_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_b_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_S_r4r4r4_b_ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_S_r4r4r4_b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.Scale get_value() declare in UnityEngine.UIElements.StyleScale
bool w_S_S_r4r4r4_b_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_b_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4_b_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4_b_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Plane Normalize(System.Numerics.Plane) declare in System.Numerics.Plane
bool w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv0);
    S_S_r4r4r4_r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_r4_ {};

    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(struct S_S_r4r4r4_r4_ p0, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Plane Translate(UnityEngine.Plane, UnityEngine.Vector3) declare in UnityEngine.Plane
bool w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv0);
    S_S_r4r4r4_r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(struct S_S_r4r4r4_r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Plane Transform(System.Numerics.Plane, System.Numerics.Quaternion) declare in System.Numerics.Plane
bool w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv0);
    S_S_r4r4r4_r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(struct S_S_r4r4r4_r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Plane Transform(System.Numerics.Plane, System.Numerics.Matrix4x4) declare in System.Numerics.Plane
bool w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv0);
    S_S_r4r4r4_r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(struct S_S_r4r4r4_r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Plane CreateFromVertices(System.Numerics.Vector3, System.Numerics.Vector3, System.Numerics.Vector3) declare in System.Numerics.Plane
bool w_S_S_r4r4r4_r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Plane get_flipped() declare in UnityEngine.Plane
bool w_S_S_r4r4r4_r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Plane TransformPlane(UnityEngine.Plane) declare in UnityEngine.Matrix4x4
bool w_S_S_r4r4r4_r4_tS_S_r4r4r4_r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_tS_S_r4r4r4_r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv0);
    S_S_r4r4r4_r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_r4_ {};

    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(void*,struct S_S_r4r4r4_r4_ p0, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Plane GetShadowCullingPlane(Int32) declare in UnityEngine.Rendering.CameraProperties
bool w_S_S_r4r4r4_r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.TreeInstance GetTreeInstance(Int32) declare in UnityEngine.TerrainData
bool w_S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.CameraProperties get_cameraProperties() declare in UnityEngine.Rendering.ScriptableCullingParameters
bool w_S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BatchRendererGroupGlobals get_Default() declare in UnityEngine.Rendering.BatchRendererGroupGlobals
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___ (*FuncToCall)(const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UI.ColorBlock get_colors() declare in UnityEngine.UI.Selectable
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Unity.Mathematics.RigidTransform) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_S_r4r4r4r4__S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_S_r4r4r4r4__S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4r4r4r4__S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_S_r4r4r4r4__S_r4r4r4__>(apis, env, _sv0);
    S_S_S_r4r4r4r4__S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_S_r4r4r4r4__S_r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_S_r4r4r4r4__S_r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Unity.Mathematics.bool4x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Unity.Mathematics.int4x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Unity.Mathematics.float3x3, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 transpose(Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 mul(Unity.Mathematics.float4x4, Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 op_Multiply(Unity.Mathematics.float4x4, Single) declare in Unity.Mathematics.float4x4
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, float p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 mul(Unity.Mathematics.float4x3, Unity.Mathematics.float3x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 mul(Unity.Mathematics.float4x2, Unity.Mathematics.float2x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Unity.Mathematics.quaternion, Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Unity.Mathematics.double4x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Unity.Mathematics.uint4x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 EulerXYZ(Unity.Mathematics.float3) declare in Unity.Mathematics.float4x4
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 Euler(Unity.Mathematics.float3, RotationOrder) declare in Unity.Mathematics.float4x4
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_Du1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_Du1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    uint8_t p1 = OptionalParameter<uint8_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, uint8_t p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 TRS(Unity.Mathematics.float3, Unity.Mathematics.quaternion, Unity.Mathematics.float3) declare in Unity.Mathematics.float4x4
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_S_S_r4r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_S_S_r4r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_S_r4r4r4r4__ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 LookAt(Unity.Mathematics.float3, Unity.Mathematics.float3, Unity.Mathematics.float3) declare in Unity.Mathematics.float4x4
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 AxisAngle(Unity.Mathematics.float3, Single) declare in Unity.Mathematics.float4x4
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, float p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Unity.Mathematics.float4, Unity.Mathematics.float4, Unity.Mathematics.float4, Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 op_Implicit(UnityEngine.Matrix4x4) declare in Unity.Mathematics.float4x4
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Int32) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 op_Multiply(Single, Unity.Mathematics.float4x4) declare in Unity.Mathematics.float4x4
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 EulerXYZ(Single, Single, Single) declare in Unity.Mathematics.float4x4
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 Euler(Single, Single, Single, RotationOrder) declare in Unity.Mathematics.float4x4
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4r4r4Du1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4r4r4Du1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    uint8_t p3 = OptionalParameter<uint8_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, uint8_t p3, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 Ortho(Single, Single, Single, Single) declare in Unity.Mathematics.float4x4
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 OrthoOffCenter(Single, Single, Single, Single, Single, Single) declare in Unity.Mathematics.float4x4
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);

    if (checkJSArgument) {
        if (js_args_len != 16) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv11)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv12)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv13)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv14)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv15)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    float p9 = converter::Converter<float>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    float p10 = converter::Converter<float>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    float p11 = converter::Converter<float>::toCpp(apis, env, _sv11);
    // JSValToCSVal P any
    float p12 = converter::Converter<float>::toCpp(apis, env, _sv12);
    // JSValToCSVal P any
    float p13 = converter::Converter<float>::toCpp(apis, env, _sv13);
    // JSValToCSVal P any
    float p14 = converter::Converter<float>::toCpp(apis, env, _sv14);
    // JSValToCSVal P any
    float p15 = converter::Converter<float>::toCpp(apis, env, _sv15);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12, float p13, float p14, float p15, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(Double) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// TMPro.VertexGradient get_colorGradient() declare in TMPro.TMP_Text
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x4 float4x4(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ValueTuple`3[UnityEngine.Vector4,UnityEngine.Vector4,UnityEngine.Vector4] PrepareShadowsMidtonesHighlights(UnityEngine.Vector4 ByRef, UnityEngine.Vector4 ByRef, UnityEngine.Vector4 ByRef) declare in UnityEngine.Rendering.ColorUtils
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__PS_r4r4r4r4_PS_r4r4r4r4_PS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__PS_r4r4r4r4_PS_r4r4r4r4_PS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4r4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4r4_));
        p2 = &up2;
    }
        

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4_* p0, struct S_r4r4r4r4_* p1, struct S_r4r4r4r4_* p2, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 float4x3(Unity.Mathematics.bool4x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 float4x3(Unity.Mathematics.int4x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 transpose(Unity.Mathematics.float3x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 mul(Unity.Mathematics.float4x4, Unity.Mathematics.float4x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 op_Increment(Unity.Mathematics.float4x3) declare in Unity.Mathematics.float4x3
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 mul(Unity.Mathematics.float4x3, Unity.Mathematics.float3x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.SphericalHarmonicsL1 op_Addition(UnityEngine.Rendering.SphericalHarmonicsL1, UnityEngine.Rendering.SphericalHarmonicsL1) declare in UnityEngine.Rendering.SphericalHarmonicsL1
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.SphericalHarmonicsL1 op_Multiply(UnityEngine.Rendering.SphericalHarmonicsL1, Single) declare in UnityEngine.Rendering.SphericalHarmonicsL1
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, float p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 mul(Unity.Mathematics.float4x2, Unity.Mathematics.float2x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 float4x3(Unity.Mathematics.double4x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 float4x3(Unity.Mathematics.uint4x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 float4x3(Unity.Mathematics.float4, Unity.Mathematics.float4, Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 float4x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 float4x3(Int32) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 float4x3(Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 op_Multiply(Single, Unity.Mathematics.float4x3) declare in Unity.Mathematics.float4x3
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 float4x3(Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4r4r4r4r4r4r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r4r4r4r4r4r4r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    float p9 = converter::Converter<float>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    float p10 = converter::Converter<float>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    float p11 = converter::Converter<float>::toCpp(apis, env, _sv11);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 float4x3(Double) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x3 float4x3(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ValueTuple`2[UnityEngine.Vector4,UnityEngine.Vector4] PrepareSplitToning(UnityEngine.Vector4 ByRef, UnityEngine.Vector4 ByRef, Single) declare in UnityEngine.Rendering.ColorUtils
bool w_S_S_r4r4r4r4_S_r4r4r4r4__PS_r4r4r4r4_PS_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__PS_r4r4r4r4_PS_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4r4_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4_* p0, struct S_r4r4r4r4_* p1, float p2, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 float4x2(Unity.Mathematics.bool4x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 float4x2(Unity.Mathematics.int4x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

}

