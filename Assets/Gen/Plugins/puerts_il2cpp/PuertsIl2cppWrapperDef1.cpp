// Auto Gen

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "PuertsValueType.h"
#if defined(__EMSCRIPTEN__)
#include "pesapi_webgl.h"
using namespace pesapi::webglimpl;
#endif

namespace puerts
{


// Unity.Mathematics.float4x2 transpose(Unity.Mathematics.float2x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 mul(Unity.Mathematics.float4x4, Unity.Mathematics.float4x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 mul(Unity.Mathematics.float4x3, Unity.Mathematics.float3x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 op_Increment(Unity.Mathematics.float4x2) declare in Unity.Mathematics.float4x2
bool w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 mul(Unity.Mathematics.float4x2, Unity.Mathematics.float2x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv1);
    S_S_r4r4_S_r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4_S_r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 op_Multiply(Unity.Mathematics.float4x2, Unity.Mathematics.float4x2) declare in Unity.Mathematics.float4x2
bool w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 op_Multiply(Unity.Mathematics.float4x2, Single) declare in Unity.Mathematics.float4x2
bool w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, float p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 float4x2(Unity.Mathematics.double4x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 float4x2(Unity.Mathematics.uint4x2) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 float4x2(Unity.Mathematics.float4, Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 float4x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 float4x2(Int32) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 float4x2(Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 op_Multiply(Single, Unity.Mathematics.float4x2) declare in Unity.Mathematics.float4x2
bool w_S_S_r4r4r4r4_S_r4r4r4r4__r4S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__r4S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, struct S_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 float4x2(Single, Single, Single, Single, Single, Single, Single, Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__r4r4r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__r4r4r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 float4x2(Double) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.float4x2 float4x2(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4_S_r4r4r4r4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion quaternion(Unity.Mathematics.float3x3) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion quaternion(Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion conjugate(Unity.Mathematics.quaternion) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4__S_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__S_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion normalizesafe(Unity.Mathematics.quaternion, Unity.Mathematics.quaternion) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4__S_S_r4r4r4r4__S_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__S_S_r4r4r4r4__S_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4__ {};

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4__ p0, struct S_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion nlerp(Unity.Mathematics.quaternion, Unity.Mathematics.quaternion, Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4__S_S_r4r4r4r4__S_S_r4r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__S_S_r4r4r4r4__S_S_r4r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4__ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4r4__ p0, struct S_S_r4r4r4r4__ p1, float p2, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion EulerXYZ(Unity.Mathematics.float3) declare in Unity.Mathematics.quaternion
bool w_S_S_r4r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion Euler(Unity.Mathematics.float3, RotationOrder) declare in Unity.Mathematics.quaternion
bool w_S_S_r4r4r4r4__S_r4r4r4_Du1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__S_r4r4r4_Du1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    uint8_t p1 = OptionalParameter<uint8_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, uint8_t p1, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion LookRotation(Unity.Mathematics.float3, Unity.Mathematics.float3) declare in Unity.Mathematics.quaternion
bool w_S_S_r4r4r4r4__S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion AxisAngle(Unity.Mathematics.float3, Single) declare in Unity.Mathematics.quaternion
bool w_S_S_r4r4r4r4__S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4_ p0, float p1, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion quaternion(Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4__S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion RotateX(Single) declare in Unity.Mathematics.quaternion
bool w_S_S_r4r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion EulerXYZ(Single, Single, Single) declare in Unity.Mathematics.quaternion
bool w_S_S_r4r4r4r4__r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion Euler(Single, Single, Single, RotationOrder) declare in Unity.Mathematics.quaternion
bool w_S_S_r4r4r4r4__r4r4r4Du1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__r4r4r4Du1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    uint8_t p3 = OptionalParameter<uint8_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, uint8_t p3, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion quaternion(Single, Single, Single, Single) declare in Unity.Mathematics.math
bool w_S_S_r4r4r4r4__r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.quaternion NextQuaternionRotation() declare in Unity.Mathematics.Random
bool w_S_S_r4r4r4r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleColor op_Implicit(UnityEngine.Color) declare in UnityEngine.UIElements.StyleColor
bool w_S_S_r4r4r4r4_i4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_i4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_S_r4r4r4r4_i4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_S_r4r4r4r4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleColor op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleColor
bool w_S_S_r4r4r4r4_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r4r4r4r4_i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r4r4r4r4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.SortingSettings get_sortingSettings() declare in UnityEngine.Rendering.DrawingSettings
bool w_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 double2x4(Unity.Mathematics.bool2x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_bb_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_bb_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 double2x4(Unity.Mathematics.int2x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 double2x4(Unity.Mathematics.float2x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 op_Increment(Unity.Mathematics.double2x4) declare in Unity.Mathematics.double2x4
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 op_Multiply(Unity.Mathematics.double2x4, Unity.Mathematics.double2x4) declare in Unity.Mathematics.double2x4
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 mul(Unity.Mathematics.double2x4, Unity.Mathematics.double4x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 op_Multiply(Unity.Mathematics.double2x4, Double) declare in Unity.Mathematics.double2x4
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, double p1, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 mul(Unity.Mathematics.double2x3, Unity.Mathematics.double3x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 mul(Unity.Mathematics.double2x2, Unity.Mathematics.double2x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 transpose(Unity.Mathematics.double4x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 double2x4(Unity.Mathematics.uint2x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 double2x4(Unity.Mathematics.double2, Unity.Mathematics.double2, Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_r8r8_S_r8r8_S_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_r8r8_S_r8r8_S_r8r8_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv2);
    S_r8r8_ p2 = pp2 ? *pp2 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp3 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv3);
    S_r8r8_ p3 = pp3 ? *pp3 : S_r8r8_ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, struct S_r8r8_ p2, struct S_r8r8_ p3, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 double2x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 double2x4(Int32) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 double2x4(Single) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 double2x4(Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 op_Multiply(Double, Unity.Mathematics.double2x4) declare in Unity.Mathematics.double2x4
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__r8S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__r8S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(double p0, struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 double2x4(Double, Double, Double, Double, Double, Double, Double, Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__r8r8r8r8r8r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__r8r8r8r8r8r8r8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    double p4 = converter::Converter<double>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    double p5 = converter::Converter<double>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    double p6 = converter::Converter<double>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    double p7 = converter::Converter<double>::toCpp(apis, env, _sv7);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(double p0, double p1, double p2, double p3, double p4, double p5, double p6, double p7, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x4 double2x4(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 double2x3(Unity.Mathematics.bool2x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__S_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__S_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 double2x3(Unity.Mathematics.int2x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 double2x3(Unity.Mathematics.float2x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 mul(Unity.Mathematics.double2x4, Unity.Mathematics.double4x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 op_Increment(Unity.Mathematics.double2x3) declare in Unity.Mathematics.double2x3
bool w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 op_Multiply(Unity.Mathematics.double2x3, Unity.Mathematics.double2x3) declare in Unity.Mathematics.double2x3
bool w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, struct S_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 mul(Unity.Mathematics.double2x3, Unity.Mathematics.double3x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 op_Multiply(Unity.Mathematics.double2x3, Double) declare in Unity.Mathematics.double2x3
bool w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, double p1, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 mul(Unity.Mathematics.double2x2, Unity.Mathematics.double2x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, struct S_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 transpose(Unity.Mathematics.double3x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 double2x3(Unity.Mathematics.uint2x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 double2x3(Unity.Mathematics.double2, Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__S_r8r8_S_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__S_r8r8_S_r8r8_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv2);
    S_r8r8_ p2 = pp2 ? *pp2 : S_r8r8_ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, struct S_r8r8_ p2, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 double2x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 double2x3(Int32) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 double2x3(Single) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 double2x3(Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 op_Multiply(Double, Unity.Mathematics.double2x3) declare in Unity.Mathematics.double2x3
bool w_S_S_r8r8_S_r8r8_S_r8r8__r8S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__r8S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(double p0, struct S_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 double2x3(Double, Double, Double, Double, Double, Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__r8r8r8r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__r8r8r8r8r8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    double p4 = converter::Converter<double>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    double p5 = converter::Converter<double>::toCpp(apis, env, _sv5);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(double p0, double p1, double p2, double p3, double p4, double p5, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x3 double2x3(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8_S_r8r8__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8_S_r8r8__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8_S_r8r8__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r8r8_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 double2x2(Unity.Mathematics.bool2x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__S_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__S_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb__ {};

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_bb_S_bb__ p0, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 double2x2(Unity.Mathematics.int2x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__S_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 double2x2(Unity.Mathematics.float2x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__S_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 mul(Unity.Mathematics.double2x4, Unity.Mathematics.double4x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 mul(Unity.Mathematics.double2x3, Unity.Mathematics.double3x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8_S_r8r8__S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 transpose(Unity.Mathematics.double2x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 mul(Unity.Mathematics.double2x2, Unity.Mathematics.double2x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, struct S_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 op_Multiply(Unity.Mathematics.double2x2, Double) declare in Unity.Mathematics.double2x2
bool w_S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__S_S_r8r8_S_r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, double p1, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 double2x2(Unity.Mathematics.uint2x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__S_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 double2x2(Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__S_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__S_r8r8_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 double2x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 double2x2(Int32) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 double2x2(Single) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 double2x2(Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 op_Multiply(Double, Unity.Mathematics.double2x2) declare in Unity.Mathematics.double2x2
bool w_S_S_r8r8_S_r8r8__r8S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__r8S_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(double p0, struct S_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 double2x2(Double, Double, Double, Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__r8r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__r8r8r8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(double p0, double p1, double p2, double p3, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double2x2 double2x2(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r8r8_S_r8r8__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8_S_r8r8__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8_S_r8r8__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r8r8_S_r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 double3x4(Unity.Mathematics.bool3x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_bbb_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_bbb_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 double3x4(Unity.Mathematics.int3x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 double3x4(Unity.Mathematics.float3x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 fastinverse(Unity.Mathematics.double3x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 op_Multiply(Unity.Mathematics.double3x4, Unity.Mathematics.double3x4) declare in Unity.Mathematics.double3x4
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 mul(Unity.Mathematics.double3x4, Unity.Mathematics.double4x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 op_Multiply(Unity.Mathematics.double3x4, Double) declare in Unity.Mathematics.double3x4
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, double p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 mul(Unity.Mathematics.double3x3, Unity.Mathematics.double3x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 mul(Unity.Mathematics.double3x2, Unity.Mathematics.double2x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 transpose(Unity.Mathematics.double4x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 double3x4(Unity.Mathematics.uint3x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 double3x4(Unity.Mathematics.double3, Unity.Mathematics.double3, Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv2);
    S_r8r8r8_ p2 = pp2 ? *pp2 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp3 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv3);
    S_r8r8r8_ p3 = pp3 ? *pp3 : S_r8r8r8_ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, struct S_r8r8r8_ p2, struct S_r8r8r8_ p3, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 double3x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 double3x4(Int32) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 double3x4(Single) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 double3x4(Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 op_Multiply(Double, Unity.Mathematics.double3x4) declare in Unity.Mathematics.double3x4
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(double p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 double3x4(Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8r8r8r8r8r8r8r8r8r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8r8r8r8r8r8r8r8r8r8r8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    double p4 = converter::Converter<double>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    double p5 = converter::Converter<double>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    double p6 = converter::Converter<double>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    double p7 = converter::Converter<double>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    double p8 = converter::Converter<double>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    double p9 = converter::Converter<double>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    double p10 = converter::Converter<double>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    double p11 = converter::Converter<double>::toCpp(apis, env, _sv11);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(double p0, double p1, double p2, double p3, double p4, double p5, double p6, double p7, double p8, double p9, double p10, double p11, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x4 double3x4(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 double3x3(Unity.Mathematics.bool3x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 double3x3(Unity.Mathematics.int3x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 double3x3(Unity.Mathematics.float3x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 mul(Unity.Mathematics.double3x4, Unity.Mathematics.double4x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 transpose(Unity.Mathematics.double3x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 mul(Unity.Mathematics.double3x3, Unity.Mathematics.double3x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 op_Multiply(Unity.Mathematics.double3x3, Double) declare in Unity.Mathematics.double3x3
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, double p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 mul(Unity.Mathematics.double3x2, Unity.Mathematics.double2x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 double3x3(Unity.Mathematics.uint3x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 double3x3(Unity.Mathematics.double3, Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_r8r8r8_S_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_r8r8r8_S_r8r8r8_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv2);
    S_r8r8r8_ p2 = pp2 ? *pp2 : S_r8r8r8_ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, struct S_r8r8r8_ p2, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 double3x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 double3x3(Int32) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 double3x3(Single) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 double3x3(Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 op_Multiply(Double, Unity.Mathematics.double3x3) declare in Unity.Mathematics.double3x3
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(double p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 double3x3(Double, Double, Double, Double, Double, Double, Double, Double, Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8r8r8r8r8r8r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__r8r8r8r8r8r8r8r8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    double p4 = converter::Converter<double>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    double p5 = converter::Converter<double>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    double p6 = converter::Converter<double>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    double p7 = converter::Converter<double>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    double p8 = converter::Converter<double>::toCpp(apis, env, _sv8);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(double p0, double p1, double p2, double p3, double p4, double p5, double p6, double p7, double p8, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x3 double3x3(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8_S_r8r8r8__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 double3x2(Unity.Mathematics.bool3x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__S_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__S_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 double3x2(Unity.Mathematics.int3x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 double3x2(Unity.Mathematics.float3x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 transpose(Unity.Mathematics.double2x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 mul(Unity.Mathematics.double3x4, Unity.Mathematics.double4x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 mul(Unity.Mathematics.double3x3, Unity.Mathematics.double3x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 op_Increment(Unity.Mathematics.double3x2) declare in Unity.Mathematics.double3x2
bool w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 mul(Unity.Mathematics.double3x2, Unity.Mathematics.double2x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__S_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 op_Multiply(Unity.Mathematics.double3x2, Unity.Mathematics.double3x2) declare in Unity.Mathematics.double3x2
bool w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 op_Multiply(Unity.Mathematics.double3x2, Double) declare in Unity.Mathematics.double3x2
bool w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__S_S_r8r8r8_S_r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, double p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 double3x2(Unity.Mathematics.uint3x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 double3x2(Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__S_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__S_r8r8r8_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 double3x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 double3x2(Int32) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 double3x2(Single) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 double3x2(Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 op_Multiply(Double, Unity.Mathematics.double3x2) declare in Unity.Mathematics.double3x2
bool w_S_S_r8r8r8_S_r8r8r8__r8S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__r8S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(double p0, struct S_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 double3x2(Double, Double, Double, Double, Double, Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__r8r8r8r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__r8r8r8r8r8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    double p4 = converter::Converter<double>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    double p5 = converter::Converter<double>::toCpp(apis, env, _sv5);

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(double p0, double p1, double p2, double p3, double p4, double p5, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double3x2 double3x2(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8_S_r8r8r8__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8_S_r8r8r8__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8_S_r8r8r8__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r8r8r8_S_r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 double4x4(Unity.Mathematics.bool4x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 double4x4(Unity.Mathematics.int4x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 double4x4(Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 transpose(Unity.Mathematics.double4x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 mul(Unity.Mathematics.double4x4, Unity.Mathematics.double4x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 op_Multiply(Unity.Mathematics.double4x4, Double) declare in Unity.Mathematics.double4x4
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, double p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 mul(Unity.Mathematics.double4x3, Unity.Mathematics.double3x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 mul(Unity.Mathematics.double4x2, Unity.Mathematics.double2x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 double4x4(Unity.Mathematics.uint4x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 double4x4(Unity.Mathematics.double4, Unity.Mathematics.double4, Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv2);
    S_r8r8r8r8_ p2 = pp2 ? *pp2 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp3 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv3);
    S_r8r8r8r8_ p3 = pp3 ? *pp3 : S_r8r8r8r8_ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, struct S_r8r8r8r8_ p2, struct S_r8r8r8r8_ p3, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 double4x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 double4x4(Int32) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 double4x4(Single) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 double4x4(Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 op_Multiply(Double, Unity.Mathematics.double4x4) declare in Unity.Mathematics.double4x4
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(double p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 double4x4(Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8r8r8r8r8r8r8r8r8r8r8r8r8r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8r8r8r8r8r8r8r8r8r8r8r8r8r8r8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);

    if (checkJSArgument) {
        if (js_args_len != 16) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv11)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv12)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv13)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv14)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv15)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    double p4 = converter::Converter<double>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    double p5 = converter::Converter<double>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    double p6 = converter::Converter<double>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    double p7 = converter::Converter<double>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    double p8 = converter::Converter<double>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    double p9 = converter::Converter<double>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    double p10 = converter::Converter<double>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    double p11 = converter::Converter<double>::toCpp(apis, env, _sv11);
    // JSValToCSVal P any
    double p12 = converter::Converter<double>::toCpp(apis, env, _sv12);
    // JSValToCSVal P any
    double p13 = converter::Converter<double>::toCpp(apis, env, _sv13);
    // JSValToCSVal P any
    double p14 = converter::Converter<double>::toCpp(apis, env, _sv14);
    // JSValToCSVal P any
    double p15 = converter::Converter<double>::toCpp(apis, env, _sv15);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(double p0, double p1, double p2, double p3, double p4, double p5, double p6, double p7, double p8, double p9, double p10, double p11, double p12, double p13, double p14, double p15, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x4 double4x4(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 double4x3(Unity.Mathematics.bool4x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 double4x3(Unity.Mathematics.int4x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 double4x3(Unity.Mathematics.float4x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 transpose(Unity.Mathematics.double3x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 mul(Unity.Mathematics.double4x4, Unity.Mathematics.double4x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 op_Increment(Unity.Mathematics.double4x3) declare in Unity.Mathematics.double4x3
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 mul(Unity.Mathematics.double4x3, Unity.Mathematics.double3x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 op_Multiply(Unity.Mathematics.double4x3, Unity.Mathematics.double4x3) declare in Unity.Mathematics.double4x3
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 op_Multiply(Unity.Mathematics.double4x3, Double) declare in Unity.Mathematics.double4x3
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, double p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 mul(Unity.Mathematics.double4x2, Unity.Mathematics.double2x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 double4x3(Unity.Mathematics.uint4x3) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 double4x3(Unity.Mathematics.double4, Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv2);
    S_r8r8r8r8_ p2 = pp2 ? *pp2 : S_r8r8r8r8_ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, struct S_r8r8r8r8_ p2, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 double4x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 double4x3(Int32) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 double4x3(Single) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 double4x3(Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 op_Multiply(Double, Unity.Mathematics.double4x3) declare in Unity.Mathematics.double4x3
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(double p0, struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 double4x3(Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double, Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8r8r8r8r8r8r8r8r8r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__r8r8r8r8r8r8r8r8r8r8r8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    double p4 = converter::Converter<double>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    double p5 = converter::Converter<double>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    double p6 = converter::Converter<double>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    double p7 = converter::Converter<double>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    double p8 = converter::Converter<double>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    double p9 = converter::Converter<double>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    double p10 = converter::Converter<double>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    double p11 = converter::Converter<double>::toCpp(apis, env, _sv11);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(double p0, double p1, double p2, double p3, double p4, double p5, double p6, double p7, double p8, double p9, double p10, double p11, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x3 double4x3(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 double4x2(Unity.Mathematics.bool4x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 double4x2(Unity.Mathematics.int4x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 double4x2(Unity.Mathematics.float4x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 transpose(Unity.Mathematics.double2x4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 mul(Unity.Mathematics.double4x4, Unity.Mathematics.double4x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 mul(Unity.Mathematics.double4x3, Unity.Mathematics.double3x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8_S_r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8r8_S_r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 op_Increment(Unity.Mathematics.double4x2) declare in Unity.Mathematics.double4x2
bool w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 mul(Unity.Mathematics.double4x2, Unity.Mathematics.double2x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv1);
    S_S_r8r8_S_r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8_S_r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8_S_r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 op_Multiply(Unity.Mathematics.double4x2, Unity.Mathematics.double4x2) declare in Unity.Mathematics.double4x2
bool w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, struct S_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 op_Multiply(Unity.Mathematics.double4x2, Double) declare in Unity.Mathematics.double4x2
bool w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_r8r8r8r8_S_r8r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, double p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 double4x2(Unity.Mathematics.uint4x2) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 double4x2(Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__S_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__S_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 double4x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 double4x2(Int32) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 double4x2(Single) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(float p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 double4x2(Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(double p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 op_Multiply(Double, Unity.Mathematics.double4x2) declare in Unity.Mathematics.double4x2
bool w_S_S_r8r8r8r8_S_r8r8r8r8__r8S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__r8S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp1 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv1);
    S_S_r8r8r8r8_S_r8r8r8r8__ p1 = pp1 ? *pp1 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(double p0, struct S_S_r8r8r8r8_S_r8r8r8r8__ p1, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 double4x2(Double, Double, Double, Double, Double, Double, Double, Double) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__r8r8r8r8r8r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__r8r8r8r8r8r8r8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    double p4 = converter::Converter<double>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    double p5 = converter::Converter<double>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    double p6 = converter::Converter<double>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    double p7 = converter::Converter<double>::toCpp(apis, env, _sv7);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(double p0, double p1, double p2, double p3, double p4, double p5, double p6, double p7, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.double4x2 double4x2(UInt32) declare in Unity.Mathematics.math
bool w_S_S_r8r8r8r8_S_r8r8r8r8__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r8r8r8r8_S_r8r8r8r8__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_r8r8r8r8_S_r8r8r8r8__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_r8r8r8r8_S_r8r8r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Diagnostics.ActivityContext Parse(System.String, System.String) declare in System.Diagnostics.ActivityContext
bool w_S_S_s_S_s_i4sb_ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_s_S_s_i4sb_ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_S_s_S_s_i4sb_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    struct S_S_s_S_s_i4sb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Diagnostics.ActivityContext get_Context() declare in System.Diagnostics.Activity
bool w_S_S_s_S_s_i4sb_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_s_S_s_i4sb_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_s_S_s_i4sb_ (*FuncToCall)(void*,const void* method);
    struct S_S_s_S_s_i4sb_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Microsoft.Extensions.Primitives.StringTokenizer Split(Char[]) declare in Microsoft.Extensions.Primitives.StringSegment
bool w_S_S_si4i4_o_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_si4i4_o_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_S_si4i4_o_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_S_si4i4_o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Enumerator GetEnumerator() declare in Microsoft.Extensions.Primitives.StringTokenizer
bool w_S_S_si4i4_oi4S_si4i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_si4i4_oi4S_si4i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_si4i4_oi4S_si4i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_si4i4_oi4S_si4i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BlendState get_defaultValue() declare in UnityEngine.Rendering.BlendState
bool w_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ (*FuncToCall)(const void* method);
    struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BlendState get_blendState() declare in UnityEngine.Rendering.RenderStateBlock
bool w_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ (*FuncToCall)(void*,const void* method);
    struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector`1[System.Single] ConvertToSingle(System.Numerics.Vector`1[System.Int32]) declare in System.Numerics.Vector
bool w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp0 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(apis, env, _sv0);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p0 = pp0 ? *pp0 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};

    typedef struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ (*FuncToCall)(struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p0, const void* method);
    struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector`1[System.Byte] Narrow(System.Numerics.Vector`1[System.UInt16], System.Numerics.Vector`1[System.UInt16]) declare in System.Numerics.Vector
bool w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp0 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(apis, env, _sv0);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p0 = pp0 ? *pp0 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
    // JSValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(apis, env, _sv1);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1 = pp1 ? *pp1 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};

    typedef struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ (*FuncToCall)(struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p0, struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1, const void* method);
    struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.Vector`1[System.Single] ConditionalSelect(System.Numerics.Vector`1[System.Int32], System.Numerics.Vector`1[System.Single], System.Numerics.Vector`1[System.Single]) declare in System.Numerics.Vector
bool w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp0 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(apis, env, _sv0);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p0 = pp0 ? *pp0 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
    // JSValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(apis, env, _sv1);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1 = pp1 ? *pp1 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
    // JSValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp2 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(apis, env, _sv2);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p2 = pp2 ? *pp2 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};

    typedef struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ (*FuncToCall)(struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p0, struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1, struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p2, const void* method);
    struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Unity.Mathematics.half4) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__S_S_u2_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__S_S_u2_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2_S_u2__ {};

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_S_u2_S_u2_S_u2_S_u2__ p0, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Unity.Mathematics.half3, Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__S_S_u2_S_u2_S_u2__S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__S_S_u2_S_u2_S_u2__S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_S_u2_S_u2_S_u2__ p0, struct S_u2_ p1, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Unity.Mathematics.half2, Unity.Mathematics.half2) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__S_S_u2_S_u2__S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__S_S_u2_S_u2__S_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2__ {};

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_S_u2_S_u2__ p0, struct S_S_u2_S_u2__ p1, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Unity.Mathematics.half2, Unity.Mathematics.half, Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__S_S_u2_S_u2__S_u2_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__S_S_u2_S_u2__S_u2_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp2 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv2);
    S_u2_ p2 = pp2 ? *pp2 : S_u2_ {};

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_S_u2_S_u2__ p0, struct S_u2_ p1, struct S_u2_ p2, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_r8r8r8r8_ p0, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_u2_ p0, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Unity.Mathematics.half, Unity.Mathematics.half3) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__S_u2_S_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__S_u2_S_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2_S_u2__ {};

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_u2_ p0, struct S_S_u2_S_u2_S_u2__ p1, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Unity.Mathematics.half, Unity.Mathematics.half2, Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__S_u2_S_S_u2_S_u2__S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__S_u2_S_S_u2_S_u2__S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_u2_* pp2 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv2);
    S_u2_ p2 = pp2 ? *pp2 : S_u2_ {};

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_u2_ p0, struct S_S_u2_S_u2__ p1, struct S_u2_ p2, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Unity.Mathematics.half, Unity.Mathematics.half, Unity.Mathematics.half2) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__S_u2_S_u2_S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__S_u2_S_u2_S_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp2 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv2);
    S_S_u2_S_u2__ p2 = pp2 ? *pp2 : S_S_u2_S_u2__ {};

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_u2_ p0, struct S_u2_ p1, struct S_S_u2_S_u2__ p2, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Unity.Mathematics.half, Unity.Mathematics.half, Unity.Mathematics.half, Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__S_u2_S_u2_S_u2_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__S_u2_S_u2_S_u2_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp2 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv2);
    S_u2_ p2 = pp2 ? *pp2 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp3 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv3);
    S_u2_ p3 = pp3 ? *pp3 : S_u2_ {};

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_u2_ p0, struct S_u2_ p1, struct S_u2_ p2, struct S_u2_ p3, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Single) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(float p0, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 half4(Double) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2_S_u2__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(double p0, const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half4 get_xxxx() declare in Unity.Mathematics.half2
bool w_S_S_u2_S_u2_S_u2_S_u2__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2_S_u2__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_u2_S_u2_S_u2_S_u2__ (*FuncToCall)(void*,const void* method);
    struct S_S_u2_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half3 half3(Unity.Mathematics.half3) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2__S_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2__S_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2__ {};

    typedef struct S_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_S_u2_S_u2_S_u2__ p0, const void* method);
    struct S_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half3 half3(Unity.Mathematics.half2, Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2__S_S_u2_S_u2__S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2__S_S_u2_S_u2__S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};

    typedef struct S_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_S_u2_S_u2__ p0, struct S_u2_ p1, const void* method);
    struct S_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half3 half3(Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2__S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half3 half3(Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2__S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2__S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};

    typedef struct S_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_r8r8r8_ p0, const void* method);
    struct S_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half3 half3(Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2__S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2__S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef struct S_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_u2_ p0, const void* method);
    struct S_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half3 half3(Unity.Mathematics.half, Unity.Mathematics.half2) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2__S_u2_S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2__S_u2_S_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2__ {};

    typedef struct S_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_u2_ p0, struct S_S_u2_S_u2__ p1, const void* method);
    struct S_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half3 half3(Unity.Mathematics.half, Unity.Mathematics.half, Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2__S_u2_S_u2_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2__S_u2_S_u2_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp2 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv2);
    S_u2_ p2 = pp2 ? *pp2 : S_u2_ {};

    typedef struct S_S_u2_S_u2_S_u2__ (*FuncToCall)(struct S_u2_ p0, struct S_u2_ p1, struct S_u2_ p2, const void* method);
    struct S_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half3 half3(Single) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_u2_S_u2_S_u2__ (*FuncToCall)(float p0, const void* method);
    struct S_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half3 half3(Double) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2_S_u2__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u2_S_u2_S_u2__ (*FuncToCall)(double p0, const void* method);
    struct S_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half3 get_xxx() declare in Unity.Mathematics.half2
bool w_S_S_u2_S_u2_S_u2__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2_S_u2__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_u2_S_u2_S_u2__ (*FuncToCall)(void*,const void* method);
    struct S_S_u2_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half2 half2(Unity.Mathematics.half2) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2__S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2__S_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};

    typedef struct S_S_u2_S_u2__ (*FuncToCall)(struct S_S_u2_S_u2__ p0, const void* method);
    struct S_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half2 half2(Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2__S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2__S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_S_u2_S_u2__ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half2 half2(Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2__S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2__S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};

    typedef struct S_S_u2_S_u2__ (*FuncToCall)(struct S_r8r8_ p0, const void* method);
    struct S_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half2 half2(Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2__S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2__S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef struct S_S_u2_S_u2__ (*FuncToCall)(struct S_u2_ p0, const void* method);
    struct S_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half2 half2(Unity.Mathematics.half, Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2__S_u2_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2__S_u2_S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};

    typedef struct S_S_u2_S_u2__ (*FuncToCall)(struct S_u2_ p0, struct S_u2_ p1, const void* method);
    struct S_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half2 half2(Single) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_u2_S_u2__ (*FuncToCall)(float p0, const void* method);
    struct S_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half2 half2(Double) declare in Unity.Mathematics.math
bool w_S_S_u2_S_u2__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u2_S_u2__ (*FuncToCall)(double p0, const void* method);
    struct S_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.half2 get_xx() declare in Unity.Mathematics.half2
bool w_S_S_u2_S_u2__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_S_u2__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_u2_S_u2__ (*FuncToCall)(void*,const void* method);
    struct S_S_u2_S_u2__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderDescription GetDescription(Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderHandle) declare in Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderHandle
bool w_S_S_u2_u2u1u1i4i4Pv_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_u2u1u1i4i4Pv_S_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef struct S_S_u2_u2u1u1i4i4Pv_ (*FuncToCall)(struct S_u8_ p0, const void* method);
    struct S_S_u2_u2u1u1i4i4Pv_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.ComputeBufferHandle get_nullHandle() declare in UnityEngine.Experimental.Rendering.RenderGraphModule.ComputeBufferHandle
bool w_S_S_u4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4i4__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_u4i4__ (*FuncToCall)(const void* method);
    struct S_S_u4i4__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle get_blackTexture() declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraphDefaultResources
bool w_S_S_u4i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_u4i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_u4i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.ComputeBufferHandle CreateComputeBuffer(UnityEngine.Experimental.Rendering.RenderGraphModule.ComputeBufferHandle ByRef) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_S_S_u4i4__tPS_S_u4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4i4__tPS_S_u4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_u4i4__* p0 = DataTransfer::GetPointer<S_S_u4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_u4i4__));
        p0 = &up0;
    }
        

    typedef struct S_S_u4i4__ (*FuncToCall)(void*,struct S_S_u4i4__* p0, const void* method);
    struct S_S_u4i4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle UseColorBuffer(UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle ByRef, Int32) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraphBuilder
bool w_S_S_u4i4__tPS_S_u4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4i4__tPS_S_u4i4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_u4i4__* p0 = DataTransfer::GetPointer<S_S_u4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_u4i4__));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4i4__ (*FuncToCall)(void*,struct S_S_u4i4__* p0, int32_t p1, const void* method);
    struct S_S_u4i4__ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle CreateTexture(UnityEngine.Experimental.Rendering.RenderGraphModule.TextureDesc ByRef) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_S_S_u4i4__tPS_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4i4__tPS_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__* p0 = DataTransfer::GetPointer<S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__));
        p0 = &up0;
    }
        

    typedef struct S_S_u4i4__ (*FuncToCall)(void*,struct S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__* p0, const void* method);
    struct S_S_u4i4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle CreateSharedTexture(UnityEngine.Experimental.Rendering.RenderGraphModule.TextureDesc ByRef, Boolean) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_S_S_u4i4__tPS_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4i4__tPS_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__* p0 = DataTransfer::GetPointer<S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__));
        p0 = &up0;
    }
        
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_S_u4i4__ (*FuncToCall)(void*,struct S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__* p0, bool p1, const void* method);
    struct S_S_u4i4__ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.ComputeBufferHandle CreateComputeBuffer(UnityEngine.Experimental.Rendering.RenderGraphModule.ComputeBufferDesc ByRef) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_S_S_u4i4__tPS_i4i4i4s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4i4__tPS_i4i4i4s_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4i4s_* p0 = DataTransfer::GetPointer<S_i4i4i4s_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4s_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4i4s_));
        p0 = &up0;
    }
        

    typedef struct S_S_u4i4__ (*FuncToCall)(void*,struct S_i4i4i4s_* p0, const void* method);
    struct S_S_u4i4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle CreateTexture(UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_S_S_u4i4__tS_S_u4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4i4__tS_S_u4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4i4__* pp0 = DataTransfer::GetPointer<S_S_u4i4__>(apis, env, _sv0);
    S_S_u4i4__ p0 = pp0 ? *pp0 : S_S_u4i4__ {};

    typedef struct S_S_u4i4__ (*FuncToCall)(void*,struct S_S_u4i4__ p0, const void* method);
    struct S_S_u4i4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle ImportBackbuffer(UnityEngine.Rendering.RenderTargetIdentifier) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_S_S_u4i4__tS_i4i4i4pi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4i4__tS_i4i4i4pi4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};

    typedef struct S_S_u4i4__ (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, const void* method);
    struct S_S_u4i4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle ImportTexture(UnityEngine.Rendering.RTHandle) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_S_S_u4i4__to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4i4__to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_S_u4i4__ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_S_u4i4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 uint2x4(Unity.Mathematics.bool2x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_bb_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_bb_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 uint2x4(Unity.Mathematics.int2x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 uint2x4(Unity.Mathematics.float2x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 uint2x4(Unity.Mathematics.double2x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 op_Increment(Unity.Mathematics.uint2x4) declare in Unity.Mathematics.uint2x4
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 op_Multiply(Unity.Mathematics.uint2x4, Unity.Mathematics.uint2x4) declare in Unity.Mathematics.uint2x4
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 mul(Unity.Mathematics.uint2x4, Unity.Mathematics.uint4x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 op_LeftShift(Unity.Mathematics.uint2x4, Int32) declare in Unity.Mathematics.uint2x4
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, int32_t p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 op_Multiply(Unity.Mathematics.uint2x4, UInt32) declare in Unity.Mathematics.uint2x4
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 mul(Unity.Mathematics.uint2x3, Unity.Mathematics.uint3x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 mul(Unity.Mathematics.uint2x2, Unity.Mathematics.uint2x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 transpose(Unity.Mathematics.uint4x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 uint2x4(Unity.Mathematics.uint2, Unity.Mathematics.uint2, Unity.Mathematics.uint2, Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_u4u4_S_u4u4_S_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_u4u4_S_u4u4_S_u4u4_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv2);
    S_u4u4_ p2 = pp2 ? *pp2 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp3 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv3);
    S_u4u4_ p3 = pp3 ? *pp3 : S_u4u4_ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, struct S_u4u4_ p2, struct S_u4u4_ p3, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 uint2x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 uint2x4(Int32) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 uint2x4(Single) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 uint2x4(Double) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 uint2x4(UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 op_Multiply(UInt32, Unity.Mathematics.uint2x4) declare in Unity.Mathematics.uint2x4
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__u4S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__u4S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x4 uint2x4(UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__u4u4u4u4u4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__u4u4u4u4u4u4u4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    uint32_t p6 = converter::Converter<uint32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, uint32_t p6, uint32_t p7, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 uint2x3(Unity.Mathematics.bool2x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_S_bb_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_bb_S_bb_S_bb__ p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 uint2x3(Unity.Mathematics.int2x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 uint2x3(Unity.Mathematics.float2x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 uint2x3(Unity.Mathematics.double2x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 mul(Unity.Mathematics.uint2x4, Unity.Mathematics.uint4x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 op_Increment(Unity.Mathematics.uint2x3) declare in Unity.Mathematics.uint2x3
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 op_Multiply(Unity.Mathematics.uint2x3, Unity.Mathematics.uint2x3) declare in Unity.Mathematics.uint2x3
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, struct S_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 mul(Unity.Mathematics.uint2x3, Unity.Mathematics.uint3x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 op_LeftShift(Unity.Mathematics.uint2x3, Int32) declare in Unity.Mathematics.uint2x3
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, int32_t p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 op_Multiply(Unity.Mathematics.uint2x3, UInt32) declare in Unity.Mathematics.uint2x3
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 mul(Unity.Mathematics.uint2x2, Unity.Mathematics.uint2x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, struct S_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 transpose(Unity.Mathematics.uint3x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 uint2x3(Unity.Mathematics.uint2, Unity.Mathematics.uint2, Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__S_u4u4_S_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__S_u4u4_S_u4u4_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv2);
    S_u4u4_ p2 = pp2 ? *pp2 : S_u4u4_ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, struct S_u4u4_ p2, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 uint2x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 uint2x3(Int32) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 uint2x3(Single) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 uint2x3(Double) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 uint2x3(UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 op_Multiply(UInt32, Unity.Mathematics.uint2x3) declare in Unity.Mathematics.uint2x3
bool w_S_S_u4u4_S_u4u4_S_u4u4__u4S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__u4S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x3 uint2x3(UInt32, UInt32, UInt32, UInt32, UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4_S_u4u4__u4u4u4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4_S_u4u4__u4u4u4u4u4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);

    typedef struct S_S_u4u4_S_u4u4_S_u4u4__ (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, const void* method);
    struct S_S_u4u4_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 uint2x2(Unity.Mathematics.bool2x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__S_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__S_S_bb_S_bb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb__ {};

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_bb_S_bb__ p0, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 uint2x2(Unity.Mathematics.int2x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__S_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 uint2x2(Unity.Mathematics.float2x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__S_S_r4r4_S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 uint2x2(Unity.Mathematics.double2x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__S_S_r8r8_S_r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 mul(Unity.Mathematics.uint2x4, Unity.Mathematics.uint4x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 mul(Unity.Mathematics.uint2x3, Unity.Mathematics.uint3x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4_S_u4u4__S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 transpose(Unity.Mathematics.uint2x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 mul(Unity.Mathematics.uint2x2, Unity.Mathematics.uint2x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, struct S_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 op_LeftShift(Unity.Mathematics.uint2x2, Int32) declare in Unity.Mathematics.uint2x2
bool w_S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, int32_t p1, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 op_Multiply(Unity.Mathematics.uint2x2, UInt32) declare in Unity.Mathematics.uint2x2
bool w_S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__S_S_u4u4_S_u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 uint2x2(Unity.Mathematics.uint2, Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__S_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__S_u4u4_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 uint2x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 uint2x2(Int32) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 uint2x2(Single) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 uint2x2(Double) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 uint2x2(UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 op_Multiply(UInt32, Unity.Mathematics.uint2x2) declare in Unity.Mathematics.uint2x2
bool w_S_S_u4u4_S_u4u4__u4S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__u4S_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint2x2 uint2x2(UInt32, UInt32, UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4_S_u4u4__u4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4_S_u4u4__u4u4u4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);

    typedef struct S_S_u4u4_S_u4u4__ (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, const void* method);
    struct S_S_u4u4_S_u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 uint3x4(Unity.Mathematics.bool3x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_bbb_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_bbb_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 uint3x4(Unity.Mathematics.int3x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 uint3x4(Unity.Mathematics.float3x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 uint3x4(Unity.Mathematics.double3x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 op_Increment(Unity.Mathematics.uint3x4) declare in Unity.Mathematics.uint3x4
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 op_Multiply(Unity.Mathematics.uint3x4, Unity.Mathematics.uint3x4) declare in Unity.Mathematics.uint3x4
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 mul(Unity.Mathematics.uint3x4, Unity.Mathematics.uint4x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 op_LeftShift(Unity.Mathematics.uint3x4, Int32) declare in Unity.Mathematics.uint3x4
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, int32_t p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 op_Multiply(Unity.Mathematics.uint3x4, UInt32) declare in Unity.Mathematics.uint3x4
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 mul(Unity.Mathematics.uint3x3, Unity.Mathematics.uint3x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 mul(Unity.Mathematics.uint3x2, Unity.Mathematics.uint2x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 transpose(Unity.Mathematics.uint4x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 uint3x4(Unity.Mathematics.uint3, Unity.Mathematics.uint3, Unity.Mathematics.uint3, Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv2);
    S_u4u4u4_ p2 = pp2 ? *pp2 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp3 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv3);
    S_u4u4u4_ p3 = pp3 ? *pp3 : S_u4u4u4_ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, struct S_u4u4u4_ p2, struct S_u4u4u4_ p3, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 uint3x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 uint3x4(Int32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 uint3x4(Single) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 uint3x4(Double) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 uint3x4(UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 op_Multiply(UInt32, Unity.Mathematics.uint3x4) declare in Unity.Mathematics.uint3x4
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x4 uint3x4(UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4u4u4u4u4u4u4u4u4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4u4u4u4u4u4u4u4u4u4u4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    uint32_t p6 = converter::Converter<uint32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    uint32_t p8 = converter::Converter<uint32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    uint32_t p9 = converter::Converter<uint32_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    uint32_t p10 = converter::Converter<uint32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    uint32_t p11 = converter::Converter<uint32_t>::toCpp(apis, env, _sv11);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, uint32_t p6, uint32_t p7, uint32_t p8, uint32_t p9, uint32_t p10, uint32_t p11, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 uint3x3(Unity.Mathematics.bool3x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_bbb_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 uint3x3(Unity.Mathematics.int3x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 uint3x3(Unity.Mathematics.float3x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 uint3x3(Unity.Mathematics.double3x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 mul(Unity.Mathematics.uint3x4, Unity.Mathematics.uint4x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 transpose(Unity.Mathematics.uint3x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 mul(Unity.Mathematics.uint3x3, Unity.Mathematics.uint3x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 op_LeftShift(Unity.Mathematics.uint3x3, Int32) declare in Unity.Mathematics.uint3x3
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, int32_t p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 op_Multiply(Unity.Mathematics.uint3x3, UInt32) declare in Unity.Mathematics.uint3x3
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 mul(Unity.Mathematics.uint3x2, Unity.Mathematics.uint2x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 uint3x3(Unity.Mathematics.uint3, Unity.Mathematics.uint3, Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_u4u4u4_S_u4u4u4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_u4u4u4_S_u4u4u4_S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv2);
    S_u4u4u4_ p2 = pp2 ? *pp2 : S_u4u4u4_ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, struct S_u4u4u4_ p2, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 uint3x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 uint3x3(Int32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 uint3x3(Single) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 uint3x3(Double) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 uint3x3(UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 op_Multiply(UInt32, Unity.Mathematics.uint3x3) declare in Unity.Mathematics.uint3x3
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x3 uint3x3(UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4u4u4u4u4u4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4_S_u4u4u4__u4u4u4u4u4u4u4u4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    uint32_t p6 = converter::Converter<uint32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    uint32_t p8 = converter::Converter<uint32_t>::toCpp(apis, env, _sv8);

    typedef struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, uint32_t p6, uint32_t p7, uint32_t p8, const void* method);
    struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 uint3x2(Unity.Mathematics.bool3x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__S_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_S_bbb_S_bbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_bbb_S_bbb__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 uint3x2(Unity.Mathematics.int3x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 uint3x2(Unity.Mathematics.float3x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 uint3x2(Unity.Mathematics.double3x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_S_r8r8r8_S_r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 transpose(Unity.Mathematics.uint2x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 mul(Unity.Mathematics.uint3x4, Unity.Mathematics.uint4x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 mul(Unity.Mathematics.uint3x3, Unity.Mathematics.uint3x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 op_Increment(Unity.Mathematics.uint3x2) declare in Unity.Mathematics.uint3x2
bool w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 mul(Unity.Mathematics.uint3x2, Unity.Mathematics.uint2x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__S_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 op_Multiply(Unity.Mathematics.uint3x2, Unity.Mathematics.uint3x2) declare in Unity.Mathematics.uint3x2
bool w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 op_LeftShift(Unity.Mathematics.uint3x2, Int32) declare in Unity.Mathematics.uint3x2
bool w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, int32_t p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 op_Multiply(Unity.Mathematics.uint3x2, UInt32) declare in Unity.Mathematics.uint3x2
bool w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_S_u4u4u4_S_u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 uint3x2(Unity.Mathematics.uint3, Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__S_u4u4u4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__S_u4u4u4_S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 uint3x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 uint3x2(Int32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 uint3x2(Single) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 uint3x2(Double) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 uint3x2(UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 op_Multiply(UInt32, Unity.Mathematics.uint3x2) declare in Unity.Mathematics.uint3x2
bool w_S_S_u4u4u4_S_u4u4u4__u4S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__u4S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3x2 uint3x2(UInt32, UInt32, UInt32, UInt32, UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4_S_u4u4u4__u4u4u4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4_S_u4u4u4__u4u4u4u4u4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);

    typedef struct S_S_u4u4u4_S_u4u4u4__ (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, const void* method);
    struct S_S_u4u4u4_S_u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 uint4x4(Unity.Mathematics.bool4x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 uint4x4(Unity.Mathematics.int4x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 uint4x4(Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 uint4x4(Unity.Mathematics.double4x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 transpose(Unity.Mathematics.uint4x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 mul(Unity.Mathematics.uint4x4, Unity.Mathematics.uint4x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 op_LeftShift(Unity.Mathematics.uint4x4, Int32) declare in Unity.Mathematics.uint4x4
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, int32_t p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 op_Multiply(Unity.Mathematics.uint4x4, UInt32) declare in Unity.Mathematics.uint4x4
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 mul(Unity.Mathematics.uint4x3, Unity.Mathematics.uint3x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 mul(Unity.Mathematics.uint4x2, Unity.Mathematics.uint2x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 uint4x4(Unity.Mathematics.uint4, Unity.Mathematics.uint4, Unity.Mathematics.uint4, Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv2);
    S_u4u4u4u4_ p2 = pp2 ? *pp2 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp3 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv3);
    S_u4u4u4u4_ p3 = pp3 ? *pp3 : S_u4u4u4u4_ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, struct S_u4u4u4u4_ p2, struct S_u4u4u4u4_ p3, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 uint4x4(Boolean) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 uint4x4(Int32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 uint4x4(Single) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 uint4x4(Double) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 uint4x4(UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 op_Multiply(UInt32, Unity.Mathematics.uint4x4) declare in Unity.Mathematics.uint4x4
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x4 uint4x4(UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);

    if (checkJSArgument) {
        if (js_args_len != 16) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv11)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv12)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv13)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv14)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv15)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    uint32_t p6 = converter::Converter<uint32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    uint32_t p8 = converter::Converter<uint32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    uint32_t p9 = converter::Converter<uint32_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    uint32_t p10 = converter::Converter<uint32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    uint32_t p11 = converter::Converter<uint32_t>::toCpp(apis, env, _sv11);
    // JSValToCSVal P any
    uint32_t p12 = converter::Converter<uint32_t>::toCpp(apis, env, _sv12);
    // JSValToCSVal P any
    uint32_t p13 = converter::Converter<uint32_t>::toCpp(apis, env, _sv13);
    // JSValToCSVal P any
    uint32_t p14 = converter::Converter<uint32_t>::toCpp(apis, env, _sv14);
    // JSValToCSVal P any
    uint32_t p15 = converter::Converter<uint32_t>::toCpp(apis, env, _sv15);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, uint32_t p6, uint32_t p7, uint32_t p8, uint32_t p9, uint32_t p10, uint32_t p11, uint32_t p12, uint32_t p13, uint32_t p14, uint32_t p15, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 uint4x3(Unity.Mathematics.bool4x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 uint4x3(Unity.Mathematics.int4x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 uint4x3(Unity.Mathematics.float4x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 uint4x3(Unity.Mathematics.double4x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 transpose(Unity.Mathematics.uint3x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 mul(Unity.Mathematics.uint4x4, Unity.Mathematics.uint4x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 op_Increment(Unity.Mathematics.uint4x3) declare in Unity.Mathematics.uint4x3
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 mul(Unity.Mathematics.uint4x3, Unity.Mathematics.uint3x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 op_Multiply(Unity.Mathematics.uint4x3, Unity.Mathematics.uint4x3) declare in Unity.Mathematics.uint4x3
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 op_LeftShift(Unity.Mathematics.uint4x3, Int32) declare in Unity.Mathematics.uint4x3
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, int32_t p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 op_Multiply(Unity.Mathematics.uint4x3, UInt32) declare in Unity.Mathematics.uint4x3
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 mul(Unity.Mathematics.uint4x2, Unity.Mathematics.uint2x3) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 uint4x3(Unity.Mathematics.uint4, Unity.Mathematics.uint4, Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv2);
    S_u4u4u4u4_ p2 = pp2 ? *pp2 : S_u4u4u4u4_ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, struct S_u4u4u4u4_ p2, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 uint4x3(Boolean) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 uint4x3(Int32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 uint4x3(Single) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 uint4x3(Double) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 uint4x3(UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 op_Multiply(UInt32, Unity.Mathematics.uint4x3) declare in Unity.Mathematics.uint4x3
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x3 uint4x3(UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4u4u4u4u4u4u4u4u4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__u4u4u4u4u4u4u4u4u4u4u4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    uint32_t p6 = converter::Converter<uint32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    uint32_t p8 = converter::Converter<uint32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    uint32_t p9 = converter::Converter<uint32_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    uint32_t p10 = converter::Converter<uint32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    uint32_t p11 = converter::Converter<uint32_t>::toCpp(apis, env, _sv11);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, uint32_t p6, uint32_t p7, uint32_t p8, uint32_t p9, uint32_t p10, uint32_t p11, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 uint4x2(Unity.Mathematics.bool4x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 uint4x2(Unity.Mathematics.int4x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 uint4x2(Unity.Mathematics.float4x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 uint4x2(Unity.Mathematics.double4x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 transpose(Unity.Mathematics.uint2x4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 mul(Unity.Mathematics.uint4x4, Unity.Mathematics.uint4x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 mul(Unity.Mathematics.uint4x3, Unity.Mathematics.uint3x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 op_Increment(Unity.Mathematics.uint4x2) declare in Unity.Mathematics.uint4x2
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 mul(Unity.Mathematics.uint4x2, Unity.Mathematics.uint2x2) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 op_Multiply(Unity.Mathematics.uint4x2, Unity.Mathematics.uint4x2) declare in Unity.Mathematics.uint4x2
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 op_LeftShift(Unity.Mathematics.uint4x2, Int32) declare in Unity.Mathematics.uint4x2
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, int32_t p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 op_Multiply(Unity.Mathematics.uint4x2, UInt32) declare in Unity.Mathematics.uint4x2
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_S_u4u4u4u4_S_u4u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, uint32_t p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 uint4x2(Unity.Mathematics.uint4, Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__S_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__S_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 uint4x2(Boolean) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(bool p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 uint4x2(Int32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 uint4x2(Single) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(float p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 uint4x2(Double) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(double p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 uint4x2(UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 op_Multiply(UInt32, Unity.Mathematics.uint4x2) declare in Unity.Mathematics.uint4x2
bool w_S_S_u4u4u4u4_S_u4u4u4u4__u4S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__u4S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(uint32_t p0, struct S_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4x2 uint4x2(UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_S_u4u4u4u4_S_u4u4u4u4__u4u4u4u4u4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_S_u4u4u4u4__u4u4u4u4u4u4u4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    uint32_t p6 = converter::Converter<uint32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);

    typedef struct S_S_u4u4u4u4_S_u4u4u4u4__ (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, uint32_t p6, uint32_t p7, const void* method);
    struct S_S_u4u4u4u4_S_u4u4u4u4__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.ObjectIdentifier get_serializedObject() declare in UnityEditor.Build.Content.ObjectSerializedInfo
bool w_S_S_u4u4u4u4_i8i4s_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_i8i4s_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_u4u4u4u4_i8i4s_ (*FuncToCall)(void*,const void* method);
    struct S_S_u4u4u4u4_i8i4s_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.AI.NavMeshLocation MoveLocation(UnityEngine.Experimental.AI.NavMeshLocation, UnityEngine.Vector3, Int32) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_S_S_u8_S_r4r4r4__tS_S_u8_S_r4r4r4__S_r4r4r4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_S_r4r4r4__tS_S_u8_S_r4r4r4__S_r4r4r4_Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_u8_S_r4r4r4__>(apis, env, _sv0);
    S_S_u8_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_u8_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_S_u8_S_r4r4r4__ (*FuncToCall)(void*,struct S_S_u8_S_r4r4r4__ p0, struct S_r4r4r4_ p1, int32_t p2, const void* method);
    struct S_S_u8_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.AI.NavMeshLocation MapLocation(UnityEngine.Vector3, UnityEngine.Vector3, Int32, Int32) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_S_S_u8_S_r4r4r4__tS_r4r4r4_S_r4r4r4_i4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_S_r4r4r4__tS_r4r4r4_S_r4r4r4_i4Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_S_u8_S_r4r4r4__ (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, int32_t p2, int32_t p3, const void* method);
    struct S_S_u8_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.AI.NavMeshLocation CreateLocation(UnityEngine.Vector3, UnityEngine.Experimental.AI.PolygonId) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_S_S_u8_S_r4r4r4__tS_r4r4r4_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_S_r4r4r4__tS_r4r4r4_S_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};

    typedef struct S_S_u8_S_r4r4r4__ (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_u8_ p1, const void* method);
    struct S_S_u8_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Loading.ContentFileUnloadHandle UnloadAsync() declare in Unity.Loading.ContentFile
bool w_S_S_u8__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_u8__ (*FuncToCall)(void*,const void* method);
    struct S_S_u8__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset get_Now() declare in System.DateTimeOffset
bool w_S_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_u8_i2_ (*FuncToCall)(const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset Parse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTimeOffset
bool w_S_S_u8_i2_S_S_p_i4_DoDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_S_p_i4_DoDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, int32_t p2, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset ParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTimeOffset
bool w_S_S_u8_i2_S_S_p_i4_S_S_p_i4_oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_S_p_i4_S_S_p_i4_oDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset ParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTimeOffset
bool w_S_S_u8_i2_S_S_p_i4_ooDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_S_p_i4_ooDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset op_Addition(System.DateTimeOffset, System.TimeSpan) declare in System.DateTimeOffset
bool w_S_S_u8_i2_S_S_u8_i2_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_S_u8_i2_S_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_S_u8_i2_ p0, struct S_i8_ p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset ConvertTime(System.DateTimeOffset, System.TimeZoneInfo) declare in System.TimeZoneInfo
bool w_S_S_u8_i2_S_S_u8_i2_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_S_u8_i2_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_S_u8_i2_ p0, Il2CppObject* p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset ConvertTimeBySystemTimeZoneId(System.DateTimeOffset, System.String) declare in System.TimeZoneInfo
bool w_S_S_u8_i2_S_S_u8_i2_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_S_u8_i2_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_S_u8_i2_ p0, Il2CppString* p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset op_Implicit(System.DateTime) declare in System.DateTimeOffset
bool w_S_S_u8_i2_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_u8_ p0, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset FromFileTime(Int64) declare in System.DateTimeOffset
bool w_S_S_u8_i2_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u8_i2_ (*FuncToCall)(int64_t p0, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_S_S_u8_i2_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset Parse(System.String) declare in System.DateTimeOffset
bool w_S_S_u8_i2_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset Parse(System.String, System.IFormatProvider) declare in System.DateTimeOffset
bool w_S_S_u8_i2_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset Parse(System.String, System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTimeOffset
bool w_S_S_u8_i2_soi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_soi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, int32_t p2, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset ParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTimeOffset
bool w_S_S_u8_i2_sooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_sooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset ToDateTimeOffset(System.String, System.String) declare in System.Xml.XmlConvert
bool w_S_S_u8_i2_ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset ParseExact(System.String, System.String, System.IFormatProvider) declare in System.DateTimeOffset
bool w_S_S_u8_i2_sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_sso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset ParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTimeOffset
bool w_S_S_u8_i2_ssoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_ssoi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset ToLocalTime() declare in System.DateTimeOffset
bool w_S_S_u8_i2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset Adjust(System.DateTimeOffset) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_S_u8_i2_tS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_tS_S_u8_i2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};

    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,struct S_S_u8_i2_ p0, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset ToOffset(System.TimeSpan) declare in System.DateTimeOffset
bool w_S_S_u8_i2_tS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_tS_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};

    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,struct S_i8_ p0, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset AddMonths(Int32) declare in System.DateTimeOffset
bool w_S_S_u8_i2_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset AddTicks(Int64) declare in System.DateTimeOffset
bool w_S_S_u8_i2_ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_ti8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,int64_t p0, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset AddDays(Double) declare in System.DateTimeOffset
bool w_S_S_u8_i2_tr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_tr8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,double p0, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTimeOffset GetCreationTime(System.String) declare in System.IO.IsolatedStorage.IsolatedStorageFile
bool w_S_S_u8_i2_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.GlobalObjectId GetGlobalObjectIdSlow(Int32) declare in UnityEditor.GlobalObjectId
bool w_S_S_u8u8_S_u4u4u4u4_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8u8_S_u4u4u4u4_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_S_u8u8_S_u4u4u4u4_i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_S_u8u8_S_u4u4u4u4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.GlobalObjectId GetGlobalObjectIdSlow(UnityEngine.Object) declare in UnityEditor.GlobalObjectId
bool w_S_S_u8u8_S_u4u4u4u4_i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8u8_S_u4u4u4u4_i4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_S_u8u8_S_u4u4u4u4_i4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_S_u8u8_S_u4u4u4u4_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.GlobalObjectId get_globalObjectId() declare in UnityEditor.SearchService.ObjectSelectorTargetInfo
bool w_S_S_u8u8_S_u4u4u4u4_i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8u8_S_u4u4u4u4_i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_S_u8u8_S_u4u4u4u4_i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_u8u8_S_u4u4u4u4_i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Experimental.ArtifactID LookupArtifact(UnityEditor.Experimental.ArtifactKey) declare in UnityEditor.Experimental.AssetDatabaseExperimental
bool w_S_S_u8u8__S_S_u4u4u4u4_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8u8__S_S_u4u4u4u4_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_o_* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_o_>(apis, env, _sv0);
    S_S_u4u4u4u4_o_ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_o_ {};

    typedef struct S_S_u8u8__ (*FuncToCall)(struct S_S_u4u4u4u4_o_ p0, const void* method);
    struct S_S_u8u8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ValueTuple Create() declare in System.ValueTuple
bool w_S__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S__ (*FuncToCall)(const void* method);
    struct S__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.GPUFence CreateGPUFence(UnityEngine.Rendering.SynchronisationStage) declare in UnityEngine.Graphics
bool w_S__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S__ (*FuncToCall)(int32_t p0, const void* method);
    struct S__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// YieldAwaiter GetAwaiter() declare in System.Runtime.CompilerServices.YieldAwaitable
bool w_S__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S__ (*FuncToCall)(void*,const void* method);
    struct S__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.GPUFence CreateGPUFence(UnityEngine.Rendering.SynchronisationStage) declare in UnityEngine.Rendering.CommandBuffer
bool w_S__ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S__ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S__ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ParallelLoopResult For(Int32, Int32, System.Action`1[System.Int32]) declare in System.Threading.Tasks.Parallel
bool w_S_bN_bi8__i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bN_bi8__i4i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_bN_bi8__ (*FuncToCall)(int32_t p0, int32_t p1, Il2CppObject* p2, const void* method);
    struct S_bN_bi8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ParallelLoopResult For(Int32, Int32, System.Threading.Tasks.ParallelOptions, System.Action`1[System.Int32]) declare in System.Threading.Tasks.Parallel
bool w_S_bN_bi8__i4i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bN_bi8__i4i4oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef struct S_bN_bi8__ (*FuncToCall)(int32_t p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_bN_bi8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ParallelLoopResult For(Int64, Int64, System.Action`1[System.Int64]) declare in System.Threading.Tasks.Parallel
bool w_S_bN_bi8__i8i8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bN_bi8__i8i8o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_bN_bi8__ (*FuncToCall)(int64_t p0, int64_t p1, Il2CppObject* p2, const void* method);
    struct S_bN_bi8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.Tasks.ParallelLoopResult For(Int64, Int64, System.Threading.Tasks.ParallelOptions, System.Action`1[System.Int64]) declare in System.Threading.Tasks.Parallel
bool w_S_bN_bi8__i8i8oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bN_bi8__i8i8oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef struct S_bN_bi8__ (*FuncToCall)(int64_t p0, int64_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_bN_bi8__ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.SceneManagement.StageHandle GetCurrentStageHandle() declare in UnityEditor.SceneManagement.StageUtility
bool w_S_bS_i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bS_i4__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bS_i4__ (*FuncToCall)(const void* method);
    struct S_bS_i4__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.SceneManagement.StageHandle GetStageHandle(UnityEngine.SceneManagement.Scene) declare in UnityEditor.SceneManagement.StageUtility
bool w_S_bS_i4__S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bS_i4__S_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};

    typedef struct S_bS_i4__ (*FuncToCall)(struct S_i4_ p0, const void* method);
    struct S_bS_i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.SceneManagement.StageHandle GetStageHandle(UnityEngine.GameObject) declare in UnityEditor.SceneManagement.StageUtility
bool w_S_bS_i4__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bS_i4__o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_bS_i4__ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_bS_i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.SceneManagement.StageHandle get_stageHandle() declare in UnityEditor.SceneManagement.PreviewSceneStage
bool w_S_bS_i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bS_i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bS_i4__ (*FuncToCall)(void*,const void* method);
    struct S_bS_i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ValueTuple`2[System.Boolean,System.Boolean] TryReloadAllNullIn(System.Object, System.String) declare in UnityEngine.Rendering.ResourceReloader
bool w_S_bb_Os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_Os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_bb_ (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_Equality(Unity.Mathematics.half2, Unity.Mathematics.half2) declare in Unity.Mathematics.half2
bool w_S_bb_S_S_u2_S_u2__S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_S_u2_S_u2__S_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2__ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_S_u2_S_u2__ p0, struct S_S_u2_S_u2__ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_Equality(Unity.Mathematics.half2, Unity.Mathematics.half) declare in Unity.Mathematics.half2
bool w_S_bb_S_S_u2_S_u2__S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_S_u2_S_u2__S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_S_u2_S_u2__ p0, struct S_u2_ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LogicalNot(Unity.Mathematics.bool2) declare in Unity.Mathematics.bool2
bool w_S_bb_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_bb_ p0, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_Equality(Unity.Mathematics.bool2, Unity.Mathematics.bool2) declare in Unity.Mathematics.bool2
bool w_S_bb_S_bb_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_bb_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_bb_ p0, struct S_bb_ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 shuffle(Unity.Mathematics.bool2, Unity.Mathematics.bool2, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_bb_S_bb_S_bb_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_bb_S_bb_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_bb_ (*FuncToCall)(struct S_bb_ p0, struct S_bb_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_Equality(Unity.Mathematics.bool2, Boolean) declare in Unity.Mathematics.bool2
bool w_S_bb_S_bb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_bb_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_bb_ (*FuncToCall)(struct S_bb_ p0, bool p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 shuffle(Unity.Mathematics.bool3, Unity.Mathematics.bool3, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_bb_S_bbb_S_bbb_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_bbb_S_bbb_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_bb_ (*FuncToCall)(struct S_bbb_ p0, struct S_bbb_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 shuffle(Unity.Mathematics.bool4, Unity.Mathematics.bool4, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_bb_S_bbbb_S_bbbb_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_bbbb_S_bbbb_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp1 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv1);
    S_bbbb_ p1 = pp1 ? *pp1 : S_bbbb_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_bb_ (*FuncToCall)(struct S_bbbb_ p0, struct S_bbbb_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 ispow2(Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_bb_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_i4i4_ p0, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LessThan(Unity.Mathematics.int2, Unity.Mathematics.int2) declare in Unity.Mathematics.int2
bool w_S_bb_S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LessThan(Unity.Mathematics.int2, Int32) declare in Unity.Mathematics.int2
bool w_S_bb_S_i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_bb_ (*FuncToCall)(struct S_i4i4_ p0, int32_t p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 isfinite(Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_S_bb_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LessThan(Unity.Mathematics.float2, Unity.Mathematics.float2) declare in Unity.Mathematics.float2
bool w_S_bb_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LessThan(Unity.Mathematics.float2, Single) declare in Unity.Mathematics.float2
bool w_S_bb_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_bb_ (*FuncToCall)(struct S_r4r4_ p0, float p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 isfinite(Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_bb_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_r8r8_ p0, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LessThan(Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.double2
bool w_S_bb_S_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_r8r8_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LessThan(Unity.Mathematics.double2, Double) declare in Unity.Mathematics.double2
bool w_S_bb_S_r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_bb_ (*FuncToCall)(struct S_r8r8_ p0, double p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_Equality(Unity.Mathematics.half, Unity.Mathematics.half2) declare in Unity.Mathematics.half2
bool w_S_bb_S_u2_S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_u2_S_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2__ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_u2_ p0, struct S_S_u2_S_u2__ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 ispow2(Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_bb_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_u4u4_ p0, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LessThan(Unity.Mathematics.uint2, Unity.Mathematics.uint2) declare in Unity.Mathematics.uint2
bool w_S_bb_S_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_u4u4_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef struct S_bb_ (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LessThan(Unity.Mathematics.uint2, UInt32) declare in Unity.Mathematics.uint2
bool w_S_bb_S_u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_S_u4u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_bb_ (*FuncToCall)(struct S_u4u4_ p0, uint32_t p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_Implicit(Boolean) declare in Unity.Mathematics.bool2
bool w_S_bb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_bb_ (*FuncToCall)(bool p0, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_Equality(Boolean, Unity.Mathematics.bool2) declare in Unity.Mathematics.bool2
bool w_S_bb_bS_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_bS_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};

    typedef struct S_bb_ (*FuncToCall)(bool p0, struct S_bb_ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 bool2(Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_bb_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_bb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_bb_ (*FuncToCall)(bool p0, bool p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LessThan(Int32, Unity.Mathematics.int2) declare in Unity.Mathematics.int2
bool w_S_bb_i4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_i4S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_bb_ (*FuncToCall)(int32_t p0, struct S_i4i4_ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LessThan(Single, Unity.Mathematics.float2) declare in Unity.Mathematics.float2
bool w_S_bb_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef struct S_bb_ (*FuncToCall)(float p0, struct S_r4r4_ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LessThan(Double, Unity.Mathematics.double2) declare in Unity.Mathematics.double2
bool w_S_bb_r8S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_r8S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef struct S_bb_ (*FuncToCall)(double p0, struct S_r8r8_ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 get_xx() declare in Unity.Mathematics.bool2
bool w_S_bb_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bb_ (*FuncToCall)(void*,const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool2 op_LessThan(UInt32, Unity.Mathematics.uint2) declare in Unity.Mathematics.uint2
bool w_S_bb_u4S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bb_u4S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef struct S_bb_ (*FuncToCall)(uint32_t p0, struct S_u4u4_ p1, const void* method);
    struct S_bb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_Equality(Unity.Mathematics.half3, Unity.Mathematics.half3) declare in Unity.Mathematics.half3
bool w_S_bbb_S_S_u2_S_u2_S_u2__S_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_S_u2_S_u2_S_u2__S_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2_S_u2__ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_S_u2_S_u2_S_u2__ p0, struct S_S_u2_S_u2_S_u2__ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_Equality(Unity.Mathematics.half3, Unity.Mathematics.half) declare in Unity.Mathematics.half3
bool w_S_bbb_S_S_u2_S_u2_S_u2__S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_S_u2_S_u2_S_u2__S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_S_u2_S_u2_S_u2__ p0, struct S_u2_ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 shuffle(Unity.Mathematics.bool2, Unity.Mathematics.bool2, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_bbb_S_bb_S_bb_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_bb_S_bb_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_bbb_ (*FuncToCall)(struct S_bb_ p0, struct S_bb_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 bool3(Unity.Mathematics.bool2, Boolean) declare in Unity.Mathematics.math
bool w_S_bbb_S_bb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_bb_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_bbb_ (*FuncToCall)(struct S_bb_ p0, bool p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 bool3(Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_bbb_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_bbb_ p0, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_Equality(Unity.Mathematics.bool3, Unity.Mathematics.bool3) declare in Unity.Mathematics.bool3
bool w_S_bbb_S_bbb_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_bbb_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_bbb_ p0, struct S_bbb_ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 shuffle(Unity.Mathematics.bool3, Unity.Mathematics.bool3, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_bbb_S_bbb_S_bbb_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_bbb_S_bbb_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_bbb_ (*FuncToCall)(struct S_bbb_ p0, struct S_bbb_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_Equality(Unity.Mathematics.bool3, Boolean) declare in Unity.Mathematics.bool3
bool w_S_bbb_S_bbb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_bbb_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_bbb_ (*FuncToCall)(struct S_bbb_ p0, bool p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 shuffle(Unity.Mathematics.bool4, Unity.Mathematics.bool4, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_bbb_S_bbbb_S_bbbb_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_bbbb_S_bbbb_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp1 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv1);
    S_bbbb_ p1 = pp1 ? *pp1 : S_bbbb_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_bbb_ (*FuncToCall)(struct S_bbbb_ p0, struct S_bbbb_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 ispow2(Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_S_bbb_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_i4i4i4_ p0, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_LessThan(Unity.Mathematics.int3, Unity.Mathematics.int3) declare in Unity.Mathematics.int3
bool w_S_bbb_S_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_i4i4i4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_LessThan(Unity.Mathematics.int3, Int32) declare in Unity.Mathematics.int3
bool w_S_bbb_S_i4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_i4i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_bbb_ (*FuncToCall)(struct S_i4i4i4_ p0, int32_t p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 isfinite(Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_S_bbb_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_LessThan(Unity.Mathematics.float3, Unity.Mathematics.float3) declare in Unity.Mathematics.float3
bool w_S_bbb_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_LessThan(Unity.Mathematics.float3, Single) declare in Unity.Mathematics.float3
bool w_S_bbb_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_bbb_ (*FuncToCall)(struct S_r4r4r4_ p0, float p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 isfinite(Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_bbb_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_r8r8r8_ p0, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_LessThan(Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.double3
bool w_S_bbb_S_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_r8r8r8_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_LessThan(Unity.Mathematics.double3, Double) declare in Unity.Mathematics.double3
bool w_S_bbb_S_r8r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_r8r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_bbb_ (*FuncToCall)(struct S_r8r8r8_ p0, double p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_Equality(Unity.Mathematics.half, Unity.Mathematics.half3) declare in Unity.Mathematics.half3
bool w_S_bbb_S_u2_S_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_u2_S_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2_S_u2__ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_u2_ p0, struct S_S_u2_S_u2_S_u2__ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 ispow2(Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_bbb_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_u4u4u4_ p0, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_LessThan(Unity.Mathematics.uint3, Unity.Mathematics.uint3) declare in Unity.Mathematics.uint3
bool w_S_bbb_S_u4u4u4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_u4u4u4_S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};

    typedef struct S_bbb_ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_LessThan(Unity.Mathematics.uint3, UInt32) declare in Unity.Mathematics.uint3
bool w_S_bbb_S_u4u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_S_u4u4u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_bbb_ (*FuncToCall)(struct S_u4u4u4_ p0, uint32_t p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 bool3(Boolean) declare in Unity.Mathematics.math
bool w_S_bbb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_bbb_ (*FuncToCall)(bool p0, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 bool3(Boolean, Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_bbb_bS_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_bS_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};

    typedef struct S_bbb_ (*FuncToCall)(bool p0, struct S_bb_ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_Equality(Boolean, Unity.Mathematics.bool3) declare in Unity.Mathematics.bool3
bool w_S_bbb_bS_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_bS_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};

    typedef struct S_bbb_ (*FuncToCall)(bool p0, struct S_bbb_ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 bool3(Boolean, Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_bbb_bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_bbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_bbb_ (*FuncToCall)(bool p0, bool p1, bool p2, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_LessThan(Int32, Unity.Mathematics.int3) declare in Unity.Mathematics.int3
bool w_S_bbb_i4S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_i4S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef struct S_bbb_ (*FuncToCall)(int32_t p0, struct S_i4i4i4_ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_LessThan(Single, Unity.Mathematics.float3) declare in Unity.Mathematics.float3
bool w_S_bbb_r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_r4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef struct S_bbb_ (*FuncToCall)(float p0, struct S_r4r4r4_ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_LessThan(Double, Unity.Mathematics.double3) declare in Unity.Mathematics.double3
bool w_S_bbb_r8S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_r8S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef struct S_bbb_ (*FuncToCall)(double p0, struct S_r8r8r8_ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 get_xxx() declare in Unity.Mathematics.bool2
bool w_S_bbb_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bbb_ (*FuncToCall)(void*,const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool3 op_LessThan(UInt32, Unity.Mathematics.uint3) declare in Unity.Mathematics.uint3
bool w_S_bbb_u4S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbb_u4S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};

    typedef struct S_bbb_ (*FuncToCall)(uint32_t p0, struct S_u4u4u4_ p1, const void* method);
    struct S_bbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_Equality(Unity.Mathematics.half4, Unity.Mathematics.half4) declare in Unity.Mathematics.half4
bool w_S_bbbb_S_S_u2_S_u2_S_u2_S_u2__S_S_u2_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_S_u2_S_u2_S_u2_S_u2__S_S_u2_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2_S_u2_S_u2__ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_S_u2_S_u2_S_u2_S_u2__ p0, struct S_S_u2_S_u2_S_u2_S_u2__ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_Equality(Unity.Mathematics.half4, Unity.Mathematics.half) declare in Unity.Mathematics.half4
bool w_S_bbbb_S_S_u2_S_u2_S_u2_S_u2__S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_S_u2_S_u2_S_u2_S_u2__S_u2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_S_u2_S_u2_S_u2_S_u2__ p0, struct S_u2_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 bool4(Unity.Mathematics.bool2, Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_bbbb_S_bb_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_bb_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_bb_ p0, struct S_bb_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 shuffle(Unity.Mathematics.bool2, Unity.Mathematics.bool2, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_bbbb_S_bb_S_bb_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_bb_S_bb_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_bbbb_ (*FuncToCall)(struct S_bb_ p0, struct S_bb_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 bool4(Unity.Mathematics.bool2, Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_bbbb_S_bb_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_bb_bb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_bbbb_ (*FuncToCall)(struct S_bb_ p0, bool p1, bool p2, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 shuffle(Unity.Mathematics.bool3, Unity.Mathematics.bool3, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_bbbb_S_bbb_S_bbb_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_bbb_S_bbb_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_bbbb_ (*FuncToCall)(struct S_bbb_ p0, struct S_bbb_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 bool4(Unity.Mathematics.bool3, Boolean) declare in Unity.Mathematics.math
bool w_S_bbbb_S_bbb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_bbb_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_bbbb_ (*FuncToCall)(struct S_bbb_ p0, bool p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 bool4(Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_S_bbbb_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_bbbb_ p0, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_Equality(Unity.Mathematics.bool4, Unity.Mathematics.bool4) declare in Unity.Mathematics.bool4
bool w_S_bbbb_S_bbbb_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_bbbb_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp1 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv1);
    S_bbbb_ p1 = pp1 ? *pp1 : S_bbbb_ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_bbbb_ p0, struct S_bbbb_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 shuffle(Unity.Mathematics.bool4, Unity.Mathematics.bool4, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_bbbb_S_bbbb_S_bbbb_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_bbbb_S_bbbb_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp1 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv1);
    S_bbbb_ p1 = pp1 ? *pp1 : S_bbbb_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_bbbb_ (*FuncToCall)(struct S_bbbb_ p0, struct S_bbbb_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_Equality(Unity.Mathematics.bool4, Boolean) declare in Unity.Mathematics.bool4
bool w_S_bbbb_S_bbbb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_bbbb_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef struct S_bbbb_ (*FuncToCall)(struct S_bbbb_ p0, bool p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 ispow2(Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_bbbb_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_i4i4i4i4_ p0, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_LessThan(Unity.Mathematics.int4, Unity.Mathematics.int4) declare in Unity.Mathematics.int4
bool w_S_bbbb_S_i4i4i4i4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_LessThan(Unity.Mathematics.int4, Int32) declare in Unity.Mathematics.int4
bool w_S_bbbb_S_i4i4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_i4i4i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_bbbb_ (*FuncToCall)(struct S_i4i4i4i4_ p0, int32_t p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 isfinite(Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_bbbb_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_LessThan(Unity.Mathematics.float4, Unity.Mathematics.float4) declare in Unity.Mathematics.float4
bool w_S_bbbb_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_LessThan(Unity.Mathematics.float4, Single) declare in Unity.Mathematics.float4
bool w_S_bbbb_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef struct S_bbbb_ (*FuncToCall)(struct S_r4r4r4r4_ p0, float p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 isfinite(Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_bbbb_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_r8r8r8r8_ p0, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_LessThan(Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.double4
bool w_S_bbbb_S_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_LessThan(Unity.Mathematics.double4, Double) declare in Unity.Mathematics.double4
bool w_S_bbbb_S_r8r8r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_r8r8r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_bbbb_ (*FuncToCall)(struct S_r8r8r8r8_ p0, double p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_Equality(Unity.Mathematics.half, Unity.Mathematics.half4) declare in Unity.Mathematics.half4
bool w_S_bbbb_S_u2_S_S_u2_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_u2_S_S_u2_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2_S_u2_S_u2__ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_u2_ p0, struct S_S_u2_S_u2_S_u2_S_u2__ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 ispow2(Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_bbbb_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_u4u4u4u4_ p0, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_LessThan(Unity.Mathematics.uint4, Unity.Mathematics.uint4) declare in Unity.Mathematics.uint4
bool w_S_bbbb_S_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};

    typedef struct S_bbbb_ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_LessThan(Unity.Mathematics.uint4, UInt32) declare in Unity.Mathematics.uint4
bool w_S_bbbb_S_u4u4u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_S_u4u4u4u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_bbbb_ (*FuncToCall)(struct S_u4u4u4u4_ p0, uint32_t p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 bool4(Boolean) declare in Unity.Mathematics.math
bool w_S_bbbb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_bbbb_ (*FuncToCall)(bool p0, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 bool4(Boolean, Unity.Mathematics.bool2, Boolean) declare in Unity.Mathematics.math
bool w_S_bbbb_bS_bb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_bS_bb_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_bbbb_ (*FuncToCall)(bool p0, struct S_bb_ p1, bool p2, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 bool4(Boolean, Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_bbbb_bS_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_bS_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};

    typedef struct S_bbbb_ (*FuncToCall)(bool p0, struct S_bbb_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_Equality(Boolean, Unity.Mathematics.bool4) declare in Unity.Mathematics.bool4
bool w_S_bbbb_bS_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_bS_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bbbb_* pp1 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv1);
    S_bbbb_ p1 = pp1 ? *pp1 : S_bbbb_ {};

    typedef struct S_bbbb_ (*FuncToCall)(bool p0, struct S_bbbb_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 bool4(Boolean, Boolean, Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_bbbb_bbS_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_bbS_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_bb_* pp2 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv2);
    S_bb_ p2 = pp2 ? *pp2 : S_bb_ {};

    typedef struct S_bbbb_ (*FuncToCall)(bool p0, bool p1, struct S_bb_ p2, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 bool4(Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.math
bool w_S_bbbb_bbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_bbbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef struct S_bbbb_ (*FuncToCall)(bool p0, bool p1, bool p2, bool p3, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_LessThan(Int32, Unity.Mathematics.int4) declare in Unity.Mathematics.int4
bool w_S_bbbb_i4S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_i4S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};

    typedef struct S_bbbb_ (*FuncToCall)(int32_t p0, struct S_i4i4i4i4_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_LessThan(Single, Unity.Mathematics.float4) declare in Unity.Mathematics.float4
bool w_S_bbbb_r4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_r4S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef struct S_bbbb_ (*FuncToCall)(float p0, struct S_r4r4r4r4_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_LessThan(Double, Unity.Mathematics.double4) declare in Unity.Mathematics.double4
bool w_S_bbbb_r8S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_r8S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};

    typedef struct S_bbbb_ (*FuncToCall)(double p0, struct S_r8r8r8r8_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 get_xxxx() declare in Unity.Mathematics.bool2
bool w_S_bbbb_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bbbb_ (*FuncToCall)(void*,const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.bool4 op_LessThan(UInt32, Unity.Mathematics.uint4) declare in Unity.Mathematics.uint4
bool w_S_bbbb_u4S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_u4S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};

    typedef struct S_bbbb_ (*FuncToCall)(uint32_t p0, struct S_u4u4u4u4_ p1, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.ContactFilter2D NoFilter() declare in UnityEngine.ContactFilter2D
bool w_S_bbbbbbS_i4_r4r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbbbbS_i4_r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bbbbbbS_i4_r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_bbbbbbS_i4_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Rendering.PlatformShaderSettings GetShaderSettingsForPlatform(UnityEditor.BuildTargetGroup, UnityEngine.Rendering.ShaderHardwareTier) declare in UnityEditor.Rendering.EditorGraphicsSettings
bool w_S_bbbi4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbi4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_bbbi4_ (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    struct S_bbbi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.GlobalDynamicResolutionSettings NewDefault() declare in UnityEngine.Rendering.GlobalDynamicResolutionSettings
bool w_S_bbbu4i4br4br4r4r4u1u1br4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbu4i4br4br4r4r4u1u1br4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bbbu4i4br4br4r4r4u1u1br4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct S_bbbu4i4br4br4r4r4u1u1br4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.PhysicsJobOptions2D get_jobOptions() declare in UnityEngine.Physics2D
bool w_S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(const void* method);
    struct S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// CurveState GetCurveState(UnityEditor.SerializedProperty) declare in UnityEditor.Rendering.InspectorCurveEditor
bool w_S_bbu4r4S_r4r4r4r4_r4r4bbb_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbu4r4S_r4r4r4r4_r4r4bbb_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_bbu4r4S_r4r4r4r4_r4r4bbb_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_bbu4r4S_r4r4r4r4_r4r4bbb_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 op_UnaryNegation(System.Data.SqlTypes.SqlInt16) declare in System.Data.SqlTypes.SqlInt16
bool w_S_bi2_S_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_S_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};

    typedef struct S_bi2_ (*FuncToCall)(struct S_bi2_ p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 op_Addition(System.Data.SqlTypes.SqlInt16, System.Data.SqlTypes.SqlInt16) declare in System.Data.SqlTypes.SqlInt16
bool w_S_bi2_S_bi2_S_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_S_bi2_S_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};
    // JSValToCSVal struct
    S_bi2_* pp1 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv1);
    S_bi2_ p1 = pp1 ? *pp1 : S_bi2_ {};

    typedef struct S_bi2_ (*FuncToCall)(struct S_bi2_ p0, struct S_bi2_ p1, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 op_Explicit(System.Data.SqlTypes.SqlInt32) declare in System.Data.SqlTypes.SqlInt16
bool w_S_bi2_S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_S_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};

    typedef struct S_bi2_ (*FuncToCall)(struct S_bi4_ p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 op_Explicit(System.Data.SqlTypes.SqlInt64) declare in System.Data.SqlTypes.SqlInt16
bool w_S_bi2_S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_S_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef struct S_bi2_ (*FuncToCall)(struct S_bi8_ p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 op_Explicit(System.Data.SqlTypes.SqlSingle) declare in System.Data.SqlTypes.SqlInt16
bool w_S_bi2_S_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_S_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};

    typedef struct S_bi2_ (*FuncToCall)(struct S_br4_ p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 op_Explicit(System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlInt16
bool w_S_bi2_S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_S_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};

    typedef struct S_bi2_ (*FuncToCall)(struct S_br8_ p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 op_Implicit(System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlInt16
bool w_S_bi2_S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_S_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};

    typedef struct S_bi2_ (*FuncToCall)(struct S_bu1_ p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 op_Explicit(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlInt16
bool w_S_bi2_S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_S_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef struct S_bi2_ (*FuncToCall)(struct S_soi4i4b_ p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 op_Explicit(System.Data.SqlTypes.SqlBoolean) declare in System.Data.SqlTypes.SqlInt16
bool w_S_bi2_S_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_S_u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef struct S_bi2_ (*FuncToCall)(struct S_u1_ p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 op_Explicit(System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlInt16
bool w_S_bi2_S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_S_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_bi2_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 op_Implicit(Int16) declare in System.Data.SqlTypes.SqlInt16
bool w_S_bi2_i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_i2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef struct S_bi2_ (*FuncToCall)(int16_t p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 Parse(System.String) declare in System.Data.SqlTypes.SqlInt16
bool w_S_bi2_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_bi2_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 ToSqlInt16() declare in System.Data.SqlTypes.SqlBoolean
bool w_S_bi2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bi2_ (*FuncToCall)(void*,const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 Adjust(System.Data.SqlTypes.SqlInt16) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_bi2_tS_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_tS_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};

    typedef struct S_bi2_ (*FuncToCall)(void*,struct S_bi2_ p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt16 GetSqlInt16(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_bi2_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi2_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_bi2_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_bi2_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 op_Implicit(System.Data.SqlTypes.SqlInt16) declare in System.Data.SqlTypes.SqlInt32
bool w_S_bi4_S_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_S_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};

    typedef struct S_bi4_ (*FuncToCall)(struct S_bi2_ p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 op_UnaryNegation(System.Data.SqlTypes.SqlInt32) declare in System.Data.SqlTypes.SqlInt32
bool w_S_bi4_S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_S_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};

    typedef struct S_bi4_ (*FuncToCall)(struct S_bi4_ p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 op_Addition(System.Data.SqlTypes.SqlInt32, System.Data.SqlTypes.SqlInt32) declare in System.Data.SqlTypes.SqlInt32
bool w_S_bi4_S_bi4_S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_S_bi4_S_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};
    // JSValToCSVal struct
    S_bi4_* pp1 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv1);
    S_bi4_ p1 = pp1 ? *pp1 : S_bi4_ {};

    typedef struct S_bi4_ (*FuncToCall)(struct S_bi4_ p0, struct S_bi4_ p1, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 op_Explicit(System.Data.SqlTypes.SqlInt64) declare in System.Data.SqlTypes.SqlInt32
bool w_S_bi4_S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_S_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef struct S_bi4_ (*FuncToCall)(struct S_bi8_ p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 op_Explicit(System.Data.SqlTypes.SqlSingle) declare in System.Data.SqlTypes.SqlInt32
bool w_S_bi4_S_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_S_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};

    typedef struct S_bi4_ (*FuncToCall)(struct S_br4_ p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 op_Explicit(System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlInt32
bool w_S_bi4_S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_S_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};

    typedef struct S_bi4_ (*FuncToCall)(struct S_br8_ p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 op_Implicit(System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlInt32
bool w_S_bi4_S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_S_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};

    typedef struct S_bi4_ (*FuncToCall)(struct S_bu1_ p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 op_Explicit(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlInt32
bool w_S_bi4_S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_S_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef struct S_bi4_ (*FuncToCall)(struct S_soi4i4b_ p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 op_Explicit(System.Data.SqlTypes.SqlBoolean) declare in System.Data.SqlTypes.SqlInt32
bool w_S_bi4_S_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_S_u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef struct S_bi4_ (*FuncToCall)(struct S_u1_ p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 Sign(System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_bi4_S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_S_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_bi4_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 op_Implicit(Int32) declare in System.Data.SqlTypes.SqlInt32
bool w_S_bi4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_bi4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 Parse(System.String) declare in System.Data.SqlTypes.SqlInt32
bool w_S_bi4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_bi4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 ToSqlInt32() declare in System.Data.SqlTypes.SqlBoolean
bool w_S_bi4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bi4_ (*FuncToCall)(void*,const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.RendererListHandle UseRendererList(UnityEngine.Experimental.Rendering.RenderGraphModule.RendererListHandle ByRef) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraphBuilder
bool w_S_bi4_tPS_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_tPS_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_bi4_* p0 = DataTransfer::GetPointer<S_bi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_bi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_bi4_));
        p0 = &up0;
    }
        

    typedef struct S_bi4_ (*FuncToCall)(void*,struct S_bi4_* p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.RendererListHandle CreateRendererList(UnityEngine.Rendering.RendererUtils.RendererListDesc ByRef) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_S_bi4_tPS_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_tPS_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_* p0 = DataTransfer::GetPointer<S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_));
        p0 = &up0;
    }
        

    typedef struct S_bi4_ (*FuncToCall)(void*,struct S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobi4u4i4i4S_pPvS_pi4i4__oS_i4_o_* p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 Adjust(System.Data.SqlTypes.SqlInt32) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_bi4_tS_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_tS_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};

    typedef struct S_bi4_ (*FuncToCall)(void*,struct S_bi4_ p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt32 GetSqlInt32(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_bi4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_bi4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_bi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDateTime op_Addition(System.Data.SqlTypes.SqlDateTime, System.TimeSpan) declare in System.Data.SqlTypes.SqlDateTime
bool w_S_bi4i4_S_bi4i4_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4i4_S_bi4i4_S_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4i4_* pp0 = DataTransfer::GetPointer<S_bi4i4_>(apis, env, _sv0);
    S_bi4i4_ p0 = pp0 ? *pp0 : S_bi4i4_ {};
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef struct S_bi4i4_ (*FuncToCall)(struct S_bi4i4_ p0, struct S_i8_ p1, const void* method);
    struct S_bi4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDateTime op_Explicit(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlDateTime
bool w_S_bi4i4_S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4i4_S_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef struct S_bi4i4_ (*FuncToCall)(struct S_soi4i4b_ p0, const void* method);
    struct S_bi4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDateTime op_Implicit(System.DateTime) declare in System.Data.SqlTypes.SqlDateTime
bool w_S_bi4i4_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4i4_S_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef struct S_bi4i4_ (*FuncToCall)(struct S_u8_ p0, const void* method);
    struct S_bi4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDateTime Parse(System.String) declare in System.Data.SqlTypes.SqlDateTime
bool w_S_bi4i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4i4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_bi4i4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_bi4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDateTime ToSqlDateTime() declare in System.Data.SqlTypes.SqlString
bool w_S_bi4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bi4i4_ (*FuncToCall)(void*,const void* method);
    struct S_bi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDateTime Adjust(System.Data.SqlTypes.SqlDateTime) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_bi4i4_tS_bi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4i4_tS_bi4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4i4_* pp0 = DataTransfer::GetPointer<S_bi4i4_>(apis, env, _sv0);
    S_bi4i4_ p0 = pp0 ? *pp0 : S_bi4i4_ {};

    typedef struct S_bi4i4_ (*FuncToCall)(void*,struct S_bi4i4_ p0, const void* method);
    struct S_bi4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDateTime GetSqlDateTime(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_bi4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_bi4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_bi4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 op_Implicit(System.Data.SqlTypes.SqlInt16) declare in System.Data.SqlTypes.SqlInt64
bool w_S_bi8_S_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_S_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};

    typedef struct S_bi8_ (*FuncToCall)(struct S_bi2_ p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 op_Implicit(System.Data.SqlTypes.SqlInt32) declare in System.Data.SqlTypes.SqlInt64
bool w_S_bi8_S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_S_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};

    typedef struct S_bi8_ (*FuncToCall)(struct S_bi4_ p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 op_UnaryNegation(System.Data.SqlTypes.SqlInt64) declare in System.Data.SqlTypes.SqlInt64
bool w_S_bi8_S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_S_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef struct S_bi8_ (*FuncToCall)(struct S_bi8_ p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 op_Addition(System.Data.SqlTypes.SqlInt64, System.Data.SqlTypes.SqlInt64) declare in System.Data.SqlTypes.SqlInt64
bool w_S_bi8_S_bi8_S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_S_bi8_S_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};
    // JSValToCSVal struct
    S_bi8_* pp1 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv1);
    S_bi8_ p1 = pp1 ? *pp1 : S_bi8_ {};

    typedef struct S_bi8_ (*FuncToCall)(struct S_bi8_ p0, struct S_bi8_ p1, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 op_Explicit(System.Data.SqlTypes.SqlSingle) declare in System.Data.SqlTypes.SqlInt64
bool w_S_bi8_S_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_S_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};

    typedef struct S_bi8_ (*FuncToCall)(struct S_br4_ p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 op_Explicit(System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlInt64
bool w_S_bi8_S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_S_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};

    typedef struct S_bi8_ (*FuncToCall)(struct S_br8_ p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 op_Implicit(System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlInt64
bool w_S_bi8_S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_S_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};

    typedef struct S_bi8_ (*FuncToCall)(struct S_bu1_ p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlMoney op_Implicit(System.Decimal) declare in System.Data.SqlTypes.SqlMoney
bool w_S_bi8_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef struct S_bi8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 op_Explicit(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlInt64
bool w_S_bi8_S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_S_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef struct S_bi8_ (*FuncToCall)(struct S_soi4i4b_ p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 op_Explicit(System.Data.SqlTypes.SqlBoolean) declare in System.Data.SqlTypes.SqlInt64
bool w_S_bi8_S_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_S_u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef struct S_bi8_ (*FuncToCall)(struct S_u1_ p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 op_Explicit(System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlInt64
bool w_S_bi8_S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_S_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_bi8_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 op_Implicit(Int64) declare in System.Data.SqlTypes.SqlInt64
bool w_S_bi8_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef struct S_bi8_ (*FuncToCall)(int64_t p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlMoney op_Explicit(Double) declare in System.Data.SqlTypes.SqlMoney
bool w_S_bi8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_bi8_ (*FuncToCall)(double p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 Parse(System.String) declare in System.Data.SqlTypes.SqlInt64
bool w_S_bi8_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_bi8_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 ToSqlInt64() declare in System.Data.SqlTypes.SqlBoolean
bool w_S_bi8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bi8_ (*FuncToCall)(void*,const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 Adjust(System.Data.SqlTypes.SqlInt64) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_bi8_tS_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_tS_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef struct S_bi8_ (*FuncToCall)(void*,struct S_bi8_ p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlInt64 GetSqlInt64(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_bi8_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bi8_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_bi8_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_bi8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.AsyncFlowControl SuppressFlow() declare in System.Threading.ExecutionContext
bool w_S_boo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_boo_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_boo_ (*FuncToCall)(const void* method);
    struct S_boo_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle op_Implicit(System.Data.SqlTypes.SqlInt16) declare in System.Data.SqlTypes.SqlSingle
bool w_S_br4_S_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_S_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};

    typedef struct S_br4_ (*FuncToCall)(struct S_bi2_ p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle op_Implicit(System.Data.SqlTypes.SqlInt32) declare in System.Data.SqlTypes.SqlSingle
bool w_S_br4_S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_S_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};

    typedef struct S_br4_ (*FuncToCall)(struct S_bi4_ p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle op_Implicit(System.Data.SqlTypes.SqlInt64) declare in System.Data.SqlTypes.SqlSingle
bool w_S_br4_S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_S_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef struct S_br4_ (*FuncToCall)(struct S_bi8_ p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle op_UnaryNegation(System.Data.SqlTypes.SqlSingle) declare in System.Data.SqlTypes.SqlSingle
bool w_S_br4_S_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_S_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};

    typedef struct S_br4_ (*FuncToCall)(struct S_br4_ p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle op_Addition(System.Data.SqlTypes.SqlSingle, System.Data.SqlTypes.SqlSingle) declare in System.Data.SqlTypes.SqlSingle
bool w_S_br4_S_br4_S_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_S_br4_S_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};
    // JSValToCSVal struct
    S_br4_* pp1 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv1);
    S_br4_ p1 = pp1 ? *pp1 : S_br4_ {};

    typedef struct S_br4_ (*FuncToCall)(struct S_br4_ p0, struct S_br4_ p1, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle op_Explicit(System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlSingle
bool w_S_br4_S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_S_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};

    typedef struct S_br4_ (*FuncToCall)(struct S_br8_ p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle op_Implicit(System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlSingle
bool w_S_br4_S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_S_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};

    typedef struct S_br4_ (*FuncToCall)(struct S_bu1_ p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle op_Explicit(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlSingle
bool w_S_br4_S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_S_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef struct S_br4_ (*FuncToCall)(struct S_soi4i4b_ p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle op_Explicit(System.Data.SqlTypes.SqlBoolean) declare in System.Data.SqlTypes.SqlSingle
bool w_S_br4_S_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_S_u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef struct S_br4_ (*FuncToCall)(struct S_u1_ p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle op_Implicit(System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlSingle
bool w_S_br4_S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_S_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_br4_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle op_Implicit(Single) declare in System.Data.SqlTypes.SqlSingle
bool w_S_br4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_br4_ (*FuncToCall)(float p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle Parse(System.String) declare in System.Data.SqlTypes.SqlSingle
bool w_S_br4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_br4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle ToSqlSingle() declare in System.Data.SqlTypes.SqlBoolean
bool w_S_br4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_br4_ (*FuncToCall)(void*,const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle Adjust(System.Data.SqlTypes.SqlSingle) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_br4_tS_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_tS_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};

    typedef struct S_br4_ (*FuncToCall)(void*,struct S_br4_ p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlSingle GetSqlSingle(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_br4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_br4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_br4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble op_Implicit(System.Data.SqlTypes.SqlInt16) declare in System.Data.SqlTypes.SqlDouble
bool w_S_br8_S_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_S_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};

    typedef struct S_br8_ (*FuncToCall)(struct S_bi2_ p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble op_Implicit(System.Data.SqlTypes.SqlInt32) declare in System.Data.SqlTypes.SqlDouble
bool w_S_br8_S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_S_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};

    typedef struct S_br8_ (*FuncToCall)(struct S_bi4_ p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble op_Implicit(System.Data.SqlTypes.SqlInt64) declare in System.Data.SqlTypes.SqlDouble
bool w_S_br8_S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_S_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef struct S_br8_ (*FuncToCall)(struct S_bi8_ p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble op_Implicit(System.Data.SqlTypes.SqlSingle) declare in System.Data.SqlTypes.SqlDouble
bool w_S_br8_S_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_S_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};

    typedef struct S_br8_ (*FuncToCall)(struct S_br4_ p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble op_UnaryNegation(System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlDouble
bool w_S_br8_S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_S_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};

    typedef struct S_br8_ (*FuncToCall)(struct S_br8_ p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble op_Addition(System.Data.SqlTypes.SqlDouble, System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlDouble
bool w_S_br8_S_br8_S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_S_br8_S_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};
    // JSValToCSVal struct
    S_br8_* pp1 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv1);
    S_br8_ p1 = pp1 ? *pp1 : S_br8_ {};

    typedef struct S_br8_ (*FuncToCall)(struct S_br8_ p0, struct S_br8_ p1, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble op_Implicit(System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlDouble
bool w_S_br8_S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_S_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};

    typedef struct S_br8_ (*FuncToCall)(struct S_bu1_ p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble op_Explicit(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlDouble
bool w_S_br8_S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_S_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef struct S_br8_ (*FuncToCall)(struct S_soi4i4b_ p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble op_Explicit(System.Data.SqlTypes.SqlBoolean) declare in System.Data.SqlTypes.SqlDouble
bool w_S_br8_S_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_S_u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef struct S_br8_ (*FuncToCall)(struct S_u1_ p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble op_Implicit(System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlDouble
bool w_S_br8_S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_S_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_br8_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble op_Implicit(Double) declare in System.Data.SqlTypes.SqlDouble
bool w_S_br8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_br8_ (*FuncToCall)(double p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble Parse(System.String) declare in System.Data.SqlTypes.SqlDouble
bool w_S_br8_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_br8_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble ToSqlDouble() declare in System.Data.SqlTypes.SqlBoolean
bool w_S_br8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_br8_ (*FuncToCall)(void*,const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble Adjust(System.Data.SqlTypes.SqlDouble) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_br8_tS_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_tS_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};

    typedef struct S_br8_ (*FuncToCall)(void*,struct S_br8_ p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlDouble GetSqlDouble(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_br8_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_br8_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_br8_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_br8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte op_Explicit(System.Data.SqlTypes.SqlInt16) declare in System.Data.SqlTypes.SqlByte
bool w_S_bu1_S_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_S_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};

    typedef struct S_bu1_ (*FuncToCall)(struct S_bi2_ p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte op_Explicit(System.Data.SqlTypes.SqlInt32) declare in System.Data.SqlTypes.SqlByte
bool w_S_bu1_S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_S_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};

    typedef struct S_bu1_ (*FuncToCall)(struct S_bi4_ p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte op_Explicit(System.Data.SqlTypes.SqlMoney) declare in System.Data.SqlTypes.SqlByte
bool w_S_bu1_S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_S_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef struct S_bu1_ (*FuncToCall)(struct S_bi8_ p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte op_Explicit(System.Data.SqlTypes.SqlSingle) declare in System.Data.SqlTypes.SqlByte
bool w_S_bu1_S_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_S_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};

    typedef struct S_bu1_ (*FuncToCall)(struct S_br4_ p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte op_Explicit(System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlByte
bool w_S_bu1_S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_S_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};

    typedef struct S_bu1_ (*FuncToCall)(struct S_br8_ p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte op_OnesComplement(System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlByte
bool w_S_bu1_S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_S_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};

    typedef struct S_bu1_ (*FuncToCall)(struct S_bu1_ p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte op_Addition(System.Data.SqlTypes.SqlByte, System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlByte
bool w_S_bu1_S_bu1_S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_S_bu1_S_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};
    // JSValToCSVal struct
    S_bu1_* pp1 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv1);
    S_bu1_ p1 = pp1 ? *pp1 : S_bu1_ {};

    typedef struct S_bu1_ (*FuncToCall)(struct S_bu1_ p0, struct S_bu1_ p1, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte op_Explicit(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlByte
bool w_S_bu1_S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_S_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef struct S_bu1_ (*FuncToCall)(struct S_soi4i4b_ p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte op_Explicit(System.Data.SqlTypes.SqlBoolean) declare in System.Data.SqlTypes.SqlByte
bool w_S_bu1_S_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_S_u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef struct S_bu1_ (*FuncToCall)(struct S_u1_ p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte op_Explicit(System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlByte
bool w_S_bu1_S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_S_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_bu1_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte Parse(System.String) declare in System.Data.SqlTypes.SqlByte
bool w_S_bu1_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_bu1_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte ToSqlByte() declare in System.Data.SqlTypes.SqlBoolean
bool w_S_bu1_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_bu1_ (*FuncToCall)(void*,const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte Adjust(System.Data.SqlTypes.SqlByte) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_bu1_tS_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_tS_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};

    typedef struct S_bu1_ (*FuncToCall)(void*,struct S_bu1_ p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte GetSqlByte(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_bu1_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_bu1_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Data.SqlTypes.SqlByte op_Implicit(Byte) declare in System.Data.SqlTypes.SqlByte
bool w_S_bu1_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_bu1_u1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef struct S_bu1_ (*FuncToCall)(uint8_t p0, const void* method);
    struct S_bu1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ConsoleKeyInfo ReadKey() declare in System.Console
bool w_S_ci4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ci4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_ci4i4_ (*FuncToCall)(const void* method);
    struct S_ci4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ConsoleKeyInfo ReadKey(Boolean) declare in System.Console
bool w_S_ci4i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_ci4i4_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_ci4i4_ (*FuncToCall)(bool p0, const void* method);
    struct S_ci4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.SortingLayerRange get_all() declare in UnityEngine.Rendering.SortingLayerRange
bool w_S_i2i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i2i2_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i2i2_ (*FuncToCall)(const void* method);
    struct S_i2i2_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Section CreateSection(Int16) declare in System.Collections.Specialized.BitVector32
bool w_S_i2i2_i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i2i2_i2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef struct S_i2i2_ (*FuncToCall)(int16_t p0, const void* method);
    struct S_i2i2_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Section CreateSection(Int16, Section) declare in System.Collections.Specialized.BitVector32
bool w_S_i2i2_i2S_i2i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i2i2_i2S_i2i2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i2i2_* pp1 = DataTransfer::GetPointer<S_i2i2_>(apis, env, _sv1);
    S_i2i2_ p1 = pp1 ? *pp1 : S_i2i2_ {};

    typedef struct S_i2i2_ (*FuncToCall)(int16_t p0, struct S_i2i2_ p1, const void* method);
    struct S_i2i2_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.SortingLayerRange get_sortingLayerRange() declare in UnityEngine.Rendering.FilteringSettings
bool w_S_i2i2_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i2i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i2i2_ (*FuncToCall)(void*,const void* method);
    struct S_i2i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleTextShadow op_Implicit(UnityEngine.UIElements.TextShadow) declare in UnityEngine.UIElements.StyleTextShadow
bool w_S_i4S_S_r4r4_r4S_r4r4r4r4___S_S_r4r4_r4S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_S_r4r4_r4S_r4r4r4r4___S_S_r4r4_r4S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_r4S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_r4S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4_r4S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_r4S_r4r4r4r4__ {};

    typedef struct S_i4S_S_r4r4_r4S_r4r4r4r4___ (*FuncToCall)(struct S_S_r4r4_r4S_r4r4r4r4__ p0, const void* method);
    struct S_i4S_S_r4r4_r4S_r4r4r4r4___ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleTextShadow op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleTextShadow
bool w_S_i4S_S_r4r4_r4S_r4r4r4r4___i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_S_r4r4_r4S_r4r4r4r4___i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4S_S_r4r4_r4S_r4r4r4r4___ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4S_S_r4r4_r4S_r4r4r4r4___ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.ScriptableCullingParameters get_cullingParams() declare in UnityEngine.Experimental.Rendering.XRPass
bool w_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ (*FuncToCall)(void*,const void* method);
    struct S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.SwitchToMainThreadAwaitable SwitchToMainThread(System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_i4S_o__DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_o__DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_i4S_o__ (*FuncToCall)(struct S_o_ p0, const void* method);
    struct S_i4S_o__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Cysharp.Threading.Tasks.SwitchToMainThreadAwaitable SwitchToMainThread(Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.UniTask
bool w_S_i4S_o__i4DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_o__i4DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_i4S_o__ (*FuncToCall)(int32_t p0, struct S_o_ p1, const void* method);
    struct S_i4S_o__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Awaiter GetAwaiter() declare in Cysharp.Threading.Tasks.SwitchToMainThreadAwaitable
bool w_S_i4S_o__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_o__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4S_o__ (*FuncToCall)(void*,const void* method);
    struct S_i4S_o__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleFontDefinition op_Implicit(UnityEngine.UIElements.FontDefinition) declare in UnityEngine.UIElements.StyleFontDefinition
bool w_S_i4S_oo__S_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_oo__S_oo_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oo_* pp0 = DataTransfer::GetPointer<S_oo_>(apis, env, _sv0);
    S_oo_ p0 = pp0 ? *pp0 : S_oo_ {};

    typedef struct S_i4S_oo__ (*FuncToCall)(struct S_oo_ p0, const void* method);
    struct S_i4S_oo__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StyleFontDefinition op_Implicit(UnityEngine.UIElements.StyleKeyword) declare in UnityEngine.UIElements.StyleFontDefinition
bool w_S_i4S_oo__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_oo__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4S_oo__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4S_oo__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.BackgroundSize ConvertScaleModeToBackgroundSize(UnityEngine.ScaleMode) declare in UnityEngine.UIElements.BackgroundPropertyHelper
bool w_S_i4S_r4i4_S_r4i4__Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4i4_S_r4i4__Di4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_i4S_r4i4_S_r4i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4S_r4i4_S_r4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.BackgroundSize get_value() declare in UnityEngine.UIElements.StyleBackgroundSize
bool w_S_i4S_r4i4_S_r4i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4i4_S_r4i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4S_r4i4_S_r4i4__ (*FuncToCall)(void*,const void* method);
    struct S_i4S_r4i4_S_r4i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.BackgroundPosition ConvertScaleModeToBackgroundPosition(UnityEngine.ScaleMode) declare in UnityEngine.UIElements.BackgroundPropertyHelper
bool w_S_i4S_r4i4__Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4i4__Di4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_i4S_r4i4__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4S_r4i4__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.BackgroundPosition get_value() declare in UnityEngine.UIElements.StyleBackgroundPosition
bool w_S_i4S_r4i4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4i4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4S_r4i4__ (*FuncToCall)(void*,const void* method);
    struct S_i4S_r4i4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Touch GetSecondaryTouch(Int32) declare in UnityEngine.AndroidInput
bool w_S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Touch GetTouch(Int32) declare in UnityEngine.EventSystems.BaseInput
bool w_S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.LODParameters get_lodParameters() declare in UnityEngine.Rendering.ScriptableCullingParameters
bool w_S_i4S_r4r4r4_r4r4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4r4r4_r4r4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4S_r4r4r4_r4r4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4S_r4r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.ShadowSplitData get_splitData() declare in UnityEngine.Rendering.ShadowDrawingSettings
bool w_S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Index get_Start() declare in System.Index
bool w_S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4_ (*FuncToCall)(const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AI.NavMeshLinkInstance AddLink(UnityEngine.AI.NavMeshLinkData) declare in UnityEngine.AI.NavMesh
bool w_S_i4_S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_ {};

    typedef struct S_i4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_ p0, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AI.NavMeshLinkInstance AddLink(UnityEngine.AI.NavMeshLinkData, UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.AI.NavMesh
bool w_S_i4_S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef struct S_i4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Index FromStart(Int32) declare in System.Index
bool w_S_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.SceneManagement.Scene LoadScene(Int32, UnityEngine.SceneManagement.LoadSceneParameters) declare in UnityEngine.SceneManagement.SceneManager
bool w_S_i4_i4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_i4S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_i4_ (*FuncToCall)(int32_t p0, struct S_i4i4_ p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.SceneManagement.Scene NewScene(UnityEditor.SceneManagement.NewSceneSetup, UnityEditor.SceneManagement.NewSceneMode) declare in UnityEditor.SceneManagement.EditorSceneManager
bool w_S_i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4_ (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AI.NavMeshDataInstance AddNavMeshData(UnityEngine.AI.NavMeshData) declare in UnityEngine.AI.NavMesh
bool w_S_i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AI.NavMeshDataInstance AddNavMeshData(UnityEngine.AI.NavMeshData, UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.AI.NavMesh
bool w_S_i4_oS_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_oS_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef struct S_i4_ (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Cache AddCache(System.String) declare in UnityEngine.Caching
bool w_S_i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.SceneManagement.Scene CreateScene(System.String, UnityEngine.SceneManagement.CreateSceneParameters) declare in UnityEngine.SceneManagement.SceneManager
bool w_S_i4_sS_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_sS_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};

    typedef struct S_i4_ (*FuncToCall)(Il2CppString* p0, struct S_i4_ p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.SceneManagement.Scene LoadScene(System.String, UnityEngine.SceneManagement.LoadSceneParameters) declare in UnityEngine.SceneManagement.SceneManager
bool w_S_i4_sS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_sS_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_i4_ (*FuncToCall)(Il2CppString* p0, struct S_i4i4_ p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.SceneManagement.Scene OpenScene(System.String, UnityEditor.SceneManagement.OpenSceneMode) declare in UnityEditor.SceneManagement.EditorSceneManager
bool w_S_i4_si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_si4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4_ (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Index get_Start() declare in System.Range
bool w_S_i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.ShaderTagId GetShaderPassName(Int32) declare in UnityEngine.Rendering.DrawingSettings
bool w_S_i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.ShaderTagId FindPassTagValue(Int32, UnityEngine.Rendering.ShaderTagId) declare in UnityEngine.Shader
bool w_S_i4_ti4S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_ti4S_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};

    typedef struct S_i4_ (*FuncToCall)(void*,int32_t p0, struct S_i4_ p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.ShaderTagId FindPassTagValue(Int32, Int32, UnityEngine.Rendering.ShaderTagId) declare in UnityEngine.Shader
bool w_S_i4_ti4i4S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_ti4i4S_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4_* pp2 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv2);
    S_i4_ p2 = pp2 ? *pp2 : S_i4_ {};

    typedef struct S_i4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, struct S_i4_ p2, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Reflection.Emit.MethodToken GetMethodToken(System.Reflection.MethodInfo) declare in System.Reflection.Emit.ModuleBuilder
bool w_S_i4_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i4_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Reflection.Emit.SignatureToken GetSignatureToken(Byte[], Int32) declare in System.Reflection.Emit.ModuleBuilder
bool w_S_i4_toi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_toi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4_ (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Reflection.Emit.MethodToken GetMethodToken(System.Reflection.MethodInfo, System.Collections.Generic.IEnumerable`1[System.Type]) declare in System.Reflection.Emit.ModuleBuilder
bool w_S_i4_too(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_too");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_i4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Reflection.Emit.MethodToken GetArrayMethodToken(System.Type, System.String, System.Reflection.CallingConventions, System.Type, System.Type[]) declare in System.Reflection.Emit.ModuleBuilder
bool w_S_i4_tosi4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_tosi4oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef struct S_i4_ (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Reflection.Emit.StringToken GetStringConstant(System.String) declare in System.Reflection.Emit.ModuleBuilder
bool w_S_i4_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i4_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.QueryParameters get_Default() declare in UnityEngine.QueryParameters
bool w_S_i4bi4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4bi4b_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4bi4b_ (*FuncToCall)(const void* method);
    struct S_i4bi4b_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UI.Navigation get_defaultNavigation() declare in UnityEngine.UI.Navigation
bool w_S_i4boooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4boooo_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4boooo_ (*FuncToCall)(const void* method);
    struct S_i4boooo_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UI.Navigation get_navigation() declare in UnityEngine.UI.Selectable
bool w_S_i4boooo_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4boooo_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4boooo_ (*FuncToCall)(void*,const void* method);
    struct S_i4boooo_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid NewGuid() declare in System.Guid
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid Parse(System.ReadOnlySpan`1[System.Char]) declare in System.Guid
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(struct S_S_p_i4_ p0, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid ParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char]) declare in System.Guid
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_S_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_S_S_p_i4_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid op_Explicit(System.Data.SqlTypes.SqlGuid) declare in System.Data.SqlTypes.SqlGuid
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(struct S_o_ p0, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid GetGuidFromLongs(Int64, Int64) declare in Codice.Client.BaseCommands.BranchExplorer.ExplorerData.BrExDataBuilder
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_i8i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(int64_t p0, int64_t p1, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid GenerateGuidForType(System.Type) declare in System.Runtime.InteropServices.Marshal
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid Parse(System.String) declare in System.Guid
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid ParseExact(System.String, System.String) declare in System.Guid
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid get_InheritedObjectType() declare in System.Security.AccessControl.ObjectAccessRule
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid Adjust(System.Guid) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_tS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_tS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid GetGuid(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid GetProjectGuid(Codice.CM.Common.RepositorySpec) declare in PlasticGui.PlasticAPI
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid GetObjectGuid(Codice.CM.Common.RepositorySpec, Int64) declare in PlasticGui.PlasticAPI
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_toi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_toi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,Il2CppObject* p0, int64_t p1, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Guid GetGuid(System.Data.Common.DbDataReader, System.String) declare in System.Data.DataReaderExtensions
bool w_S_i4i2i2u1u1u1u1u1u1u1u1_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Resolution get_currentResolution() declare in UnityEngine.Screen
bool w_S_i4i4S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4S_u4u4__ (*FuncToCall)(const void* method);
    struct S_i4i4S_u4u4__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int get_mainWindowPosition() declare in UnityEngine.Screen
bool w_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4_ (*FuncToCall)(const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.BackgroundRepeat ConvertScaleModeToBackgroundRepeat(UnityEngine.ScaleMode) declare in UnityEngine.UIElements.BackgroundPropertyHelper
bool w_S_i4i4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_Di4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_i4i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 mul(Unity.Mathematics.int2x4, Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_i4i4_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, struct S_i4i4i4i4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 mul(Unity.Mathematics.int2x3, Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_S_i4i4_S_S_i4i4_S_i4i4_S_i4i4__S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_S_i4i4_S_i4i4_S_i4i4__S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, struct S_i4i4i4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 mul(Unity.Mathematics.int2x2, Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_i4i4_S_S_i4i4_S_i4i4__S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_S_i4i4_S_i4i4__S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, struct S_i4i4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 int2(Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_i4i4_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_bb_ p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int op_UnaryNegation(UnityEngine.Vector2Int) declare in UnityEngine.Vector2Int
bool w_S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 mul(Unity.Mathematics.int2, Unity.Mathematics.int2x2) declare in Unity.Mathematics.math
bool w_S_i4i4_S_i4i4_S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_S_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4__ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p0, struct S_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int Min(UnityEngine.Vector2Int, UnityEngine.Vector2Int) declare in UnityEngine.Vector2Int
bool w_S_i4i4_S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 select(Unity.Mathematics.int2, Unity.Mathematics.int2, Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_S_i4i4_S_i4i4_S_i4i4_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_S_i4i4_S_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal struct
    S_bb_* pp2 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv2);
    S_bb_ p2 = pp2 ? *pp2 : S_bb_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, struct S_bb_ p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 mad(Unity.Mathematics.int2, Unity.Mathematics.int2, Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_i4i4_S_i4i4_S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_S_i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, struct S_i4i4_ p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 select(Unity.Mathematics.int2, Unity.Mathematics.int2, Boolean) declare in Unity.Mathematics.math
bool w_S_i4i4_S_i4i4_S_i4i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_S_i4i4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, bool p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 shuffle(Unity.Mathematics.int2, Unity.Mathematics.int2, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_i4i4_S_i4i4_S_i4i4_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_S_i4i4_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int op_Multiply(UnityEngine.Vector2Int, Int32) declare in UnityEngine.Vector2Int
bool w_S_i4i4_S_i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p0, int32_t p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int op_Explicit(UnityEngine.Vector3Int) declare in UnityEngine.Vector3Int
bool w_S_i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 mul(Unity.Mathematics.int3, Unity.Mathematics.int3x2) declare in Unity.Mathematics.math
bool w_S_i4i4_S_i4i4i4_S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4i4_S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 shuffle(Unity.Mathematics.int3, Unity.Mathematics.int3, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_i4i4_S_i4i4i4_S_i4i4i4_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4i4_S_i4i4i4_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 mul(Unity.Mathematics.int4, Unity.Mathematics.int4x2) declare in Unity.Mathematics.math
bool w_S_i4i4_S_i4i4i4i4_S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4i4i4_S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 shuffle(Unity.Mathematics.int4, Unity.Mathematics.int4, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_i4i4_S_i4i4i4i4_S_i4i4i4i4_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4i4i4_S_i4i4i4i4_u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, uint8_t p2, uint8_t p3, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int FloorToInt(UnityEngine.Vector2) declare in UnityEngine.Vector2Int
bool w_S_i4i4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int Vector2IntField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Vector2Int) declare in UnityEditor.EditorGUI
bool w_S_i4i4_S_r4r4r4r4_oS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_r4r4r4r4_oS_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, struct S_i4i4_ p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int Vector2IntField(UnityEngine.Rect, System.String, UnityEngine.Vector2Int) declare in UnityEditor.EditorGUI
bool w_S_i4i4_S_r4r4r4r4_sS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_r4r4r4r4_sS_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, struct S_i4i4_ p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 int2(Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_S_i4i4_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_r8r8_ p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 int2(Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_i4i4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(struct S_u4u4_ p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 int2(Boolean) declare in Unity.Mathematics.math
bool w_S_i4i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4_ (*FuncToCall)(bool p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.PropertyName op_Implicit(Int32) declare in UnityEngine.PropertyName
bool w_S_i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int op_Multiply(Int32, UnityEngine.Vector2Int) declare in UnityEngine.Vector2Int
bool w_S_i4i4_i4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_i4S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(int32_t p0, struct S_i4i4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 int2(Int32, Int32) declare in Unity.Mathematics.math
bool w_S_i4i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i4_ (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int Vector2IntField(UnityEngine.GUIContent, UnityEngine.Vector2Int, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_i4i4_oS_i4i4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_oS_i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_i4i4_ (*FuncToCall)(Il2CppObject* p0, struct S_i4i4_ p1, Il2CppArray* p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 int2(Single) declare in Unity.Mathematics.math
bool w_S_i4i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4_ (*FuncToCall)(float p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 int2(Double) declare in Unity.Mathematics.math
bool w_S_i4i4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4_ (*FuncToCall)(double p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.TextureMipmapLimitSettings GetTextureMipmapLimitSettings(System.String) declare in UnityEngine.QualitySettings
bool w_S_i4i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int Vector2IntField(System.String, UnityEngine.Vector2Int, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_i4i4_sS_i4i4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_sS_i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_i4i4_ (*FuncToCall)(Il2CppString* p0, struct S_i4i4_ p1, Il2CppArray* p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int get_min() declare in UnityEngine.RectInt
bool w_S_i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int GetScaledSize(UnityEngine.Vector2Int) declare in UnityEngine.Rendering.DynamicResolutionHandler
bool w_S_i4i4_tS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_tS_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(void*,struct S_i4i4_ p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 NextInt2(Unity.Mathematics.int2, Unity.Mathematics.int2) declare in Unity.Mathematics.Random
bool w_S_i4i4_tS_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_tS_i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_i4i4_ (*FuncToCall)(void*,struct S_i4i4_ p0, struct S_i4i4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.ValueTuple`2[System.Int32,System.Int32] GetOffsetAndLength(Int32) declare in System.Range
bool w_S_i4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector2Int GetBrushOffset(Int32, Int32) declare in UnityEditor.TerrainTools.DetailBrushBounds
bool w_S_i4i4_ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int2 int2(UInt32) declare in Unity.Mathematics.math
bool w_S_i4i4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.U2D.SpriteAtlasPackingSettings GetPackingSettings(UnityEngine.U2D.SpriteAtlas) declare in UnityEditor.U2D.SpriteAtlasExtensions
bool w_S_i4i4bbbb_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4bbbb_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4bbbb_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4bbbb_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Rendering.TierSettings GetTierSettings(UnityEditor.Build.NamedBuildTarget, UnityEngine.Rendering.GraphicsTier) declare in UnityEditor.Rendering.EditorGraphicsSettings
bool w_S_i4i4bbbbbbbbi4i4_S_s_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4bbbbbbbbi4i4_S_s_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i4bbbbbbbbi4i4_ (*FuncToCall)(struct S_s_ p0, int32_t p1, const void* method);
    struct S_i4i4bbbbbbbbi4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Rendering.TierSettings GetTierSettings(UnityEditor.BuildTargetGroup, UnityEngine.Rendering.GraphicsTier) declare in UnityEditor.Rendering.EditorGraphicsSettings
bool w_S_i4i4bbbbbbbbi4i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4bbbbbbbbi4i4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i4bbbbbbbbi4i4_ (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    struct S_i4i4bbbbbbbbi4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Mono.Cecil.Cil.ImageDebugDirectory get_Directory() declare in Mono.Cecil.Cil.ImageDebugHeaderEntry
bool w_S_i4i4i2i2i4i4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i2i2i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i2i2i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i2i2i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3Int get_zero() declare in UnityEngine.Vector3Int
bool w_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4_ (*FuncToCall)(const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 mul(Unity.Mathematics.int3x4, Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, struct S_i4i4i4i4_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 mul(Unity.Mathematics.int3x3, Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, struct S_i4i4i4_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 mul(Unity.Mathematics.int3x2, Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_S_i4i4i4_S_i4i4i4__S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_S_i4i4i4_S_i4i4i4__S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, struct S_i4i4_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 int3(Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_bbb_ p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3Int op_Explicit(UnityEngine.Vector2Int) declare in UnityEngine.Vector2Int
bool w_S_i4i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4_ p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 mul(Unity.Mathematics.int2, Unity.Mathematics.int2x3) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_i4i4_S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4_S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4_ p0, struct S_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 shuffle(Unity.Mathematics.int2, Unity.Mathematics.int2, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_i4i4_S_i4i4_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4_S_i4i4_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 int3(Unity.Mathematics.int2, Int32) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4_ p0, int32_t p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3Int op_UnaryNegation(UnityEngine.Vector3Int) declare in UnityEngine.Vector3Int
bool w_S_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 mul(Unity.Mathematics.int3, Unity.Mathematics.int3x3) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_i4i4i4_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3Int Min(UnityEngine.Vector3Int, UnityEngine.Vector3Int) declare in UnityEngine.Vector3Int
bool w_S_i4i4i4_S_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 select(Unity.Mathematics.int3, Unity.Mathematics.int3, Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_bbb_* pp2 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv2);
    S_bbb_ p2 = pp2 ? *pp2 : S_bbb_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, struct S_bbb_ p2, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 mad(Unity.Mathematics.int3, Unity.Mathematics.int3, Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, struct S_i4i4i4_ p2, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 select(Unity.Mathematics.int3, Unity.Mathematics.int3, Boolean) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_i4i4i4_S_i4i4i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4_S_i4i4i4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, bool p2, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 shuffle(Unity.Mathematics.int3, Unity.Mathematics.int3, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_i4i4i4_S_i4i4i4_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4_S_i4i4i4_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3Int op_Multiply(UnityEngine.Vector3Int, Int32) declare in UnityEngine.Vector3Int
bool w_S_i4i4i4_S_i4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, int32_t p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 mul(Unity.Mathematics.int4, Unity.Mathematics.int4x3) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_i4i4i4i4_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4i4_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 shuffle(Unity.Mathematics.int4, Unity.Mathematics.int4, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_i4i4i4i4_S_i4i4i4i4_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4i4_S_i4i4i4i4_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3Int FloorToInt(UnityEngine.Vector3) declare in UnityEngine.Vector3Int
bool w_S_i4i4i4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3Int Vector3IntField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Vector3Int) declare in UnityEditor.EditorGUI
bool w_S_i4i4i4_S_r4r4r4r4_oS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_r4r4r4r4_oS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, struct S_i4i4i4_ p2, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3Int Vector3IntField(UnityEngine.Rect, System.String, UnityEngine.Vector3Int) declare in UnityEditor.EditorGUI
bool w_S_i4i4i4_S_r4r4r4r4_sS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_r4r4r4r4_sS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, struct S_i4i4i4_ p2, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 int3(Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_r8r8r8_ p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 int3(Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_i4i4i4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_u4u4u4_ p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 int3(Boolean) declare in Unity.Mathematics.math
bool w_S_i4i4i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4_ (*FuncToCall)(bool p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 int3(Int32) declare in Unity.Mathematics.math
bool w_S_i4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 int3(Int32, Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_i4i4i4_i4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_i4S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(int32_t p0, struct S_i4i4_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3Int op_Multiply(Int32, UnityEngine.Vector3Int) declare in UnityEngine.Vector3Int
bool w_S_i4i4i4_i4S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_i4S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(int32_t p0, struct S_i4i4i4_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 int3(Int32, Int32, Int32) declare in Unity.Mathematics.math
bool w_S_i4i4i4_i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_i4i4i4_ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3Int Vector3IntField(UnityEngine.GUIContent, UnityEngine.Vector3Int, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_i4i4i4_oS_i4i4i4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_oS_i4i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_i4i4i4_ (*FuncToCall)(Il2CppObject* p0, struct S_i4i4i4_ p1, Il2CppArray* p2, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 int3(Single) declare in Unity.Mathematics.math
bool w_S_i4i4i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4_ (*FuncToCall)(float p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 int3(Double) declare in Unity.Mathematics.math
bool w_S_i4i4i4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4_ (*FuncToCall)(double p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3Int Vector3IntField(System.String, UnityEngine.Vector3Int, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_i4i4i4_sS_i4i4i4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_sS_i4i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_i4i4i4_ (*FuncToCall)(Il2CppString* p0, struct S_i4i4i4_ p1, Il2CppArray* p2, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.LockCookie ReleaseLock() declare in System.Threading.ReaderWriterLock
bool w_S_i4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 NextInt3(Unity.Mathematics.int3) declare in Unity.Mathematics.Random
bool w_S_i4i4i4_tS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_tS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(void*,struct S_i4i4i4_ p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 NextInt3(Unity.Mathematics.int3, Unity.Mathematics.int3) declare in Unity.Mathematics.Random
bool w_S_i4i4i4_tS_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_tS_i4i4i4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(void*,struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.LockCookie UpgradeToWriterLock(System.TimeSpan) declare in System.Threading.ReaderWriterLock
bool w_S_i4i4i4_tS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_tS_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(void*,struct S_i8_ p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Vector3Int LocalToCell(UnityEngine.Vector3) declare in UnityEngine.GridLayout
bool w_S_i4i4i4_tS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_tS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef struct S_i4i4i4_ (*FuncToCall)(void*,struct S_r4r4r4_ p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Threading.LockCookie UpgradeToWriterLock(Int32) declare in System.Threading.ReaderWriterLock
bool w_S_i4i4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int3 int3(UInt32) declare in Unity.Mathematics.math
bool w_S_i4i4i4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AnimatorTransitionInfo GetAnimatorTransitionInfo(Int32) declare in UnityEngine.Animator
bool w_S_i4i4i4br4r4bi4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4br4r4bi4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4br4r4bi4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4i4i4br4r4bi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.TextureDesc GetTextureDesc(UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__tS_S_u4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__tS_S_u4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4i4__* pp0 = DataTransfer::GetPointer<S_S_u4i4__>(apis, env, _sv0);
    S_S_u4i4__ p0 = pp0 ? *pp0 : S_S_u4i4__ {};

    typedef struct S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__ (*FuncToCall)(void*,struct S_S_u4i4__ p0, const void* method);
    struct S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AI.OffMeshLinkData get_currentOffMeshLinkData() declare in UnityEngine.AI.NavMeshAgent
bool w_S_i4i4i4i4S_r4r4r4_S_r4r4r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4S_r4r4r4_S_r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4i4S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// State get_state() declare in UnityEngine.Random
bool w_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4i4_ (*FuncToCall)(const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 mul(Unity.Mathematics.int4x4, Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_i4i4i4i4_ p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 mul(Unity.Mathematics.int4x3, Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_i4i4i4_ p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 mul(Unity.Mathematics.int4x2, Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_S_i4i4i4i4_S_i4i4i4i4__S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_S_i4i4i4i4_S_i4i4i4i4__S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, struct S_i4i4_ p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_bbbb_ p0, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 mul(Unity.Mathematics.int2, Unity.Mathematics.int2x4) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4_S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv1);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4_ p0, struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Unity.Mathematics.int2, Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 shuffle(Unity.Mathematics.int2, Unity.Mathematics.int2, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4_S_i4i4_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4_S_i4i4_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Unity.Mathematics.int2, Int32, Int32) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4_ p0, int32_t p1, int32_t p2, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 mul(Unity.Mathematics.int3, Unity.Mathematics.int3x4) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4i4_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4_S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 shuffle(Unity.Mathematics.int3, Unity.Mathematics.int3, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4i4_S_i4i4i4_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4_S_i4i4i4_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Unity.Mathematics.int3, Int32) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p0, int32_t p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 mul(Unity.Mathematics.int4, Unity.Mathematics.int4x4) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4i4i4_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4i4_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 min(Unity.Mathematics.int4, Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 select(Unity.Mathematics.int4, Unity.Mathematics.int4, Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_bbbb_* pp2 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv2);
    S_bbbb_ p2 = pp2 ? *pp2 : S_bbbb_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, struct S_bbbb_ p2, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 mad(Unity.Mathematics.int4, Unity.Mathematics.int4, Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv2);
    S_i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, struct S_i4i4i4i4_ p2, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 select(Unity.Mathematics.int4, Unity.Mathematics.int4, Boolean) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, bool p2, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 shuffle(Unity.Mathematics.int4, Unity.Mathematics.int4, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RectInt RectIntField(UnityEngine.RectInt, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_i4i4i4i4_S_i4i4i4i4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, Il2CppArray* p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 rol(Unity.Mathematics.int4, Int32) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_i4i4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, int32_t p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RectInt RectIntField(UnityEngine.Rect, UnityEngine.RectInt) declare in UnityEditor.EditorGUI
bool w_S_i4i4i4i4_S_r4r4r4r4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_r4r4r4r4_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_i4i4i4i4_ p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RectInt RectIntField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.RectInt) declare in UnityEditor.EditorGUI
bool w_S_i4i4i4i4_S_r4r4r4r4_oS_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_r4r4r4r4_oS_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv2);
    S_i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, struct S_i4i4i4i4_ p2, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RectInt RectIntField(UnityEngine.Rect, System.String, UnityEngine.RectInt) declare in UnityEditor.EditorGUI
bool w_S_i4i4i4i4_S_r4r4r4r4_sS_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_r4r4r4r4_sS_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv2);
    S_i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, struct S_i4i4i4i4_ p2, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_r8r8r8r8_ p0, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Boolean) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(bool p0, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Int32) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Int32, Unity.Mathematics.int2, Int32) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_i4S_i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_i4S_i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(int32_t p0, struct S_i4i4_ p1, int32_t p2, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Int32, Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_i4S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_i4S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(int32_t p0, struct S_i4i4i4_ p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 op_Multiply(Int32, Unity.Mathematics.int4) declare in Unity.Mathematics.int4
bool w_S_i4i4i4i4_i4S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_i4S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(int32_t p0, struct S_i4i4i4i4_ p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Int32, Int32, Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_i4i4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_i4i4S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(int32_t p0, int32_t p1, struct S_i4i4_ p2, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Int32, Int32, Int32, Int32) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RectInt RectIntField(UnityEngine.GUIContent, UnityEngine.RectInt, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_i4i4i4i4_oS_i4i4i4i4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_oS_i4i4i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_i4i4i4i4_ (*FuncToCall)(Il2CppObject* p0, struct S_i4i4i4i4_ p1, Il2CppArray* p2, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Single) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(float p0, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(Double) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(double p0, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RectInt RectIntField(System.String, UnityEngine.RectInt, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_S_i4i4i4i4_sS_i4i4i4i4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_sS_i4i4i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef struct S_i4i4i4i4_ (*FuncToCall)(Il2CppString* p0, struct S_i4i4i4i4_ p1, Il2CppArray* p2, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RectInt get_pixelRect() declare in UnityEngine.TerrainTools.PaintContext
bool w_S_i4i4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 NextInt4(Unity.Mathematics.int4) declare in Unity.Mathematics.Random
bool w_S_i4i4i4i4_tS_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_tS_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(void*,struct S_i4i4i4i4_ p0, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 NextInt4(Unity.Mathematics.int4, Unity.Mathematics.int4) declare in Unity.Mathematics.Random
bool w_S_i4i4i4i4_tS_i4i4i4i4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_tS_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};

    typedef struct S_i4i4i4i4_ (*FuncToCall)(void*,struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.VertexAttributeDescriptor GetVertexAttribute(Int32) declare in UnityEngine.Mesh
bool w_S_i4i4i4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.int4 int4(UInt32) declare in Unity.Mathematics.math
bool w_S_i4i4i4i4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.LightBakingOutput get_bakingOutput() declare in UnityEngine.Light
bool w_S_i4i4i4i4b_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4b_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4i4b_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4b_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AudioConfiguration GetConfiguration() declare in UnityEngine.AudioSettings
bool w_S_i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4i4i4_ (*FuncToCall)(const void* method);
    struct S_i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.U2D.SpriteAtlasTextureSettings GetTextureSettings(UnityEngine.U2D.SpriteAtlas) declare in UnityEditor.U2D.SpriteAtlasExtensions
bool w_S_i4i4i4i4i4bbbb_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4i4bbbb_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4i4i4bbbb_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4i4bbbb_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.MemoryProfiler.VirtualMachineInformation get_virtualMachineInformation() declare in UnityEditor.MemoryProfiler.PackedMemorySnapshot
bool w_S_i4i4i4i4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RenderTextureDescriptor get_eyeTextureDesc() declare in UnityEngine.XR.XRSettings
bool w_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(const void* method);
    struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RenderTextureDescriptor get_descriptor() declare in UnityEngine.RenderTexture
bool w_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// ChangesToApplySummary GetChangesToApplySummary(PlasticGui.Gluon.WorkspaceWindow.Views.IncomingChanges.IncomingChangesTree) declare in PlasticGui.Gluon.WorkspaceWindow.Views.IncomingChanges.BuildFilesSummaryData
bool w_S_i4i4i4i4i8i8i8i8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4i8i8i8i8_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i4i4i4i4i8i8i8i8_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_i4i4i4i4i8i8i8i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(System.Object) declare in System.Convert
bool w_S_i4i4i4i4u8_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_O");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(System.Object, System.IFormatProvider) declare in System.Convert
bool w_S_i4i4i4i4u8_Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_Oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider) declare in System.Decimal
bool w_S_i4i4i4i4u8_S_S_p_i4_Di4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_S_p_i4_Di4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal op_Explicit(System.Data.SqlTypes.SqlMoney) declare in System.Data.SqlTypes.SqlMoney
bool w_S_i4i4i4i4u8_S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_bi8_ p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(System.Decimal) declare in System.Convert
bool w_S_i4i4i4i4u8_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal Max(System.Decimal, System.Decimal) declare in System.Math
bool w_S_i4i4i4i4u8_S_i4i4i4i4u8_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p0, struct S_i4i4i4i4u8_ p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal Clamp(System.Decimal, System.Decimal, System.Decimal) declare in System.Math
bool w_S_i4i4i4i4u8_S_i4i4i4i4u8_S_i4i4i4i4u8_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4i4i4i4u8_S_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv2);
    S_i4i4i4i4u8_ p2 = pp2 ? *pp2 : S_i4i4i4i4u8_ {};

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p0, struct S_i4i4i4i4u8_ p1, struct S_i4i4i4i4u8_ p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal Round(System.Decimal, Int32) declare in System.Math
bool w_S_i4i4i4i4u8_S_i4i4i4i4u8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4i4i4i4u8_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p0, int32_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal Round(System.Decimal, Int32, System.MidpointRounding) declare in System.Math
bool w_S_i4i4i4i4u8_S_i4i4i4i4u8_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4i4i4i4u8_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p0, int32_t p1, int32_t p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal op_Explicit(System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_S_i4i4i4i4u8_S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4o_ p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal op_Explicit(System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlDecimal
bool w_S_i4i4i4i4u8_S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_u1u1u1u1u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_u1u1u1u1u4u4u4u4_ p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(System.DateTime) declare in System.Convert
bool w_S_i4i4i4i4u8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_u8_ p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(Boolean) declare in System.Convert
bool w_S_i4i4i4i4u8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(bool p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(Char) declare in System.Convert
bool w_S_i4i4i4i4u8_c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_c");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppChar p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(SByte) declare in System.Convert
bool w_S_i4i4i4i4u8_i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_i1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(int8_t p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(Int16) declare in System.Convert
bool w_S_i4i4i4i4u8_i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_i2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(int16_t p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(Int32) declare in System.Convert
bool w_S_i4i4i4i4u8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(Int64) declare in System.Convert
bool w_S_i4i4i4i4u8_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(int64_t p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_S_i4i4i4i4u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(Single) declare in System.Convert
bool w_S_i4i4i4i4u8_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(float p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(Double) declare in System.Convert
bool w_S_i4i4i4i4u8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(double p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(System.String) declare in System.Convert
bool w_S_i4i4i4i4u8_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal Parse(System.String, System.Globalization.NumberStyles) declare in System.Decimal
bool w_S_i4i4i4i4u8_si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_si4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider) declare in System.Decimal
bool w_S_i4i4i4i4u8_si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_si4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(System.String, System.IFormatProvider) declare in System.Convert
bool w_S_i4i4i4i4u8_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal get_Value() declare in System.Runtime.Remoting.Metadata.W3cXsd2001.SoapInteger
bool w_S_i4i4i4i4u8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(System.Object) declare in System.Runtime.Serialization.FormatterConverter
bool w_S_i4i4i4i4u8_tO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_tO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal Adjust(System.Decimal) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_S_i4i4i4i4u8_tS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_tS_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,struct S_i4i4i4i4u8_ p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal NextDecimal(System.Decimal, System.Decimal) declare in NUnit.Framework.Internal.Randomizer
bool w_S_i4i4i4i4u8_tS_i4i4i4i4u8_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_tS_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,struct S_i4i4i4i4u8_ p0, struct S_i4i4i4i4u8_ p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal GetDecimal(Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_S_i4i4i4i4u8_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ReadDecimal(Int64) declare in System.IO.UnmanagedMemoryAccessor
bool w_S_i4i4i4i4u8_ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_ti8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,int64_t p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal GetDecimal(System.String) declare in System.Runtime.Serialization.SerializationInfo
bool w_S_i4i4i4i4u8_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ReadElementContentAsDecimal(System.String, System.String) declare in System.Xml.XmlReader
bool w_S_i4i4i4i4u8_tss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_tss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(Byte) declare in System.Convert
bool w_S_i4i4i4i4u8_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_u1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(uint8_t p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(UInt16) declare in System.Convert
bool w_S_i4i4i4i4u8_u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_u2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(uint16_t p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(UInt32) declare in System.Convert
bool w_S_i4i4i4i4u8_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Decimal ToDecimal(UInt64) declare in System.Convert
bool w_S_i4i4i4i4u8_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_u8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(uint64_t p0, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle
bool w_S_i4i4i4pi4i4i4_S_S_u4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4pi4i4i4_S_S_u4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4i4__* pp0 = DataTransfer::GetPointer<S_S_u4i4__>(apis, env, _sv0);
    S_S_u4i4__ p0 = pp0 ? *pp0 : S_S_u4i4__ {};

    typedef struct S_i4i4i4pi4i4i4_ (*FuncToCall)(struct S_S_u4i4__ p0, const void* method);
    struct S_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(UnityEngine.RenderBuffer) declare in UnityEngine.Rendering.RenderTargetIdentifier
bool w_S_i4i4i4pi4i4i4_S_i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4pi4i4i4_S_i4p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4p_* pp0 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv0);
    S_i4p_ p0 = pp0 ? *pp0 : S_i4p_ {};

    typedef struct S_i4i4i4pi4i4i4_ (*FuncToCall)(struct S_i4p_ p0, const void* method);
    struct S_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(UnityEngine.Rendering.BuiltinRenderTextureType) declare in UnityEngine.Rendering.RenderTargetIdentifier
bool w_S_i4i4i4pi4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4pi4i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4pi4i4i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(UnityEngine.Texture) declare in UnityEngine.Rendering.RenderTargetIdentifier
bool w_S_i4i4i4pi4i4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4pi4i4i4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i4i4i4pi4i4i4_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(System.String) declare in UnityEngine.Rendering.RenderTargetIdentifier
bool w_S_i4i4i4pi4i4i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4pi4i4i4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4pi4i4i4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RenderTargetIdentifier get_depthRenderTarget() declare in UnityEngine.Rendering.RenderTargetBinding
bool w_S_i4i4i4pi4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4pi4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4pi4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// HDRDisplayInformation get_hdrDisplayOutputInformation() declare in UnityEngine.Experimental.Rendering.XRPass
bool w_S_i4i4i4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4r4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AnimatorStateInfo get_animatorStateInfo() declare in UnityEngine.AnimationEvent
bool w_S_i4i4i4r4r4r4r4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4r4r4r4r4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4i4r4r4r4r4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4r4r4r4r4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AnimatorStateInfo GetCurrentAnimatorStateInfo(Int32) declare in UnityEngine.Animator
bool w_S_i4i4i4r4r4r4r4i4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4r4r4r4r4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4i4r4r4r4r4i4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4i4i4r4r4r4r4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.Rendering.RenderGraphModule.ComputeBufferDesc GetComputeBufferDesc(UnityEngine.Experimental.Rendering.RenderGraphModule.ComputeBufferHandle ByRef) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_S_i4i4i4s_tPS_S_u4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4s_tPS_S_u4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_u4i4__* p0 = DataTransfer::GetPointer<S_S_u4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_u4i4__));
        p0 = &up0;
    }
        

    typedef struct S_i4i4i4s_ (*FuncToCall)(void*,struct S_S_u4i4__* p0, const void* method);
    struct S_i4i4i4s_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonWriterOptions get_Options() declare in System.Text.Json.Utf8JsonWriter
bool w_S_i4i4o_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4o_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4o_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4o_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.RasterState get_rasterState() declare in UnityEngine.Rendering.RenderStateBlock
bool w_S_i4i4r4u1u1u1u1_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4r4u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4r4u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4r4u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Codice.Client.Commands.CurrentUploadBlock get_CurrentCheckinBlock() declare in Codice.Client.GameUI.Checkin.CheckinProgress
bool w_S_i4i4si8i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4si8i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4si8i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4si8i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.AudioImporterSampleSettings get_defaultSampleSettings() declare in UnityEditor.AudioImporter
bool w_S_i4i4u4i4r4i4b_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4u4i4r4i4b_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4i4u4i4r4i4b_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4u4i4r4i4b_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.AudioImporterSampleSettings GetOverrideSampleSettings(UnityEditor.BuildTargetGroup) declare in UnityEditor.AudioImporter
bool w_S_i4i4u4i4r4i4b_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4u4i4r4i4b_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4u4i4r4i4b_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4i4u4i4r4i4b_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.AudioImporterSampleSettings GetOverrideSampleSettings(System.String) declare in UnityEditor.AudioImporter
bool w_S_i4i4u4i4r4i4b_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4u4i4r4i4b_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i4i4u4i4r4i4b_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_i4i4u4i4r4i4b_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger get_Zero() declare in System.Numerics.BigInteger
bool w_S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4o_ (*FuncToCall)(const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider) declare in System.Numerics.BigInteger
bool w_S_i4o_S_S_p_i4_Di4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_S_p_i4_Di4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef struct S_i4o_ (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger op_Explicit(System.Decimal) declare in System.Numerics.BigInteger
bool w_S_i4o_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef struct S_i4o_ (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger Abs(System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_S_i4o_S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_i4o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};

    typedef struct S_i4o_ (*FuncToCall)(struct S_i4o_ p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger Add(System.Numerics.BigInteger, System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_S_i4o_S_i4o_S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_i4o_S_i4o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};
    // JSValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};

    typedef struct S_i4o_ (*FuncToCall)(struct S_i4o_ p0, struct S_i4o_ p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger DivRem(System.Numerics.BigInteger, System.Numerics.BigInteger, System.Numerics.BigInteger ByRef) declare in System.Numerics.BigInteger
bool w_S_i4o_S_i4o_S_i4o_PS_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_i4o_S_i4o_PS_i4o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};
    // JSValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
    // JSValToCSVal Pstruct
    S_i4o_* p2 = DataTransfer::GetPointer<S_i4o_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_i4o_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_i4o_));
        p2 = &up2;
    }
        

    typedef struct S_i4o_ (*FuncToCall)(struct S_i4o_ p0, struct S_i4o_ p1, struct S_i4o_* p2, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger ModPow(System.Numerics.BigInteger, System.Numerics.BigInteger, System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_S_i4o_S_i4o_S_i4o_S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_i4o_S_i4o_S_i4o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};
    // JSValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
    // JSValToCSVal struct
    S_i4o_* pp2 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv2);
    S_i4o_ p2 = pp2 ? *pp2 : S_i4o_ {};

    typedef struct S_i4o_ (*FuncToCall)(struct S_i4o_ p0, struct S_i4o_ p1, struct S_i4o_ p2, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger Pow(System.Numerics.BigInteger, Int32) declare in System.Numerics.BigInteger
bool w_S_i4o_S_i4o_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_i4o_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4o_ (*FuncToCall)(struct S_i4o_ p0, int32_t p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger op_Implicit(SByte) declare in System.Numerics.BigInteger
bool w_S_i4o_i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_i1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4o_ (*FuncToCall)(int8_t p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger op_Implicit(Int16) declare in System.Numerics.BigInteger
bool w_S_i4o_i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_i2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4o_ (*FuncToCall)(int16_t p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger op_Implicit(Int32) declare in System.Numerics.BigInteger
bool w_S_i4o_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4o_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger op_Implicit(Int64) declare in System.Numerics.BigInteger
bool w_S_i4o_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4o_ (*FuncToCall)(int64_t p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger op_Explicit(Single) declare in System.Numerics.BigInteger
bool w_S_i4o_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_i4o_ (*FuncToCall)(float p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger op_Explicit(Double) declare in System.Numerics.BigInteger
bool w_S_i4o_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_i4o_ (*FuncToCall)(double p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger Parse(System.String) declare in System.Numerics.BigInteger
bool w_S_i4o_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i4o_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger Parse(System.String, System.Globalization.NumberStyles) declare in System.Numerics.BigInteger
bool w_S_i4o_si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_si4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4o_ (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider) declare in System.Numerics.BigInteger
bool w_S_i4o_si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_si4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_i4o_ (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger Parse(System.String, System.IFormatProvider) declare in System.Numerics.BigInteger
bool w_S_i4o_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_i4o_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger op_Implicit(Byte) declare in System.Numerics.BigInteger
bool w_S_i4o_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_u1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4o_ (*FuncToCall)(uint8_t p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger op_Implicit(UInt16) declare in System.Numerics.BigInteger
bool w_S_i4o_u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_u2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4o_ (*FuncToCall)(uint16_t p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger op_Implicit(UInt32) declare in System.Numerics.BigInteger
bool w_S_i4o_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4o_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Numerics.BigInteger op_Implicit(UInt64) declare in System.Numerics.BigInteger
bool w_S_i4o_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_u8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4o_ (*FuncToCall)(uint64_t p0, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Presets.PresetType GetPresetType() declare in UnityEditor.Presets.Preset
bool w_S_i4os_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4os_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4os_ (*FuncToCall)(void*,const void* method);
    struct S_i4os_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RenderBuffer get_activeColorBuffer() declare in UnityEngine.Graphics
bool w_S_i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4p_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4p_ (*FuncToCall)(const void* method);
    struct S_i4p_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.RenderBuffer get_colorBuffer() declare in UnityEngine.Display
bool w_S_i4p_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4p_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4p_ (*FuncToCall)(void*,const void* method);
    struct S_i4p_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Experimental.GlobalIllumination.Cookie Defaults() declare in UnityEngine.Experimental.GlobalIllumination.Cookie
bool w_S_i4r4S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4r4S_r4r4__ (*FuncToCall)(const void* method);
    struct S_i4r4S_r4r4__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Experimental.OnDemandProgress GetOnDemandArtifactProgress(UnityEditor.Experimental.ArtifactKey) declare in UnityEditor.Experimental.AssetDatabaseExperimental
bool w_S_i4r4_S_S_u4u4u4u4_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4_S_S_u4u4u4u4_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_o_* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_o_>(apis, env, _sv0);
    S_S_u4u4u4u4_o_ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_o_ {};

    typedef struct S_i4r4_ (*FuncToCall)(struct S_S_u4u4u4u4_o_ p0, const void* method);
    struct S_i4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Experimental.OnDemandProgress GetOnDemandArtifactProgress(System.String) declare in UnityEditor.Experimental.AssetDatabaseExperimental
bool w_S_i4r4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i4r4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_i4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Experimental.OnDemandProgress GetOnDemandArtifactProgress(System.String, System.Type) declare in UnityEditor.Experimental.AssetDatabaseExperimental
bool w_S_i4r4_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_i4r4_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    struct S_i4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AnimatorClipInfo get_animatorClipInfo() declare in UnityEngine.AnimationEvent
bool w_S_i4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4r4_ (*FuncToCall)(void*,const void* method);
    struct S_i4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.PhysicsShape2D GetShape(Int32) declare in UnityEngine.PhysicsShapeGroup2D
bool w_S_i4r4i4i4i4i4S_r4r4_S_r4r4__ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4i4i4i4i4S_r4r4_S_r4r4__ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4r4i4i4i4i4S_r4r4_S_r4r4__ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4r4i4i4i4i4S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// MinMaxCurve get_directionX() declare in UnityEngine.ParticleSystemForceField
bool w_S_i4r4oor4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4oor4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4r4oor4r4_ (*FuncToCall)(void*,const void* method);
    struct S_i4r4oor4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AI.NavMeshBuildSettings CreateSettings() declare in UnityEngine.AI.NavMesh
bool w_S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ (*FuncToCall)(const void* method);
    struct S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.AI.NavMeshBuildSettings GetSettingsByID(Int32) declare in UnityEngine.AI.NavMesh
bool w_S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.NVIDIA.DLSSCommandExecutionData get_execData() declare in UnityEngine.NVIDIA.DLSSDebugFeatureInfos
bool w_S_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_ (*FuncToCall)(void*,const void* method);
    struct S_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Microsoft.Extensions.Logging.EventId op_Implicit(Int32) declare in Microsoft.Extensions.Logging.EventId
bool w_S_i4s_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4s_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4s_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4s_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.UIElements.StylePropertyName op_Implicit(System.String) declare in UnityEngine.UIElements.StylePropertyName
bool w_S_i4s_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4s_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i4s_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_i4s_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Properties.PropertyPathPart get_Item(Int32) declare in Unity.Properties.PropertyPath
bool w_S_i4si4O_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4si4O_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4si4O_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4si4O_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.ShaderGraph.Internal.OutputMetadata GetOutput(Int32) declare in UnityEditor.ShaderGraph.Internal.ShaderGraphVfxAsset
bool w_S_i4si4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4si4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4si4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4si4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// CameraMode GetBuiltinCameraMode(UnityEditor.DrawCameraMode) declare in UnityEditor.SceneView
bool w_S_i4ss_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ss_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4ss_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_i4ss_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// CameraMode AddCameraMode(System.String, System.String) declare in UnityEditor.SceneView
bool w_S_i4ss_ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ss_ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_i4ss_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    struct S_i4ss_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// CameraMode get_cameraMode() declare in UnityEditor.SceneView
bool w_S_i4ss_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ss_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4ss_ (*FuncToCall)(void*,const void* method);
    struct S_i4ss_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// PlasticGui.Gluon.WorkspaceWindow.Views.IncomingChanges.PendingConflictsLabelData GetPendingConflictsLabelData(Int32, Int32) declare in PlasticGui.Gluon.WorkspaceWindow.Views.IncomingChanges.BuildFilesSummaryData
bool w_S_i4ssb_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ssb_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4ssb_ (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    struct S_i4ssb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.IO.WaitForChangedResult WaitForChanged(System.IO.WatcherChangeTypes) declare in System.IO.FileSystemWatcher
bool w_S_i4ssb_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ssb_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_i4ssb_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_i4ssb_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.IO.WaitForChangedResult WaitForChanged(System.IO.WatcherChangeTypes, Int32) declare in System.IO.FileSystemWatcher
bool w_S_i4ssb_ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ssb_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_i4ssb_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct S_i4ssb_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.TextCore.FaceInfo GetFaceInfo() declare in UnityEngine.TextCore.LowLevel.FontEngine
bool w_S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.TextCore.FaceInfo get_faceInfo() declare in UnityEngine.TextCore.Text.FontAsset
bool w_S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.Text.Json.JsonReaderOptions get_Options() declare in System.Text.Json.JsonReaderState
bool w_S_i4u1bb_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4u1bb_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4u1bb_ (*FuncToCall)(void*,const void* method);
    struct S_i4u1bb_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color32 PassAndReturnColor32(UnityEngine.Color32) declare in UnityEditorInternal.InternalEditorUtility
bool w_S_i4u1u1u1u1_S_i4u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4u1u1u1u1_S_i4u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(apis, env, _sv0);
    S_i4u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4u1u1u1u1_ {};

    typedef struct S_i4u1u1u1u1_ (*FuncToCall)(struct S_i4u1u1u1u1_ p0, const void* method);
    struct S_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color32 Lerp(UnityEngine.Color32, UnityEngine.Color32, Single) declare in UnityEngine.Color32
bool w_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(apis, env, _sv0);
    S_i4u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4u1u1u1u1_ {};
    // JSValToCSVal struct
    S_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(apis, env, _sv1);
    S_i4u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4u1u1u1u1_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef struct S_i4u1u1u1u1_ (*FuncToCall)(struct S_i4u1u1u1u1_ p0, struct S_i4u1u1u1u1_ p1, float p2, const void* method);
    struct S_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color32 op_Implicit(UnityEngine.Color) declare in UnityEngine.Color32
bool w_S_i4u1u1u1u1_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4u1u1u1u1_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_i4u1u1u1u1_ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color32 get_Color() declare in Unity.Profiling.ProfilerCategory
bool w_S_i4u1u1u1u1_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i4u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct S_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color32 Multiply(UnityEngine.Color32, UnityEngine.Color32) declare in TMPro.TMPro_ExtensionMethods
bool w_S_i4u1u1u1u1_tS_i4u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4u1u1u1u1_tS_i4u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(apis, env, _sv0);
    S_i4u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4u1u1u1u1_ {};

    typedef struct S_i4u1u1u1u1_ (*FuncToCall)(void*,struct S_i4u1u1u1u1_ p0, const void* method);
    struct S_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Color32 Tint(UnityEngine.Color32, Single) declare in TMPro.TMPro_ExtensionMethods
bool w_S_i4u1u1u1u1_tr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4u1u1u1u1_tr4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_i4u1u1u1u1_ (*FuncToCall)(void*,float p0, const void* method);
    struct S_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Reporting.BuildSummary get_summary() declare in UnityEditor.Build.Reporting.BuildReport
bool w_S_i8S_u4u4u4u4_i4i4i4i4i4su4u8u8i4i4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8S_u4u4u4u4_i4i4i4i4i4su4u8u8i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i8S_u4u4u4u4_i4i4i4i4i4su4u8u8i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i8S_u4u4u4u4_i4i4i4i4i4su4u8u8i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan get_LeaseManagerPollTime() declare in System.Runtime.Remoting.Lifetime.LifetimeServices
bool w_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_i8_ (*FuncToCall)(const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan Parse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider) declare in System.TimeSpan
bool w_S_i8_S_S_p_i4_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_S_p_i4_Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef struct S_i8_ (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan ParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.TimeSpanStyles) declare in System.TimeSpan
bool w_S_i8_S_S_p_i4_S_S_p_i4_oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_S_p_i4_S_S_p_i4_oDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_i8_ (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan ParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.TimeSpanStyles) declare in System.TimeSpan
bool w_S_i8_S_S_p_i4_ooDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_S_p_i4_ooDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_i8_ (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan op_Subtraction(System.DateTimeOffset, System.DateTimeOffset) declare in System.DateTimeOffset
bool w_S_i8_S_S_u8_i2_S_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_S_u8_i2_S_S_u8_i2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};
    // JSValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};

    typedef struct S_i8_ (*FuncToCall)(struct S_S_u8_i2_ p0, struct S_S_u8_i2_ p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan op_UnaryNegation(System.TimeSpan) declare in System.TimeSpan
bool w_S_i8_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};

    typedef struct S_i8_ (*FuncToCall)(struct S_i8_ p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan op_Subtraction(System.TimeSpan, System.TimeSpan) declare in System.TimeSpan
bool w_S_i8_S_i8_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_i8_S_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef struct S_i8_ (*FuncToCall)(struct S_i8_ p0, struct S_i8_ p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan op_Multiply(System.TimeSpan, Double) declare in System.TimeSpan
bool w_S_i8_S_i8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_i8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_i8_ (*FuncToCall)(struct S_i8_ p0, double p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan op_Subtraction(System.DateTime, System.DateTime) declare in System.DateTime
bool w_S_i8_S_u8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_u8_S_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};

    typedef struct S_i8_ (*FuncToCall)(struct S_u8_ p0, struct S_u8_ p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan FromTicks(Int64) declare in System.TimeSpan
bool w_S_i8_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef struct S_i8_ (*FuncToCall)(int64_t p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_S_i8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_i8_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// JetBrains.Rd.RdId Define(System.Type, System.Nullable`1[System.Int64]) declare in JetBrains.Rd.RdId
bool w_S_i8_oDN_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_oDN_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal valuetype  with default
    N_bi8_ p1 = OptionalParameter<N_bi8_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_i8_ (*FuncToCall)(Il2CppObject* p0, struct N_bi8_ p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan FromDays(Double) declare in System.TimeSpan
bool w_S_i8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_i8_ (*FuncToCall)(double p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan op_Multiply(Double, System.TimeSpan) declare in System.TimeSpan
bool w_S_i8_r8S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_r8S_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef struct S_i8_ (*FuncToCall)(double p0, struct S_i8_ p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan CalculateRemainingTimeForTesting(Double, Int64) declare in Codice.Client.BaseCommands.BuildProgressSpeedAndRemainingTime
bool w_S_i8_r8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_r8i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef struct S_i8_ (*FuncToCall)(double p0, int64_t p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan Parse(System.String) declare in System.TimeSpan
bool w_S_i8_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_i8_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan Parse(System.String, System.IFormatProvider) declare in System.TimeSpan
bool w_S_i8_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_i8_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan ParseExact(System.String, System.String[], System.IFormatProvider) declare in System.TimeSpan
bool w_S_i8_soo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_soo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_i8_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan ParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.TimeSpanStyles) declare in System.TimeSpan
bool w_S_i8_sooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_sooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef struct S_i8_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan ParseExact(System.String, System.String, System.IFormatProvider) declare in System.TimeSpan
bool w_S_i8_sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_sso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_i8_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.TimeSpan ParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.TimeSpanStyles) declare in System.TimeSpan
bool w_S_i8_ssoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_ssoi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef struct S_i8_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

}

