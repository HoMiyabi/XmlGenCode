// Auto Gen

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "PuertsValueType.h"
#if defined(__EMSCRIPTEN__)
#include "pesapi_webgl.h"
using namespace pesapi::webglimpl;
#endif

namespace puerts
{


// Single HorizontalScrollbar(UnityEngine.Rect, Single, Single, Single, Single, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_r4S_r4r4r4r4_r4r4r4r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_r4r4r4r4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p0, float p1, float p2, float p3, float p4, Il2CppObject* p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Slider(UnityEngine.Rect, Single, Single, Single, Single, UnityEngine.GUIStyle, UnityEngine.GUIStyle, Boolean, Int32, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_r4S_r4r4r4r4_r4r4r4r4oobi4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_r4r4r4r4oobi4Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    auto TIp9 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (true) {
        if (js_args_len < 9) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (js_args_len > 9 && !DataTransfer::IsAssignable(apis, env, _sv9, TIp9, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal ref  with default
    Il2CppObject* p9 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 9, TIp9);
                

    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p0, float p1, float p2, float p3, float p4, Il2CppObject* p5, Il2CppObject* p6, bool p7, int32_t p8, Il2CppObject* p9, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single FloatField(UnityEngine.Rect, System.String, Single) declare in UnityEditor.EditorGUI
bool w_r4S_r4r4r4r4_sr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_sr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single FloatField(UnityEngine.Rect, System.String, Single, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_r4S_r4r4r4r4_sr4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_sr4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, float p2, Il2CppObject* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Slider(UnityEngine.Rect, System.String, Single, Single, Single) declare in UnityEditor.EditorGUI
bool w_r4S_r4r4r4r4_sr4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_sr4r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, float p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Determinant(UnityEngine.Matrix4x4) declare in UnityEngine.Matrix4x4
bool w_r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef float (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single op_Implicit(Unity.Mathematics.half) declare in Unity.Mathematics.half
bool w_r4S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef float (*FuncToCall)(struct S_u2_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(System.DateTime) declare in System.Convert
bool w_r4S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef float (*FuncToCall)(struct S_u8_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single DistanceToPolyLine(UnityEngine.Vector3[]) declare in UnityEditor.HandleUtility
bool w_r4VS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4VS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, true)) return false;
    }
    
    // JSValToCSVal valuetype params
    Il2CppArray* p0 = Params<S_r4r4r4_>::PackValueType(apis, env, info, TIp0, js_args_len, 0);
                

    typedef float (*FuncToCall)(Il2CppArray* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Min(Single[]) declare in UnityEngine.Mathf
bool w_r4Vr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4Vr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive params
    Il2CppArray* p0 = Params<float>::PackPrimitive(apis, env, info, TIp0, js_args_len, 0);
                

    typedef float (*FuncToCall)(Il2CppArray* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(Boolean) declare in System.Convert
bool w_r4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(bool p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(Char) declare in System.Convert
bool w_r4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4c");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(Il2CppChar p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(SByte) declare in System.Convert
bool w_r4i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(int8_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(Int16) declare in System.Convert
bool w_r4i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(int16_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Int32BitsToSingle(Int32) declare in System.BitConverter
bool w_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(int32_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Get(Int32, Int32) declare in UnityEngine.Rendering.HaltonSequence
bool w_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetPropertyHeight(UnityEditor.SerializedPropertyType, UnityEngine.GUIContent) declare in UnityEditor.EditorGUI
bool w_r4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef float (*FuncToCall)(int32_t p0, Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Evaluate(DG.Tweening.Ease, DG.Tweening.EaseFunction, Single, Single, Single, Single) declare in DG.Tweening.Core.Easing.EaseManager
bool w_r4i4or4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4or4r4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef float (*FuncToCall)(int32_t p0, Il2CppObject* p1, float p2, float p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetFloat(Int32, IntPtr, Puerts.IGetValueFromJs, IntPtr, Boolean) declare in Puerts.PrimitiveTypeTranslate
bool w_r4i4popb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4popb");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef float (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, void* p3, bool p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ScaleSlider(Int32, Single, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Single) declare in UnityEditor.Handles
bool w_r4i4r4S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4r4S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4r4");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);

    typedef float (*FuncToCall)(int32_t p0, float p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4r4_ p4, float p5, float p6, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ScaleValueHandle(Int32, Single, UnityEngine.Vector3, UnityEngine.Quaternion, Single, CapFunction, Single) declare in UnityEditor.Handles
bool w_r4i4r4S_r4r4r4_S_r4r4r4r4_r4or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4r4S_r4r4r4_S_r4r4r4r4_r4or4");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);

    typedef float (*FuncToCall)(int32_t p0, float p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, Il2CppObject* p5, float p6, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(Int64) declare in System.Convert
bool w_r4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(int64_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ConvertToSize(Int64, EnumUnitSize) declare in Codice.Client.Common.SizeConverter
bool w_r4i8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4i8i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(int64_t p0, int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ExtractInnerCone(UnityEngine.Light) declare in UnityEngine.Experimental.GlobalIllumination.LightmapperUtils
bool w_r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4o");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef float (*FuncToCall)(Il2CppObject* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetPropertyHeight(UnityEditor.SerializedProperty, Boolean) declare in UnityEditor.EditorGUI
bool w_r4ob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4ob");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(Il2CppObject* p0, bool p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetPadding(UnityEngine.Material, Boolean, Boolean) declare in TMPro.ShaderUtilities
bool w_r4obb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4obb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(Il2CppObject* p0, bool p1, bool p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(Byte[], Int32) declare in System.BitConverter
bool w_r4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetRangeLimits(UnityEngine.Shader, Int32, Int32) declare in UnityEditor.ShaderUtil
bool w_r4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4oi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetPropertyHeight(UnityEditor.SerializedProperty, UnityEngine.GUIContent) declare in UnityEditor.EditorGUI
bool w_r4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef float (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetPropertyHeight(UnityEditor.SerializedProperty, UnityEngine.GUIContent, Boolean) declare in UnityEditor.EditorGUI
bool w_r4oob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4oob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetLayoutProperty(UnityEngine.RectTransform, System.Func`2[UnityEngine.UI.ILayoutElement,System.Single], Single) declare in UnityEngine.UI.LayoutUtility
bool w_r4oor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4oor4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetLayoutProperty(UnityEngine.RectTransform, System.Func`2[UnityEngine.UI.ILayoutElement,System.Single], Single, UnityEngine.UI.ILayoutElement ByRef) declare in UnityEngine.UI.LayoutUtility
bool w_r4oor4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4oor4Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv3)); // object ref
    Il2CppObject** p3 = &up3;
        

    typedef float (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, float p2, Il2CppObject** p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, CSRefToJsValue(apis, env, TIp3, *p3));
    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single FloatField(UnityEngine.GUIContent, Single, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r4or4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4or4Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef float (*FuncToCall)(Il2CppObject* p0, float p1, Il2CppArray* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single FloatField(UnityEngine.GUIContent, Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r4or4oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4or4oVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef float (*FuncToCall)(Il2CppObject* p0, float p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Slider(UnityEngine.GUIContent, Single, Single, Single, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r4or4r4r4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4or4r4r4Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef float (*FuncToCall)(Il2CppObject* p0, float p1, float p2, float p3, Il2CppArray* p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Evaluate(DG.Tweening.Tween, Single, Single, Single, Single) declare in DG.Tweening.Core.Easing.EaseManager
bool w_r4or4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4or4r4r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef float (*FuncToCall)(Il2CppObject* p0, float p1, float p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetFloatArrayElement(IntPtr, Int32) declare in UnityEngine.AndroidJNI
bool w_r4pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(void* p0, int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetFloatField(IntPtr, IntPtr) declare in UnityEngine.AndroidJNI
bool w_r4pp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4pp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef float (*FuncToCall)(void* p0, void* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single CallFloatMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*) declare in UnityEngine.AndroidJNI
bool w_r4ppPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4ppPv");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef float (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single CallFloatMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue]) declare in UnityEngine.AndroidJNI
bool w_r4ppS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4ppS_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};

    typedef float (*FuncToCall)(void* p0, void* p1, struct S_S_p_i4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single CallFloatMethod(IntPtr, IntPtr, UnityEngine.jvalue[]) declare in UnityEngine.AndroidJNI
bool w_r4ppo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4ppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef float (*FuncToCall)(void* p0, void* p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(Single) declare in System.Convert
bool w_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(float p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single modf(Single, Single ByRef) declare in Unity.Mathematics.math
bool w_r4r4Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4Pr4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;

    typedef float (*FuncToCall)(float p0, float* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<float>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ScaleSlider(Single, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Single) declare in UnityEditor.Handles
bool w_r4r4S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4r4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef float (*FuncToCall)(float p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ScaleValueHandle(Single, UnityEngine.Vector3, UnityEngine.Quaternion, Single, CapFunction, Single) declare in UnityEditor.Handles
bool w_r4r4S_r4r4r4_S_r4r4r4r4_r4or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4S_r4r4r4_S_r4r4r4r4_r4or4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef float (*FuncToCall)(float p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, float p3, Il2CppObject* p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single FloatField(Single, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r4r4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4Vo");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef float (*FuncToCall)(float p0, Il2CppArray* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Round(Single, Int32) declare in System.MathF
bool w_r4r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(float p0, int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Round(Single, Int32, System.MidpointRounding) declare in System.MathF
bool w_r4r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(float p0, int32_t p1, int32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single FloatField(Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r4r4oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4oVo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef float (*FuncToCall)(float p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Max(Single, Single) declare in System.Math
bool w_r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(float p0, float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single SmoothDamp(Single, Single, Single ByRef, Single) declare in UnityEngine.Mathf
bool w_r4r4r4Pr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4Pr4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef float (*FuncToCall)(float p0, float p1, float* p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<float>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single SmoothDamp(Single, Single, Single ByRef, Single, Single) declare in UnityEngine.Mathf
bool w_r4r4r4Pr4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4Pr4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef float (*FuncToCall)(float p0, float p1, float* p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<float>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single SmoothDamp(Single, Single, Single ByRef, Single, Single, Single) declare in UnityEngine.Mathf
bool w_r4r4r4Pr4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4Pr4r4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef float (*FuncToCall)(float p0, float p1, float* p2, float p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<float>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single select(Single, Single, Boolean) declare in Unity.Mathematics.math
bool w_r4r4r4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(float p0, float p1, bool p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Clamp(Single, Single, Single) declare in System.Math
bool w_r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(float p0, float p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single HorizontalSlider(Single, Single, Single, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_r4r4r4r4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4Vo");
    
    auto TIp3 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef float (*FuncToCall)(float p0, float p1, float p2, Il2CppArray* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single EasedValue(Single, Single, Single, DG.Tweening.Ease) declare in DG.Tweening.DOVirtual
bool w_r4r4r4r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef float (*FuncToCall)(float p0, float p1, float p2, int32_t p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single EasedValue(Single, Single, Single, DG.Tweening.Ease, Single) declare in DG.Tweening.DOVirtual
bool w_r4r4r4r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4i4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef float (*FuncToCall)(float p0, float p1, float p2, int32_t p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single EasedValue(Single, Single, Single, DG.Tweening.Ease, Single, Single) declare in DG.Tweening.DOVirtual
bool w_r4r4r4r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4i4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef float (*FuncToCall)(float p0, float p1, float p2, int32_t p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single EasedValue(Single, Single, Single, UnityEngine.AnimationCurve) declare in DG.Tweening.DOVirtual
bool w_r4r4r4r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4o");
    
    auto TIp3 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef float (*FuncToCall)(float p0, float p1, float p2, Il2CppObject* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single HorizontalSlider(Single, Single, Single, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_r4r4r4r4ooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4ooVo");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len < 5) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        auto TIp5_V = il2cpp::vm::Class::GetElementClass(TIp5);if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5_V, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal ref params
    Il2CppArray* p5 = Params<void*>::PackRef(apis, env, info, TIp5, js_args_len, 5);
                

    typedef float (*FuncToCall)(float p0, float p1, float p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppArray* p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single EaseIn(Single, Single, Single, Single) declare in DG.Tweening.Core.Easing.Bounce
bool w_r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef float (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single HorizontalScrollbar(Single, Single, Single, Single, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_r4r4r4r4r4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4r4Vo");
    
    auto TIp4 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef float (*FuncToCall)(float p0, float p1, float p2, float p3, Il2CppArray* p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single HorizontalScrollbar(Single, Single, Single, Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_r4r4r4r4r4oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4r4oVo");
    
    auto TIp4 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len < 5) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        auto TIp5_V = il2cpp::vm::Class::GetElementClass(TIp5);if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5_V, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal ref params
    Il2CppArray* p5 = Params<void*>::PackRef(apis, env, info, TIp5, js_args_len, 5);
                

    typedef float (*FuncToCall)(float p0, float p1, float p2, float p3, Il2CppObject* p4, Il2CppArray* p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single remap(Single, Single, Single, Single, Single) declare in Unity.Mathematics.math
bool w_r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef float (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(Double) declare in System.Convert
bool w_r4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(double p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(System.String) declare in System.Convert
bool w_r4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(Il2CppString* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Parse(System.String, System.Globalization.NumberStyles) declare in System.Single
bool w_r4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4si4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider) declare in System.Single
bool w_r4si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4si4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef float (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(System.String, System.IFormatProvider) declare in System.Convert
bool w_r4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef float (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetFloat(System.String, Single) declare in UnityEngine.PlayerPrefs
bool w_r4sr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4sr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(Il2CppString* p0, float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single FloatField(System.String, Single, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r4sr4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4sr4Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef float (*FuncToCall)(Il2CppString* p0, float p1, Il2CppArray* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single FloatField(System.String, Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r4sr4oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4sr4oVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef float (*FuncToCall)(Il2CppString* p0, float p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Slider(System.String, Single, Single, Single, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r4sr4r4r4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4sr4r4r4Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef float (*FuncToCall)(Il2CppString* p0, float p1, float p2, float p3, Il2CppArray* p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetFloat(System.String, System.String) declare in Codice.Utils.ConfigurationManager
bool w_r4ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4ss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetFloat(System.String, System.String, Single) declare in Codice.Utils.ConfigurationManager
bool w_r4ssr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4ssr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ReadSingle() declare in System.IO.BinaryReader
bool w_r4t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4t");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef float (*FuncToCall)(void*,const void* method);
    float ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Duration(DG.Tweening.Tween, Boolean) declare in DG.Tweening.TweenExtensions
bool w_r4tDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tDb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef float (*FuncToCall)(void*,bool p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(System.Object) declare in System.Runtime.Serialization.FormatterConverter
bool w_r4tO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef float (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.NoOptions, Single, UnityEngine.Quaternion) declare in DG.Tweening.CustomPlugins.PureQuaternionPlugin
bool w_r4tS__r4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS__r4S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef float (*FuncToCall)(void*,struct S__ p0, float p1, struct S_r4r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.NoOptions, Single, Int32) declare in DG.Tweening.Plugins.IntPlugin
bool w_r4tS__r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS__r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,struct S__ p0, float p1, int32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.NoOptions, Single, Int64) declare in DG.Tweening.Plugins.LongPlugin
bool w_r4tS__r4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS__r4i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,struct S__ p0, float p1, int64_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.NoOptions, Single, UnityEngine.RectOffset) declare in DG.Tweening.Plugins.RectOffsetPlugin
bool w_r4tS__r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS__r4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef float (*FuncToCall)(void*,struct S__ p0, float p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.NoOptions, Single, Double) declare in DG.Tweening.Plugins.DoublePlugin
bool w_r4tS__r4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS__r4r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,struct S__ p0, float p1, double p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.NoOptions, Single, UInt64) declare in DG.Tweening.Plugins.UlongPlugin
bool w_r4tS__r4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS__r4u8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,struct S__ p0, float p1, uint64_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.ColorOptions, Single, UnityEngine.Color) declare in DG.Tweening.Plugins.ColorPlugin
bool w_r4tS_b_r4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_b_r4S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_b_* pp0 = DataTransfer::GetPointer<S_b_>(apis, env, _sv0);
    S_b_ p0 = pp0 ? *pp0 : S_b_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef float (*FuncToCall)(void*,struct S_b_ p0, float p1, struct S_r4r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.FloatOptions, Single, Single) declare in DG.Tweening.Plugins.FloatPlugin
bool w_r4tS_b_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_b_r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_b_* pp0 = DataTransfer::GetPointer<S_b_>(apis, env, _sv0);
    S_b_ p0 = pp0 ? *pp0 : S_b_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,struct S_b_ p0, float p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.UintOptions, Single, UInt32) declare in DG.Tweening.Plugins.UintPlugin
bool w_r4tS_b_r4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_b_r4u4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_b_* pp0 = DataTransfer::GetPointer<S_b_>(apis, env, _sv0);
    S_b_ p0 = pp0 ? *pp0 : S_b_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,struct S_b_ p0, float p1, uint32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.StringOptions, Single, System.String) declare in DG.Tweening.Plugins.StringPlugin
bool w_r4tS_bi4oi4i4_r4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_bi4oi4i4_r4s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4oi4i4_* pp0 = DataTransfer::GetPointer<S_bi4oi4i4_>(apis, env, _sv0);
    S_bi4oi4i4_ p0 = pp0 ? *pp0 : S_bi4oi4i4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,struct S_bi4oi4i4_ p0, float p1, Il2CppString* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.VectorOptions, Single, UnityEngine.Vector2) declare in DG.Tweening.Plugins.Vector2Plugin
bool w_r4tS_i4b_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_i4b_r4S_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4b_* pp0 = DataTransfer::GetPointer<S_i4b_>(apis, env, _sv0);
    S_i4b_ p0 = pp0 ? *pp0 : S_i4b_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef float (*FuncToCall)(void*,struct S_i4b_ p0, float p1, struct S_r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.VectorOptions, Single, UnityEngine.Vector3) declare in DG.Tweening.Plugins.Vector3Plugin
bool w_r4tS_i4b_r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_i4b_r4S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4b_* pp0 = DataTransfer::GetPointer<S_i4b_>(apis, env, _sv0);
    S_i4b_ p0 = pp0 ? *pp0 : S_i4b_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef float (*FuncToCall)(void*,struct S_i4b_ p0, float p1, struct S_r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.VectorOptions, Single, UnityEngine.Vector4) declare in DG.Tweening.Plugins.Vector4Plugin
bool w_r4tS_i4b_r4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_i4b_r4S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4b_* pp0 = DataTransfer::GetPointer<S_i4b_>(apis, env, _sv0);
    S_i4b_ p0 = pp0 ? *pp0 : S_i4b_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef float (*FuncToCall)(void*,struct S_i4b_ p0, float p1, struct S_r4r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.Vector3ArrayOptions, Single, UnityEngine.Vector3[]) declare in DG.Tweening.Plugins.Vector3ArrayPlugin
bool w_r4tS_i4bo_r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_i4bo_r4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4bo_* pp0 = DataTransfer::GetPointer<S_i4bo_>(apis, env, _sv0);
    S_i4bo_ p0 = pp0 ? *pp0 : S_i4bo_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef float (*FuncToCall)(void*,struct S_i4bo_ p0, float p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.QuaternionOptions, Single, UnityEngine.Vector3) declare in DG.Tweening.Plugins.QuaternionPlugin
bool w_r4tS_i4i4S_r4r4r4_bS_r4r4r4__r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_i4i4S_r4r4r4_bS_r4r4r4__r4S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4S_r4r4r4_bS_r4r4r4__* pp0 = DataTransfer::GetPointer<S_i4i4S_r4r4r4_bS_r4r4r4__>(apis, env, _sv0);
    S_i4i4S_r4r4r4_bS_r4r4r4__ p0 = pp0 ? *pp0 : S_i4i4S_r4r4r4_bS_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef float (*FuncToCall)(void*,struct S_i4i4S_r4r4r4_bS_r4r4r4__ p0, float p1, struct S_r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetMuscle(UnityEngine.Animations.MuscleHandle) declare in UnityEngine.Animations.AnimationHumanStream
bool w_r4tS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef float (*FuncToCall)(void*,struct S_i4i4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single CalculateMipBias(UnityEngine.Vector2Int, UnityEngine.Vector2Int, Boolean) declare in UnityEngine.Rendering.DynamicResolutionHandler
bool w_r4tS_i4i4_S_i4i4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_i4i4_S_i4i4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef float (*FuncToCall)(void*,struct S_i4i4_ p0, struct S_i4i4_ p1, bool p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetAnimationTime(UnityEngine.Vector3Int) declare in UnityEngine.Tilemaps.Tilemap
bool w_r4tS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef float (*FuncToCall)(void*,struct S_i4i4i4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.Options.PathOptions, Single, DG.Tweening.Plugins.Core.PathCore.Path) declare in DG.Tweening.Plugins.PathPlugin
bool w_r4tS_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_r4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_>(apis, env, _sv0);
    S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_ p0 = pp0 ? *pp0 : S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef float (*FuncToCall)(void*,struct S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_ p0, float p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSpeedBasedDuration(DG.Tweening.Plugins.CircleOptions, Single, UnityEngine.Vector2) declare in DG.Tweening.Plugins.CirclePlugin
bool w_r4tS_r4bbS_r4r4_r4r4b_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4bbS_r4r4_r4r4b_r4S_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4bbS_r4r4_r4r4b_* pp0 = DataTransfer::GetPointer<S_r4bbS_r4r4_r4r4b_>(apis, env, _sv0);
    S_r4bbS_r4r4_r4r4b_ p0 = pp0 ? *pp0 : S_r4bbS_r4r4_r4r4b_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef float (*FuncToCall)(void*,struct S_r4bbS_r4r4_r4r4b_ p0, float p1, struct S_r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single SqrDistance(UnityEngine.Vector3) declare in UnityEngine.Bounds
bool w_r4tS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef float (*FuncToCall)(void*,struct S_r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single PointOcclusion(UnityEngine.Vector3, UnityEngine.Vector3) declare in TreeEditor.TreeAOSphere
bool w_r4tS_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef float (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single TextureScaleOffsetProperty(UnityEngine.Rect, UnityEditor.MaterialProperty) declare in UnityEditor.MaterialEditor
bool w_r4tS_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef float (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single TextureScaleOffsetProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, Boolean) declare in UnityEditor.MaterialEditor
bool w_r4tS_r4r4r4r4_ob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4r4_ob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, bool p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single RangeProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, System.String) declare in UnityEditor.MaterialEditor
bool w_r4tS_r4r4r4r4_os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4r4_os");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetFloat(UnityEngine.Animations.AnimationStream) declare in UnityEngine.Animations.PropertyStreamHandle
bool w_r4tS_u4pppppp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_u4pppppp_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};

    typedef float (*FuncToCall)(void*,struct S_u4pppppp_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetLayerCost(Int32) declare in UnityEngine.AI.NavMeshAgent
bool w_r4ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(void*,int32_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetBlendShapeFrameWeight(Int32, Int32) declare in UnityEngine.Mesh
bool w_r4ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetItemMergedSamplesMetadataAsFloat(Int32, Int32, Int32) declare in UnityEditor.Profiling.HierarchyFrameDataView
bool w_r4ti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ReadSingle(Int64) declare in System.IO.UnmanagedMemoryAccessor
bool w_r4ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(void*,int64_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetPropertyHeight(UnityEditor.MaterialProperty) declare in UnityEditor.MaterialEditor
bool w_r4to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4to");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef float (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext) declare in UnityEngine.UIElements.UxmlFloatAttributeDescription
bool w_r4toS_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4toS_oooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};

    typedef float (*FuncToCall)(void*,Il2CppObject* p0, struct S_oooo_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetPropertyHeight(UnityEditor.SerializedProperty, UnityEngine.GUIContent) declare in UnityEditorInternal.MinMaxGradientPropertyDrawer
bool w_r4too(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4too");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef float (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single CalcHeight(UnityEngine.GUIContent, Single) declare in UnityEngine.GUIStyle
bool w_r4tor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tor4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(void*,Il2CppObject* p0, float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetRadiusAtTime(TreeEditor.TreeNode, Single, Boolean) declare in TreeEditor.TreeGroup
bool w_r4tor4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tor4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,Il2CppObject* p0, float p1, bool p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single RangeProperty(UnityEditor.MaterialProperty, System.String) declare in UnityEditor.MaterialEditor
bool w_r4tos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetPropertyHeight(UnityEditor.MaterialProperty, System.String, UnityEditor.MaterialEditor) declare in UnityEditor.MaterialPropertyDrawer
bool w_r4toso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4toso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef float (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Evaluate(Single) declare in UnityEngine.AnimationCurve
bool w_r4tr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(void*,float p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetInterpolatedHeight(Single, Single) declare in UnityEngine.TerrainData
bool w_r4tr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(void*,float p0, float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single Noise(Single, Single, Single) declare in TreeEditor.Perlin
bool w_r4tr4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single RidgedMultifractal(Single, Single, Single, Single) declare in TreeEditor.FractalNoise
bool w_r4tr4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4r4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef float (*FuncToCall)(void*,float p0, float p1, float p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single EvaluateMixOut(Double) declare in UnityEngine.Timeline.TimelineClip
bool w_r4tr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(void*,double p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetSingle(System.String) declare in System.Runtime.Serialization.SerializationInfo
bool w_r4ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetFloat(System.String, Boolean ByRef) declare in UnityEditor.MaterialEditor
bool w_r4tsPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tsPb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;

    typedef float (*FuncToCall)(void*,Il2CppString* p0, bool* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetPreferredWidth(System.String, UnityEngine.TextGenerationSettings) declare in UnityEngine.TextGenerator
bool w_r4tsS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tsS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_b_* pp1 = DataTransfer::GetPointer<S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_b_>(apis, env, _sv1);
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_b_ p1 = pp1 ? *pp1 : S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_b_ {};

    typedef float (*FuncToCall)(void*,Il2CppString* p0, struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_b_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetFloat(System.String, Single) declare in UnityEngine.RemoteConfigSettings
bool w_r4tsr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tsr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(void*,Il2CppString* p0, float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single FloatProperty(System.String, System.String) declare in UnityEditor.MaterialEditor
bool w_r4tss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single RangeProperty(System.String, System.String, Single, Single) declare in UnityEditor.MaterialEditor
bool w_r4tssr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tssr4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef float (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, float p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single GetDirectAudioVolume(UInt16) declare in UnityEngine.Video.VideoPlayer
bool w_r4tu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4tu2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(void*,uint16_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(Byte) declare in System.Convert
bool w_r4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(uint8_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(UInt16) declare in System.Convert
bool w_r4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(uint16_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(UInt32) declare in System.Convert
bool w_r4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(uint32_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Single ToSingle(UInt64) declare in System.Convert
bool w_r4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r4u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(uint64_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<float>::toScript(apis, env, ret));
    return true;
}

// Double get_dspTime() declare in UnityEngine.AudioSettings
bool w_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef double (*FuncToCall)(const void* method);
    double ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(System.Object) declare in System.Convert
bool w_r8O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8O");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef double (*FuncToCall)(Il2CppObject* p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(System.Object, System.IFormatProvider) declare in System.Convert
bool w_r8Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8Oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef double (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double VolatileRead(Double ByRef) declare in System.Threading.Thread
bool w_r8Pr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8Pr8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    double up0 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv0);
    double* p0 = &up0;

    typedef double (*FuncToCall)(double* p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<double>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double Exchange(Double ByRef, Double) declare in System.Threading.Interlocked
bool w_r8Pr8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8Pr8r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    double up0 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv0);
    double* p0 = &up0;
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(double* p0, double p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<double>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double CompareExchange(Double ByRef, Double, Double) declare in System.Threading.Interlocked
bool w_r8Pr8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8Pr8r8r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P primitive
    double up0 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv0);
    double* p0 = &up0;
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(double* p0, double p1, double p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<double>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(System.ReadOnlySpan`1[System.Byte]) declare in System.BitConverter
bool w_r8S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef double (*FuncToCall)(struct S_S_p_i4_ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider) declare in System.Double
bool w_r8S_S_p_i4_Di4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_S_p_i4_Di4Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef double (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double determinant(Unity.Mathematics.double2x2) declare in Unity.Mathematics.math
bool w_r8S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_S_r8r8_S_r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};

    typedef double (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double determinant(Unity.Mathematics.double3x3) declare in Unity.Mathematics.math
bool w_r8S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef double (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double determinant(Unity.Mathematics.double4x4) declare in Unity.Mathematics.math
bool w_r8S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef double (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double op_Explicit(System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlDouble
bool w_r8S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_br8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};

    typedef double (*FuncToCall)(struct S_br8_ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double op_Explicit(UnityEditor.Media.MediaRational) declare in UnityEditor.Media.MediaRational
bool w_r8S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef double (*FuncToCall)(struct S_i4i4_ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(System.Decimal) declare in System.Convert
bool w_r8S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef double (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double Log(System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_r8S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};

    typedef double (*FuncToCall)(struct S_i4o_ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double Log(System.Numerics.BigInteger, Double) declare in System.Numerics.BigInteger
bool w_r8S_i4o_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i4o_r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(struct S_i4o_ p0, double p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double op_Explicit(UnityEditor.Media.MediaTime) declare in UnityEditor.Media.MediaTime
bool w_r8S_i8S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i8S_i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8S_i4i4__* pp0 = DataTransfer::GetPointer<S_i8S_i4i4__>(apis, env, _sv0);
    S_i8S_i4i4__ p0 = pp0 ? *pp0 : S_i8S_i4i4__ {};

    typedef double (*FuncToCall)(struct S_i8S_i4i4__ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double op_Division(System.TimeSpan, System.TimeSpan) declare in System.TimeSpan
bool w_r8S_i8_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i8_S_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef double (*FuncToCall)(struct S_i8_ p0, struct S_i8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double DoubleField(UnityEngine.Rect, UnityEngine.GUIContent, Double) declare in UnityEditor.EditorGUI
bool w_r8S_r4r4r4r4_or8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r4r4r4r4_or8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, double p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double DoubleField(UnityEngine.Rect, UnityEngine.GUIContent, Double, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_r8S_r4r4r4r4_or8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r4r4r4r4_or8o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef double (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, double p2, Il2CppObject* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double DoubleField(UnityEngine.Rect, Double) declare in UnityEditor.EditorGUI
bool w_r8S_r4r4r4r4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r4r4r4r4_r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(struct S_r4r4r4r4_ p0, double p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double DoubleField(UnityEngine.Rect, Double, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_r8S_r4r4r4r4_r8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r4r4r4r4_r8o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef double (*FuncToCall)(struct S_r4r4r4r4_ p0, double p1, Il2CppObject* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double DoubleField(UnityEngine.Rect, System.String, Double) declare in UnityEditor.EditorGUI
bool w_r8S_r4r4r4r4_sr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r4r4r4r4_sr8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, double p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double DoubleField(UnityEngine.Rect, System.String, Double, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_r8S_r4r4r4r4_sr8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r4r4r4r4_sr8o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef double (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, double p2, Il2CppObject* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double Abs(System.Numerics.Complex) declare in System.Numerics.Complex
bool w_r8S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};

    typedef double (*FuncToCall)(struct S_r8r8_ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double dot(Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_r8S_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r8r8_S_r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef double (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double shuffle(Unity.Mathematics.double2, Unity.Mathematics.double2, ShuffleComponent) declare in Unity.Mathematics.math
bool w_r8S_r8r8_S_r8r8_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r8r8_S_r8r8_u1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, uint8_t p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double length(Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_r8S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};

    typedef double (*FuncToCall)(struct S_r8r8r8_ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double dot(Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_r8S_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r8r8r8_S_r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef double (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double shuffle(Unity.Mathematics.double3, Unity.Mathematics.double3, ShuffleComponent) declare in Unity.Mathematics.math
bool w_r8S_r8r8r8_S_r8r8r8_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r8r8r8_S_r8r8r8_u1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, uint8_t p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double length(Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_r8S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r8r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};

    typedef double (*FuncToCall)(struct S_r8r8r8r8_ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double dot(Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_r8S_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};

    typedef double (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double shuffle(Unity.Mathematics.double4, Unity.Mathematics.double4, ShuffleComponent) declare in Unity.Mathematics.math
bool w_r8S_r8r8r8r8_S_r8r8r8r8_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r8r8r8r8_S_r8r8r8r8_u1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, uint8_t p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double op_Implicit(Unity.Mathematics.half) declare in Unity.Mathematics.half
bool w_r8S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef double (*FuncToCall)(struct S_u2_ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(System.DateTime) declare in System.Convert
bool w_r8S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef double (*FuncToCall)(struct S_u8_ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(Boolean) declare in System.Convert
bool w_r8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(bool p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetNumericValue(Char) declare in System.Char
bool w_r8c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8c");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(Il2CppChar p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(SByte) declare in System.Convert
bool w_r8i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(int8_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(Int16) declare in System.Convert
bool w_r8i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(int16_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(Int32) declare in System.Convert
bool w_r8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(int32_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double CalculateProgress(Codice.CM.Common.Replication.EnumReplicationStatus, Codice.CM.Common.Replication.EnumReplicationStatus, Codice.CM.Common.Replication.EnumReplicationStatus) declare in Codice.Client.Common.ReplicationProgress
bool w_r8i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetDouble(Int32, IntPtr, Puerts.IGetValueFromJs, IntPtr, Boolean) declare in Puerts.PrimitiveTypeTranslate
bool w_r8i4popb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8i4popb");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef double (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, void* p3, bool p4, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double Int64BitsToDouble(Int64) declare in System.BitConverter
bool w_r8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(int64_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double CalculateSpeedInMbpsForTesting(Int64, Int64, Double) declare in Codice.Client.BaseCommands.BuildProgressSpeedAndRemainingTime
bool w_r8i8i8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8i8i8r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(int64_t p0, int64_t p1, double p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(System.Xml.XPath.XPathItem) declare in System.Xml.Xsl.Runtime.XsltConvert
bool w_r8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8o");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef double (*FuncToCall)(Il2CppObject* p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(Byte[], Int32) declare in System.BitConverter
bool w_r8oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetChangesPerUnit(Codice.CM.Client.Differences.IDiffComparable, Codice.CM.Client.Differences.IDiffComparable, Double) declare in Codice.CM.Client.Differences.FileDiff
bool w_r8oor8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8oor8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, double p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double DoubleField(UnityEngine.GUIContent, Double, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r8or8Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8or8Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef double (*FuncToCall)(Il2CppObject* p0, double p1, Il2CppArray* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double DoubleField(UnityEngine.GUIContent, Double, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r8or8oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8or8oVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef double (*FuncToCall)(Il2CppObject* p0, double p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetNumberFromResult(IntPtr) declare in Puerts.PuertsDLL
bool w_r8p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8p");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef double (*FuncToCall)(void* p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetDoubleArrayElement(IntPtr, Int32) declare in UnityEngine.AndroidJNI
bool w_r8pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(void* p0, int32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetDoubleField(IntPtr, IntPtr) declare in UnityEngine.AndroidJNI
bool w_r8pp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8pp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef double (*FuncToCall)(void* p0, void* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double CallDoubleMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*) declare in UnityEngine.AndroidJNI
bool w_r8ppPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ppPv");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef double (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double CallDoubleMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue]) declare in UnityEngine.AndroidJNI
bool w_r8ppS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ppS_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};

    typedef double (*FuncToCall)(void* p0, void* p1, struct S_S_p_i4_ p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetNumberFromValue(IntPtr, IntPtr, Boolean) declare in Puerts.PuertsDLL
bool w_r8ppb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ppb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(void* p0, void* p1, bool p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double CallDoubleMethod(IntPtr, IntPtr, UnityEngine.jvalue[]) declare in UnityEngine.AndroidJNI
bool w_r8ppo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef double (*FuncToCall)(void* p0, void* p1, Il2CppObject* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double pesapi_get_value_double(IntPtr, IntPtr, IntPtr) declare in Puerts.NativeAPI
bool w_r8ppp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ppp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef double (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(Single) declare in System.Convert
bool w_r8r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(float p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(Double) declare in System.Convert
bool w_r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(double p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double modf(Double, Double ByRef) declare in Unity.Mathematics.math
bool w_r8r8Pr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8Pr8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    double up1 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv1);
    double* p1 = &up1;

    typedef double (*FuncToCall)(double p0, double* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<double>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double DoubleField(Double, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r8r8Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8Vo");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef double (*FuncToCall)(double p0, Il2CppArray* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double Round(Double, Int32) declare in System.Math
bool w_r8r8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(double p0, int32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double Round(Double, Int32, System.MidpointRounding) declare in System.Math
bool w_r8r8i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(double p0, int32_t p1, int32_t p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double DoubleField(Double, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r8r8oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8oVo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef double (*FuncToCall)(double p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double IEEERemainder(Double, Double) declare in System.Math
bool w_r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(double p0, double p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double select(Double, Double, Boolean) declare in Unity.Mathematics.math
bool w_r8r8r8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8r8b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(double p0, double p1, bool p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double Clamp(Double, Double, Double) declare in System.Math
bool w_r8r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8r8r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(double p0, double p1, double p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double remap(Double, Double, Double, Double, Double) declare in Unity.Mathematics.math
bool w_r8r8r8r8r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8r8r8r8r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    double p4 = converter::Converter<double>::toCpp(apis, env, _sv4);

    typedef double (*FuncToCall)(double p0, double p1, double p2, double p3, double p4, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(System.String) declare in System.Convert
bool w_r8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(Il2CppString* p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetScrollXPosition(System.String, System.Guid) declare in GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.WorkspaceExplorerSettings
bool w_r8sS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8sS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef double (*FuncToCall)(Il2CppString* p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetNumericValue(System.String, Int32) declare in System.Char
bool w_r8si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8si4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider) declare in System.Double
bool w_r8si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8si4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef double (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(System.String, System.IFormatProvider) declare in System.Convert
bool w_r8so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef double (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double DoubleField(System.String, Double, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r8sr8Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8sr8Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef double (*FuncToCall)(Il2CppString* p0, double p1, Il2CppArray* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double DoubleField(System.String, Double, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_r8sr8oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8sr8oVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef double (*FuncToCall)(Il2CppString* p0, double p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetDouble(System.String, System.String) declare in Codice.Utils.ConfigurationManager
bool w_r8ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetChangesPerUnit(System.String, System.String, Codice.CM.Client.Differences.ComparisonMethodTypes, System.Text.Encoding, Double) declare in Codice.CM.Client.Differences.FileDiff
bool w_r8ssi4or8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ssi4or8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    double p4 = converter::Converter<double>::toCpp(apis, env, _sv4);

    typedef double (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int32_t p2, Il2CppObject* p3, double p4, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetDouble(System.String, System.String, Double) declare in Codice.Utils.ConfigurationManager
bool w_r8ssr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ssr8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, double p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double MSStringCompare(System.String, System.String, System.String, System.String) declare in System.Xml.Xsl.Runtime.XsltFunctions
bool w_r8ssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ssss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef double (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToOADate() declare in System.DateTime
bool w_r8t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8t");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef double (*FuncToCall)(void*,const void* method);
    double ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetCurrentTime(Context) declare in UnityEditor.Timeline.TimelinePlaybackControls
bool w_r8tDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tDi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef double (*FuncToCall)(void*,int32_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetNumberValue(Double) declare in UnityEditor.Search.SearchExpression
bool w_r8tDr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tDr8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    double p0 = OptionalParameter<double>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef double (*FuncToCall)(void*,double p0, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(System.Object) declare in System.Runtime.Serialization.FormatterConverter
bool w_r8tO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef double (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double Divide(System.TimeSpan) declare in System.TimeSpan
bool w_r8tS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};

    typedef double (*FuncToCall)(void*,struct S_i8_ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetMilliseconds(System.DateTime) declare in System.Globalization.Calendar
bool w_r8tS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef double (*FuncToCall)(void*,struct S_u8_ p0, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetFrameStartS(Int32) declare in UnityEditorInternal.ProfilerFrameDataIterator
bool w_r8ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ti4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(void*,int32_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetItemColumnDataAsDouble(Int32, Int32) declare in UnityEditor.Profiling.HierarchyFrameDataView
bool w_r8ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ti4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ReadDouble(Int64) declare in System.IO.UnmanagedMemoryAccessor
bool w_r8ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ti8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(void*,int64_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext) declare in UnityEngine.UIElements.UxmlDoubleAttributeDescription
bool w_r8toS_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8toS_oooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};

    typedef double (*FuncToCall)(void*,Il2CppObject* p0, struct S_oooo_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ConvertToStartValue(DG.Tweening.Core.TweenerCore`3[System.Double,System.Double,DG.Tweening.Plugins.Options.NoOptions], Double) declare in DG.Tweening.Plugins.DoublePlugin
bool w_r8tor8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tor8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(void*,Il2CppObject* p0, double p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetDate(IntPtr, IntPtr, Boolean) declare in Puerts.GetValueFromResultImpl
bool w_r8tppb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tppb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef double (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double Adjust(Double) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_r8tr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tr8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(void*,double p0, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double NextDouble(Double, Double) declare in Unity.Mathematics.Random
bool w_r8tr8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tr8r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(void*,double p0, double p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetDouble(System.String) declare in System.Runtime.Serialization.SerializationInfo
bool w_r8ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetDouble(System.String, Single) declare in Codice.Utils.ConfigurationSection
bool w_r8tsr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tsr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(void*,Il2CppString* p0, float p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double GetDouble(System.String, Double) declare in Codice.Utils.ConfigurationSection
bool w_r8tsr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tsr8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(void*,Il2CppString* p0, double p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ReadElementContentAsDouble(System.String, System.String) declare in System.Xml.XmlReader
bool w_r8tss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef double (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double RegisterDecimalFormatter(System.String, System.String, System.String, System.String) declare in System.Xml.Xsl.Runtime.XsltLibrary
bool w_r8tssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8tssss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef double (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(Byte) declare in System.Convert
bool w_r8u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(uint8_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(UInt16) declare in System.Convert
bool w_r8u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(uint16_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(UInt32) declare in System.Convert
bool w_r8u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(uint32_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// Double ToDouble(UInt64) declare in System.Convert
bool w_r8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_r8u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(uint64_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<double>::toScript(apis, env, ret));
    return true;
}

// System.String get_BaseDirectory() declare in System.AppContext
bool w_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_s");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef Il2CppString* (*FuncToCall)(const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Concat(System.Object) declare in System.String
bool w_sO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Concat(System.Object, System.Object) declare in System.String
bool w_sOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Concat(System.Object, System.Object, System.Object) declare in System.String
bool w_sOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Concat(System.Object, System.Object, System.Object, System.Object, ...) declare in System.String
bool w_sOOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOOOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String SerializeObject(System.Object, Unity.Plastic.Newtonsoft.Json.JsonConverter[]) declare in Unity.Plastic.Newtonsoft.Json.JsonConvert
bool w_sOVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToJson(System.Object, Boolean) declare in UnityEngine.JsonUtility
bool w_sOb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String SerializeObject(System.Object, Unity.Plastic.Newtonsoft.Json.Formatting) declare in Unity.Plastic.Newtonsoft.Json.JsonConvert
bool w_sOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String SerializeObject(System.Object, Unity.Plastic.Newtonsoft.Json.Formatting, Unity.Plastic.Newtonsoft.Json.JsonConverter[]) declare in Unity.Plastic.Newtonsoft.Json.JsonConvert
bool w_sOi4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOi4Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String SerializeObject(System.Object, Unity.Plastic.Newtonsoft.Json.Formatting, Unity.Plastic.Newtonsoft.Json.JsonSerializerSettings) declare in Unity.Plastic.Newtonsoft.Json.JsonConvert
bool w_sOi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.Object, System.IFormatProvider) declare in System.Convert
bool w_sOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Serialize(System.Object, System.Type, System.Text.Json.JsonSerializerOptions) declare in System.Text.Json.JsonSerializer
bool w_sOoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOoDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String SerializeObject(System.Object, System.Type, Unity.Plastic.Newtonsoft.Json.Formatting, Unity.Plastic.Newtonsoft.Json.JsonSerializerSettings) declare in Unity.Plastic.Newtonsoft.Json.JsonConvert
bool w_sOoi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOoi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Serialize(System.Object, System.Type, System.Text.Json.Serialization.JsonSerializerContext) declare in System.Text.Json.JsonSerializer
bool w_sOoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ConvertDefaultValueToString(System.Object, System.String) declare in Puerts.Editor.Generator.Wrapper.ParameterGenInfo
bool w_sOs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sOs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetAssetPath(UnityEditor.Search.SearchItem ByRef) declare in UnityEditor.Search.SearchUtils
bool w_sPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sPo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        

    typedef Il2CppString* (*FuncToCall)(Il2CppObject** p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String op_Implicit(Microsoft.Extensions.Primitives.StringValues) declare in Microsoft.Extensions.Primitives.StringValues
bool w_sS_O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_O_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_O_* pp0 = DataTransfer::GetPointer<S_O_>(apis, env, _sv0);
    S_O_ p0 = pp0 ? *pp0 : S_O_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_O_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToBase64String(System.ReadOnlySpan`1[System.Byte], System.Base64FormattingOptions) declare in System.Convert
bool w_sS_S_p_i4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String HashDataToString(System.ReadOnlySpan`1[System.Object], System.Text.Json.JsonSerializerOptions) declare in Microsoft.Extensions.AI.AIJsonUtilities
bool w_sS_S_p_i4_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Join(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char]) declare in System.IO.Path
bool w_sS_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Join(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char]) declare in System.IO.Path
bool w_sS_S_p_i4_S_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_S_S_p_i4_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.DateTimeOffset) declare in System.Xml.XmlConvert
bool w_sS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_u8_i2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_S_u8_i2_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.DateTimeOffset, Newtonsoft.Json.DateFormatHandling) declare in Newtonsoft.Json.JsonConvert
bool w_sS_S_u8_i2_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_u8_i2_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(struct S_S_u8_i2_ p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.DateTimeOffset, System.String) declare in System.Xml.XmlConvert
bool w_sS_S_u8_i2_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_u8_i2_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(struct S_S_u8_i2_ p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String op_Explicit(UnityEngine.Rendering.ShaderTagId) declare in UnityEngine.Rendering.ShaderTagId
bool w_sS_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_i4_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.Guid) declare in System.Xml.XmlConvert
bool w_sS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String DownloadRemotePackage(System.Guid, Codice.CM.Interfaces.IReplicationHandler, System.String, DownloadPackageProgressDelegate) declare in Codice.CM.Common.Serialization.Replication.PackageIO
bool w_sS_i4i2i2u1u1u1u1u1u1u1u1_oso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4i2i2u1u1u1u1u1u1u1u1_oso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetChangesToApplyCaption(ChangesToApplySummary) declare in PlasticGui.WorkspaceWindow.Merge.MergeViewTexts
bool w_sS_i4i4i4i4i8i8i8i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4i4i4i4i8i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4i8i8i8i8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i8i8i8i8_>(apis, env, _sv0);
    S_i4i4i4i4i8i8i8i8_ p0 = pp0 ? *pp0 : S_i4i4i4i4i8i8i8i8_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_i4i4i4i4i8i8i8i8_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.Decimal) declare in System.Convert
bool w_sS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.Decimal, System.IFormatProvider) declare in System.Convert
bool w_sS_i4i4i4i4u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4i4i4i4u8_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(struct S_i4i4i4i4u8_ p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.TimeSpan) declare in System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDuration
bool w_sS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_i8_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetProgressString(Codice.Client.Commands.UpdateOperationStatus, ProgressData) declare in PlasticGui.WorkspaceWindow.Update.UpdateProgressRender
bool w_sS_i8i8i8i8bb_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i8i8i8i8bb_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i8i8i8i8bb_* pp0 = DataTransfer::GetPointer<S_i8i8i8i8bb_>(apis, env, _sv0);
    S_i8i8i8i8bb_ p0 = pp0 ? *pp0 : S_i8i8i8i8bb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(struct S_i8i8i8i8bb_ p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetProgressString(Codice.Client.Commands.UpdateOperationStatus, ProgressData, System.DateTime, Double, System.String, System.String, System.String, System.String, System.String) declare in PlasticGui.WorkspaceWindow.Update.UpdateProgressRender
bool w_sS_i8i8i8i8bb_oS_u8_r8sssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i8i8i8i8bb_oS_u8_r8sssss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal struct
    S_i8i8i8i8bb_* pp0 = DataTransfer::GetPointer<S_i8i8i8i8bb_>(apis, env, _sv0);
    S_i8i8i8i8bb_ p0 = pp0 ? *pp0 : S_i8i8i8i8bb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);
    // JSValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6);
    // JSValToCSVal s
    Il2CppString* p7 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv7);
    // JSValToCSVal s
    Il2CppString* p8 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv8);

    typedef Il2CppString* (*FuncToCall)(struct S_i8i8i8i8bb_ p0, Il2CppObject* p1, struct S_u8_ p2, double p3, Il2CppString* p4, Il2CppString* p5, Il2CppString* p6, Il2CppString* p7, Il2CppString* p8, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetWriterName(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) declare in Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle
bool w_sS_pi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_pi4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pi4i4_* pp0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, _sv0);
    S_pi4i4_ p0 = pp0 ? *pp0 : S_pi4i4_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_pi4i4_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetReaderName(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, Int32) declare in Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle
bool w_sS_pi4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_pi4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_pi4i4_* pp0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, _sv0);
    S_pi4i4_ p0 = pp0 ? *pp0 : S_pi4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(struct S_pi4i4_ p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToHtmlStringRGB(UnityEngine.Color) declare in UnityEngine.ColorUtility
bool w_sS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String DelayedTextField(UnityEngine.Rect, UnityEngine.GUIContent, Int32, System.String) declare in UnityEditor.EditorGUI
bool w_sS_r4r4r4r4_oi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_oi4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String DelayedTextField(UnityEngine.Rect, UnityEngine.GUIContent, Int32, System.String, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_sS_r4r4r4r4_oi4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_oi4so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(UnityEngine.Rect, UnityEngine.GUIContent, System.String) declare in UnityEditor.EditorGUI
bool w_sS_r4r4r4r4_os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(UnityEngine.Rect, UnityEngine.GUIContent, System.String, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_sS_r4r4r4r4_oso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_oso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(UnityEngine.Rect, System.String) declare in UnityEngine.GUI
bool w_sS_r4r4r4r4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PasswordField(UnityEngine.Rect, System.String, Char) declare in UnityEngine.GUI
bool w_sS_r4r4r4r4_sc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_sc");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppChar p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PasswordField(UnityEngine.Rect, System.String, Char, Int32) declare in UnityEngine.GUI
bool w_sS_r4r4r4r4_sci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_sci4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppChar p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PasswordField(UnityEngine.Rect, System.String, Char, Int32, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_sS_r4r4r4r4_sci4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_sci4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppChar p2, int32_t p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PasswordField(UnityEngine.Rect, System.String, Char, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_sS_r4r4r4r4_sco(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_sco");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppChar p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(UnityEngine.Rect, System.String, Int32) declare in UnityEngine.GUI
bool w_sS_r4r4r4r4_si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_si4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(UnityEngine.Rect, System.String, Int32, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_sS_r4r4r4r4_si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_si4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(UnityEngine.Rect, System.String, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_sS_r4r4r4r4_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(UnityEngine.Rect, System.String, System.String) declare in UnityEditor.EditorGUI
bool w_sS_r4r4r4r4_ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(UnityEngine.Rect, System.String, System.String, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_sS_r4r4r4r4_sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_sso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetScriptingDefineSymbols(UnityEditor.Build.NamedBuildTarget) declare in UnityEditor.PlayerSettings
bool w_sS_s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_s_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_s_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String op_Explicit(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlString
bool w_sS_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_soi4i4b_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetGlobalKeywordName(UnityEngine.Rendering.ShaderKeyword) declare in UnityEngine.Rendering.ShaderKeyword
bool w_sS_su4bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_su4bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_su4bbb_* pp0 = DataTransfer::GetPointer<S_su4bbb_>(apis, env, _sv0);
    S_su4bbb_ p0 = pp0 ? *pp0 : S_su4bbb_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_su4bbb_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.Collections.Specialized.BitVector32) declare in System.Collections.Specialized.BitVector32
bool w_sS_u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4_* pp0 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv0);
    S_u4_ p0 = pp0 ? *pp0 : S_u4_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_u4_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String NewFileName(Codice.CM.Common.RepId, Int64, UInt64, System.String) declare in Codice.CM.Common.Serialization.ExternalDataInfo
bool w_sS_u4u4_i8u8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u4u4_i8u8s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(struct S_u4u4_ p0, int64_t p1, uint64_t p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GUIDToAssetPath(UnityEditor.GUID) declare in UnityEditor.AssetDatabase
bool w_sS_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_u4u4u4u4_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.DateTime) declare in System.Convert
bool w_sS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetLongTimeAgoString(System.DateTime, System.DateTime) declare in Codice.Client.Common.Time
bool w_sS_u8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_S_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};

    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p0, struct S_u8_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GenerateFilterName(System.DateTime, System.DateTime, Boolean, System.Collections.Generic.List`1[System.String]) declare in Codice.Client.BaseCommands.LayoutFilters.DateFilter
bool w_sS_u8_S_u8_bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_S_u8_bo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p0, struct S_u8_ p1, bool p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.DateTime, System.Xml.XmlDateTimeSerializationMode) declare in System.Xml.XmlConvert
bool w_sS_u8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.DateTime, Unity.Plastic.Newtonsoft.Json.DateFormatHandling, Unity.Plastic.Newtonsoft.Json.DateTimeZoneHandling) declare in Unity.Plastic.Newtonsoft.Json.JsonConvert
bool w_sS_u8_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p0, int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.DateTime, System.IFormatProvider) declare in System.Convert
bool w_sS_u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.DateTime, System.String) declare in System.Xml.XmlConvert
bool w_sS_u8_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString() declare in System.Object
bool w_sT(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sT");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef Il2CppString* (*FuncToCall)(void*,const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Concat(System.Object[]) declare in System.String
bool w_sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
    }
    
    // JSValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, js_args_len, 0);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppArray* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Concat(System.String[]) declare in System.String
bool w_sVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sVs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal string params
    Il2CppArray* p0 = Params<void*>::PackString(apis, env, info, TIp0, js_args_len, 0);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppArray* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Boolean) declare in System.Convert
bool w_sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(bool p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetProcessMergeButtonText(Boolean, Boolean) declare in PlasticGui.WorkspaceWindow.Merge.MergeViewTexts
bool w_sbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(bool p0, bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetProcessMergesButtonText(Boolean, Boolean, Boolean) declare in PlasticGui.WorkspaceWindow.Merge.MergeViewTexts
bool w_sbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sbbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(bool p0, bool p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetPendingDirectoryConflictsWarning(Boolean, Int32, Boolean) declare in PlasticGui.WorkspaceWindow.Merge.MergeViewTexts
bool w_sbi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sbi4b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(bool p0, int32_t p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Boolean, System.IFormatProvider) declare in System.Convert
bool w_sbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sbo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(bool p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetRemainingTimeStringForTesting(Boolean, Double, Int64, System.String) declare in Codice.Client.BaseCommands.BuildProgressSpeedAndRemainingTime
bool w_sbr8i8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sbr8i8s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(bool p0, double p1, int64_t p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Char) declare in System.Char
bool w_sc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sc");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(Il2CppChar p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Join(Char, System.Object[]) declare in System.String
bool w_scVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_scVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppChar p0, Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Join(Char, System.String[]) declare in System.String
bool w_scVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_scVs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppChar p0, Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Char, System.IFormatProvider) declare in System.Convert
bool w_sco(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sco");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppChar p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Join(Char, System.String[], Int32, Int32) declare in System.String
bool w_scoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_scoi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppChar p0, Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetTranslatedOSPath(Char, System.String) declare in Codice.Client.Commands.Matcher.PathConverter
bool w_scs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_scs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppChar p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(SByte) declare in System.Convert
bool w_si1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(int8_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(SByte, System.IFormatProvider) declare in System.Convert
bool w_si1o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si1o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int8_t p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Int16) declare in System.Convert
bool w_si2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(int16_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Int16, Int32) declare in System.Convert
bool w_si2i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si2i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int16_t p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Int16, System.IFormatProvider) declare in System.Convert
bool w_si2o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si2o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int16_t p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ConvertFromUtf32(Int32) declare in System.Char
bool w_si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String DoPasswordField(Int32, UnityEngine.Rect, UnityEngine.GUIContent, System.String, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_si4S_r4r4r4r4_oso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4S_r4r4r4r4_oso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String DoPasswordField(Int32, UnityEngine.Rect, System.String, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_si4S_r4r4r4r4_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4S_r4r4r4r4_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetString(Name, System.Object[]) declare in Codice.Client.BaseCommands.BaseCommandsLocalization
bool w_si4VO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4VO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(int32_t p0, Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetFileConflictsCaption(Int32, Boolean) declare in PlasticGui.WorkspaceWindow.Merge.MergeViewTexts
bool w_si4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Int32, Int32) declare in System.Convert
bool w_si4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetPlaybackEngineDirectory(UnityEditor.BuildTarget, UnityEditor.BuildOptions, Boolean) declare in UnityEditor.BuildPipeline
bool w_si4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, int32_t p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetPlaybackEngineDirectory(UnityEditor.BuildTargetGroup, UnityEditor.BuildTarget, UnityEditor.BuildOptions) declare in UnityEditor.BuildPipeline
bool w_si4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetTextureAutoName(Int32, Int32, UnityEngine.TextureFormat, UnityEngine.Rendering.TextureDimension, System.String, Boolean, Int32) declare in UnityEngine.Rendering.CoreUtils
bool w_si4i4i4Di4DsDbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4i4Di4DsDbDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal string  with default
    Il2CppString* p4 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef Il2CppString* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, Il2CppString* p4, bool p5, int32_t p6, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetPlaybackEngineDirectory(UnityEditor.BuildTargetGroup, UnityEditor.BuildTarget, UnityEditor.BuildOptions, Boolean) declare in UnityEditor.BuildPipeline
bool w_si4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4i4b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, bool p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetRenderTargetAutoName(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, UnityEngine.Rendering.TextureDimension, System.String, Boolean, Boolean, UnityEngine.Rendering.MSAASamples, Boolean) declare in UnityEngine.Rendering.CoreUtils
bool w_si4i4i4i4i4sDbDbDi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4i4i4i4sDbDbDi4Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (true) {
        if (js_args_len < 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (js_args_len > 8 && !converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (js_args_len > 9 && !converter::Converter<bool>::accept(apis, env, _sv9)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);
    // JSValToCSVal primitive with default
    bool p6 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    bool p7 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                
    // JSValToCSVal primitive with default
    int32_t p8 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 8);
                
    // JSValToCSVal primitive with default
    bool p9 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 9);
                

    typedef Il2CppString* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, Il2CppString* p5, bool p6, bool p7, int32_t p8, bool p9, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetRenderTargetAutoName(Int32, Int32, Int32, UnityEngine.RenderTextureFormat, System.String, Boolean, Boolean, UnityEngine.Rendering.MSAASamples) declare in UnityEngine.Rendering.CoreUtils
bool w_si4i4i4i4sDbDbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4i4i4sDbDbDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (true) {
        if (js_args_len < 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    bool p6 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                

    typedef Il2CppString* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, Il2CppString* p4, bool p5, bool p6, int32_t p7, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetFormattedCounterValue(Int32, UnityEngine.Profiling.ProfilerArea, System.String) declare in UnityEditorInternal.ProfilerDriver
bool w_si4i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, int32_t p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String BuildString(Int32, Int64) declare in GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Configuration.DownloadInfoString
bool w_si4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, int64_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Int32, System.IFormatProvider) declare in System.Convert
bool w_si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetString(Int32, IntPtr, Puerts.IGetValueFromJs, IntPtr, Boolean) declare in Puerts.PrimitiveTypeTranslate
bool w_si4popb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4popb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, void* p3, bool p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetSpec(LinkType, System.String) declare in PlasticGui.Diff.GetDiffPlasticLinkSpec
bool w_si4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetFormattedCounterValue(Int32, System.String, System.String) declare in UnityEditorInternal.ProfilerDriver
bool w_si4ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String RaiseContractFailedEvent(System.Diagnostics.Contracts.ContractFailureKind, System.String, System.String, System.Exception) declare in System.Runtime.CompilerServices.ContractHelper
bool w_si4sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si4sso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(int32_t p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Int64) declare in System.Convert
bool w_si8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(int64_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Int64, Int32) declare in System.Convert
bool w_si8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si8i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int64_t p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ConvertToSizeString_NoUnit(Int64, EnumUnitSize, System.String) declare in Codice.Client.Common.SizeConverter
bool w_si8i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si8i4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(int64_t p0, int32_t p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Int64, System.IFormatProvider) declare in System.Convert
bool w_si8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si8o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int64_t p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String FindExternalData(Int64, UInt64, Codice.CM.Common.Serialization.ExternalDataInfo, System.String, RequestExternalDataPath) declare in Codice.Client.BaseCommands.Download.ExternalData
bool w_si8u8oso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_si8u8oso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppString* (*FuncToCall)(int64_t p0, uint64_t p1, Il2CppObject* p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Concat(System.Collections.Generic.IEnumerable`1[System.String]) declare in System.String
bool w_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetHierarchyPath(UnityEngine.GameObject, Boolean) declare in UnityEditor.Search.SearchUtils
bool w_soDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetMethodSignature(System.Reflection.MethodBase, Boolean, Boolean) declare in PuertsIl2cpp.TypeUtils
bool w_soDbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soDbDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, bool p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetName(System.Type, System.Object) declare in System.Enum
bool w_soO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Format(System.Type, System.Object, System.String) declare in System.Enum
bool w_soOs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soOs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetKeywordName(UnityEngine.Shader, UnityEngine.Rendering.ShaderKeyword) declare in UnityEngine.Rendering.ShaderKeyword
bool w_soS_su4bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soS_su4bbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_su4bbb_* pp1 = DataTransfer::GetPointer<S_su4bbb_>(apis, env, _sv1);
    S_su4bbb_ p1 = pp1 ? *pp1 : S_su4bbb_ {};

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, struct S_su4bbb_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ForTransfer(ProgressData, System.DateTime, Int64, Int64, Double, System.String) declare in Codice.Client.BaseCommands.BuildProgressSpeedAndRemainingTime
bool w_soS_u8_i8i8r8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soS_u8_i8i8r8s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    double p4 = converter::Converter<double>::toCpp(apis, env, _sv4);
    // JSValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, struct S_u8_ p1, int64_t p2, int64_t p3, double p4, Il2CppString* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetInspectorTitle(UnityEngine.Object, Boolean) declare in UnityEditor.ObjectNames
bool w_sob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String FromSelectedPaths(System.Collections.Generic.List`1[System.String], Boolean, System.String) declare in PlasticGui.WorkspaceWindow.GetFilePathList
bool w_sobs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sobs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Mono.Security.ASN1, Boolean, System.String, Boolean) declare in Mono.Security.X509.X501
bool w_sobsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sobsb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetRootFolderFromFileListOnDisk(System.Collections.IList, Char) declare in Codice.Client.Common.PathHelper
bool w_soc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soc");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppChar p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Byte[], Int32) declare in System.BitConverter
bool w_soi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String SerializeXmlNode(System.Xml.XmlNode, Unity.Plastic.Newtonsoft.Json.Formatting, Boolean) declare in Unity.Plastic.Newtonsoft.Json.JsonConvert
bool w_soi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soi4b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, int32_t p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Byte[], Int32, Int32) declare in System.BitConverter
bool w_soi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToBase64String(Byte[], Int32, Int32, System.Base64FormattingOptions) declare in System.Convert
bool w_soi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soi4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String UrlDecode(Byte[], Int32, Int32, System.Text.Encoding) declare in System.Web.HttpUtility
bool w_soi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soi4i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetProtectedBranchName(Codice.CM.Common.RepositorySpec, Int64) declare in PlasticGui.WorkspaceWindow.BranchInfoCache
bool w_soi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, int64_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String From(Codice.CM.Common.RepositorySpec, Int64, Boolean) declare in Codice.Client.Common.GetCodeReviewPlasticLink
bool w_soi8Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soi8Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, int64_t p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String CalculateTransformPath(UnityEngine.Transform, UnityEngine.Transform) declare in UnityEditor.AnimationUtility
bool w_soo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String CreateFromDataContractSerializer(System.Type, System.Reflection.MemberInfo[], System.Xml.XmlNamespaceManager ByRef) declare in System.Runtime.Serialization.XPathQueryGenerator
bool w_sooPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sooPo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject** p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Get(Codice.CM.Common.ObjectInfo, Codice.CM.Common.ObjectInfo, PlasticGui.WorkspaceWindow.Merge.EnumMergeType) declare in PlasticGui.WorkspaceWindow.Merge.MergeViewTitle
bool w_sooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetGlobalWorkspaceUIConfigFilePath(Codice.Client.BaseCommands.Config.IGlobalConfig, Codice.Client.Commands.IWorkspaceTreeHandler, Codice.CM.Common.WorkspaceInfo) declare in PlasticGui.WorkspaceWindow.Configuration.WorkspaceUIConfigurationPath
bool w_sooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String CreateFromDataContractSerializer(System.Type, System.Reflection.MemberInfo[], System.Text.StringBuilder, System.Xml.XmlNamespaceManager ByRef) declare in System.Runtime.Serialization.XPathQueryGenerator
bool w_soooPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soooPo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv3)); // object ref
    Il2CppObject** p3 = &up3;
        

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject** p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, CSRefToJsValue(apis, env, TIp3, *p3));
    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetSpecFromRepObjectInfo(Codice.CM.Common.RepositorySpec, Codice.CM.Common.ObjectInfo, Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.IUnityOrgResolver) declare in Codice.Client.Common.SpecGenerator
bool w_soooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetColumnText(Codice.CM.Common.WorkspaceInfo, PlasticGui.WorkspaceWindow.Items.ExpandedTreeNode, PlasticGui.WorkspaceWindow.Items.LockStatusCache, System.String) declare in PlasticGui.WorkspaceWindow.Items.ExpandedTreeNode
bool w_sooos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sooos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String FormatItem(UnityEditor.Search.SearchContext, UnityEditor.Search.SearchItem, System.String) declare in UnityEditor.Search.SearchExpression
bool w_soos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GenerateManifest(System.Type, System.String) declare in System.Diagnostics.Tracing.EventSource
bool w_sos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Format(System.IFormatProvider, System.String, System.Object) declare in System.String
bool w_sosO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Format(System.IFormatProvider, System.String, System.Object, System.Object) declare in System.String
bool w_sosOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Format(System.IFormatProvider, System.String, System.Object, System.Object, System.Object) declare in System.String
bool w_sosOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosOOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Format(System.IFormatProvider, System.String, System.Object[]) declare in System.String
bool w_sosVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(UnityEngine.GUIContent, System.String, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_sosVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String FullPath(Codice.Client.Common.ISolveSymlinks, System.String, Boolean) declare in Codice.Client.Common.SolveSymlinks
bool w_sosb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetPath(Codice.Client.Commands.WkTree.WorkspaceTreeNode, System.String, Char) declare in Codice.Client.Common.WkTree.WorkspaceNodeOperations
bool w_sosc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosc");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppChar p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GenerateManifest(System.Type, System.String, System.Diagnostics.Tracing.EventManifestOptions) declare in System.Diagnostics.Tracing.EventSource
bool w_sosi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String BuildStreamedSceneAssetBundle(System.String[], System.String, UnityEditor.BuildTarget, UInt32 ByRef) declare in UnityEditor.BuildPipeline
bool w_sosi4Pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosi4Pu4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    uint32_t up3 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv3);
    uint32_t* p3 = &up3;

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, int32_t p2, uint32_t* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<uint32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String BuildStreamedSceneAssetBundle(System.String[], System.String, UnityEditor.BuildTarget, UInt32 ByRef, UnityEditor.BuildOptions) declare in UnityEditor.BuildPipeline
bool w_sosi4Pu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosi4Pu4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    uint32_t up3 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv3);
    uint32_t* p3 = &up3;
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, int32_t p2, uint32_t* p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<uint32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String BuildStreamedSceneAssetBundle(System.String[], System.String, UnityEditor.BuildTarget, UnityEditor.BuildOptions) declare in UnityEditor.BuildPipeline
bool w_sosi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetExplanation(Codice.CM.Common.RepositorySpec, System.String, Codice.CM.Common.ChangesetInfo) declare in PlasticGui.WorkspaceWindow.QueryViews.Changesets.ChangesetLabelUserInfo
bool w_soso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(UnityEngine.GUIContent, System.String, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_sosoVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosoVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetCloudServer(Codice.Client.Common.WebApi.IPlasticWebRestApi, System.String, System.String) declare in PlasticGui.Configuration.CloudEdition.GetFirstCloudServer
bool w_soss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_soss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ExecuteCommandInThreadWithStringResultCheckDuplicates(System.String[], System.String, System.String, Int32 ByRef) declare in Codice.Utils.CmdRunner
bool w_sossPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sossPi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppString* p2, int32_t* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetProgressString(Codice.Client.BaseCommands.UpdateProgress, System.String, System.String, System.String) declare in Codice.Client.GameUI.Update.UpdateProgressRender
bool w_sosss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sosss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PtrToStringAnsi(IntPtr) declare in System.Runtime.InteropServices.Marshal
bool w_sp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PtrToStringAnsi(IntPtr, Int32) declare in System.Runtime.InteropServices.Marshal
bool w_spi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_spi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PtrToString(IntPtr, System.Text.Encoding) declare in Mono.Unix.UnixMarshal
bool w_spo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_spo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetStringField(IntPtr, IntPtr) declare in UnityEngine.AndroidJNI
bool w_spp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_spp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void* p0, void* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String CallStringMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*) declare in UnityEngine.AndroidJNI
bool w_sppPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sppPv");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String CallStringMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue]) declare in UnityEngine.AndroidJNI
bool w_sppS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sppS_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};

    typedef Il2CppString* (*FuncToCall)(void* p0, void* p1, struct S_S_p_i4_ p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetStringFromValue(IntPtr, IntPtr, Boolean) declare in Puerts.PuertsDLL
bool w_sppb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sppb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void* p0, void* p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String CallStringMethod(IntPtr, IntPtr, UnityEngine.jvalue[]) declare in UnityEngine.AndroidJNI
bool w_sppo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sppo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void* p0, void* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Single) declare in System.Convert
bool w_sr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sr4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(float p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Single, System.IFormatProvider) declare in System.Convert
bool w_sr4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sr4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(float p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Double) declare in System.Convert
bool w_sr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sr8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(double p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Double, System.IFormatProvider) declare in System.Convert
bool w_sr8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sr8o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(double p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Copy(System.String) declare in System.String
bool w_ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Format(System.String, System.Object) declare in System.String
bool w_ssO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Format(System.String, System.Object, System.Object) declare in System.String
bool w_ssOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Format(System.String, System.Object, System.Object, System.Object) declare in System.String
bool w_ssOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssOOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetSingleSelectedPath(System.String, System.Guid) declare in PlasticGui.WorkspaceWindow.Items.WorkspaceExplorerSettings
bool w_ssS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetWkConfigPath(System.String, System.Guid, Boolean) declare in Codice.CM.WorkspaceServer.WorkspaceConfigFile
bool w_ssS_i4i2i2u1u1u1u1u1u1u1u1_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssS_i4i2i2u1u1u1u1u1u1u1u1_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Format(System.String, System.Object[]) declare in System.String
bool w_ssVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(System.String, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_ssVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Join(System.String, System.String[]) declare in System.String
bool w_ssVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssVs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String RemoveInvalidCharsFromFileName(System.String, Boolean) declare in UnityEditorInternal.InternalEditorUtility
bool w_ssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Run(System.String, Boolean, System.Object[]) declare in FullscreenEditor.Cmd
bool w_ssbVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssbVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, bool p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetValue(System.String, Boolean, Boolean, Codice.Client.Common.IConsoleReader) declare in Codice.CM.ConfigureHelper.ConfigureHelper
bool w_ssbbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssbbo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, bool p1, bool p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.String, Char) declare in Unity.Plastic.Newtonsoft.Json.JsonConvert
bool w_ssc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssc");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppChar p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetParentPath(System.String, Char, System.String ByRef) declare in Codice.Client.Common.PathHelper
bool w_sscPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sscPs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppChar p1, Il2CppString** p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PasswordField(System.String, Char, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_sscVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sscVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppChar p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.String, Char, Unity.Plastic.Newtonsoft.Json.StringEscapeHandling) declare in Unity.Plastic.Newtonsoft.Json.JsonConvert
bool w_ssci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssci4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppChar p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PasswordField(System.String, Char, Int32, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_ssci4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssci4Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppChar p1, int32_t p2, Il2CppArray* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PasswordField(System.String, Char, Int32, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_ssci4oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssci4oVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppChar p1, int32_t p2, Il2CppObject* p3, Il2CppArray* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PasswordField(System.String, Char, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_sscoVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sscoVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppChar p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetEnvironmentVariable(System.String, System.EnvironmentVariableTarget) declare in System.Environment
bool w_ssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(System.String, Int32, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_ssi4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssi4Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String MakeVersionSafeName(System.String, System.Runtime.Versioning.ResourceScope, System.Runtime.Versioning.ResourceScope) declare in System.Runtime.Versioning.VersioningHelper
bool w_ssi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String MakeVersionSafeName(System.String, System.Runtime.Versioning.ResourceScope, System.Runtime.Versioning.ResourceScope, System.Type) declare in System.Runtime.Versioning.VersioningHelper
bool w_ssi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssi4i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(System.String, Int32, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_ssi4oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssi4oVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Get(System.String, Int64) declare in PlasticGui.WorkspaceWindow.DefaultRevisionName
bool w_ssi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, int64_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Join(System.String, System.Collections.Generic.IEnumerable`1[System.String]) declare in System.String
bool w_sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(System.String, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_ssoVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssoVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Join(System.String, System.String[], Int32, Int32) declare in System.String
bool w_ssoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssoi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetIdFromSlug(System.String, Codice.Client.Common.IUnityOrgCache, Codice.CM.Common.IUnityOrgResolver) declare in Codice.Client.Common.ResolveServer
bool w_ssoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetColumnText(System.String, Codice.CM.Common.RepositorySpec, Codice.CM.Common.RepObjectInfo, System.String) declare in PlasticGui.WorkspaceWindow.History.HistoryInfoView
bool w_ssoos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssoos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetMetadata(System.String, Codice.CM.Common.RepObjectInfo, System.String) declare in PlasticGui.WorkspaceWindow.Diff.DiffWindowParametersBuilder
bool w_ssos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String FromPathOnBranch(System.String, Codice.CM.Common.RepositorySpec, System.String, System.String) declare in PlasticGui.WorkspaceWindow.Items.GetFilePlasticLink
bool w_ssoss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssoss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Substring(System.String, Double) declare in System.Xml.Xsl.Runtime.XsltFunctions
bool w_ssr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssr8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, double p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Substring(System.String, Double, Double) declare in System.Xml.Xsl.Runtime.XsltFunctions
bool w_ssr8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssr8r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, double p1, double p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Concat(System.String, System.String) declare in System.String
bool w_sss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetSIDFromName(System.String, System.String, Boolean ByRef) declare in Codice.CM.SEIDInfo.NetWorkAPI
bool w_sssPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssPb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    bool up2 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv2);
    bool* p2 = &up2;

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, bool* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<bool>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Command(System.String, System.String, System.String ByRef) declare in Codice.Utils.GetSpreadsheetCompare
bool w_sssPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssPs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString** p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetInfoFormatString(System.String, System.String, System.Object[]) declare in Codice.Client.BaseCommands.FormatString
bool w_sssVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(System.String, System.String, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_sssVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetAvailableName(System.String, System.String, Boolean) declare in GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Explorer.Operations.NewOperation
bool w_sssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PathWithStatus(System.String, System.String, Boolean, Boolean) declare in Codice.Utils.PathWithStatusUtils
bool w_sssbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, bool p2, bool p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetName(System.String, System.String, Char) declare in Codice.CM.Common.WorkspaceRevisionPath
bool w_sssc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssc");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppChar p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Encrypt(System.String, System.String, EncryptionMode) declare in Codice.Utils.CryptoServices
bool w_sssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ParseArgument(System.String, System.String, Int32, Int32) declare in Unity.CodeEditor.CodeEditor
bool w_sssi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String OpenFilePanelWithFilters(System.String, System.String, System.String[]) declare in UnityEditor.EditorUtility
bool w_ssso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String TextField(System.String, System.String, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_sssoVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssoVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator, System.Text.RegularExpressions.RegexOptions) declare in System.Text.RegularExpressions.Regex
bool w_sssoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssoi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator, System.Text.RegularExpressions.RegexOptions, System.TimeSpan) declare in System.Text.RegularExpressions.Regex
bool w_sssoi4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssoi4S_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_i8_* pp4 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv4);
    S_i8_ p4 = pp4 ? *pp4 : S_i8_ {};

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, struct S_i8_ p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Concat(System.String, System.String, System.String) declare in System.String
bool w_ssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String MSFormatDateTime(System.String, System.String, System.String, Boolean) declare in System.Xml.Xsl.Runtime.XsltFunctions
bool w_ssssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssssb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetRegistryStringValue(System.String, System.String, System.String, UnityEditorInternal.RegistryView) declare in UnityEditorInternal.RegistryUtil
bool w_ssssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssssi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Replace(System.String, System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan) declare in System.Text.RegularExpressions.Regex
bool w_ssssi4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssssi4S_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_i8_* pp4 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv4);
    S_i8_ p4 = pp4 ? *pp4 : S_i8_ {};

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, int32_t p3, struct S_i8_ p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String FromUserInputForcingCredentials(System.String, System.String, System.String, Codice.CM.Common.IUnityOrgResolver) declare in Codice.Client.Common.ResolveServer
bool w_sssso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetIdFromSlugForcingCredentials(System.String, System.String, System.String, Codice.Client.Common.IUnityOrgCache, Codice.CM.Common.IUnityOrgResolver) declare in Codice.Client.Common.ResolveServer
bool w_ssssoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssssoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Concat(System.String, System.String, System.String, System.String) declare in System.String
bool w_sssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String SaveFilePanelInProject(System.String, System.String, System.String, System.String, System.String) declare in UnityEditor.EditorUtility
bool w_ssssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ssssss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String InvokeDiffTool(System.String, System.String, System.String, System.String, System.String, System.String) declare in UnityEditor.EditorUtility
bool w_sssssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sssssss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String get_Name() declare in Microsoft.Win32.RegistryKey
bool w_st(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_st");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef Il2CppString* (*FuncToCall)(void*,const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ModelNameBuilder(BaseModel, System.Nullable`1[Betalgo.Ranul.OpenAI.ObjectModels.Models+Subject], System.String) declare in Betalgo.Ranul.OpenAI.ObjectModels.Models
bool w_stDN_bi4_Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stDN_bi4_Ds");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    N_bi4_ p0 = OptionalParameter<N_bi4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(void*,struct N_bi4_ p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetFriendlyName(System.Type, System.Type[]) declare in Puerts.TypeExtensions
bool w_stDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal ref  with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 0, TIp0);
                

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ResolveAlias(System.String) declare in UnityEditor.Search.SearchExpressionContext
bool w_stDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal string  with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetEnumName(System.Object) declare in System.Type
bool w_stO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.Object, System.Object) declare in Unity.Plastic.Antlr3.Runtime.Tree.BufferedTreeNodeStream
bool w_stOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToDot(System.Object, Unity.Plastic.Antlr3.Runtime.Tree.ITreeAdaptor) declare in Unity.Plastic.Antlr3.Runtime.Tree.DotTreeGenerator
bool w_stOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetString(Byte*, Int32) declare in System.Text.Encoding
bool w_stPvi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stPvi4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetString(System.ReadOnlySpan`1[System.Byte]) declare in System.Text.Encoding
bool w_stS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stS_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef Il2CppString* (*FuncToCall)(void*,struct S_S_p_i4_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetArtifactFilePath(UnityEditor.Experimental.ArtifactKey, System.String) declare in UnityEditor.AssetImporters.AssetImportContext
bool w_stS_S_u4u4u4u4_o_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stS_S_u4u4u4u4_o_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_o_* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_o_>(apis, env, _sv0);
    S_S_u4u4u4u4_o_ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_o_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,struct S_S_u4u4u4u4_o_ p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetCurrentBlockUploadSize(Codice.Client.Commands.CurrentUploadBlock, Int32) declare in Codice.Client.BaseCommands.CheckIn.Progress.CheckinUploadProgressRender
bool w_stS_i4i4si8i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stS_i4i4si8i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4si8i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4si8i4i4_>(apis, env, _sv0);
    S_i4i4si8i4i4_ p0 = pp0 ? *pp0 : S_i4i4si8i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,struct S_i4i4si8i4i4_ p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetCurrentFileInfo(Codice.Client.Commands.CurrentUploadBlock, System.String) declare in Codice.Client.BaseCommands.CheckIn.Progress.CheckinUploadProgressRender
bool w_stS_i4i4si8i4i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stS_i4i4si8i4i4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4si8i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4si8i4i4_>(apis, env, _sv0);
    S_i4i4si8i4i4_ p0 = pp0 ? *pp0 : S_i4i4si8i4i4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,struct S_i4i4si8i4i4_ p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String OnGUI(UnityEngine.Rect, System.String) declare in UnityEditor.IMGUI.Controls.SearchField
bool w_stS_r4r4r4r4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stS_r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String OnGUI(UnityEngine.Rect, System.String, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUIStyle) declare in UnityEditor.IMGUI.Controls.SearchField
bool w_stS_r4r4r4r4_sooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stS_r4r4r4r4_sooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppString* (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetCertHashString(System.Security.Cryptography.HashAlgorithmName) declare in System.Security.Cryptography.X509Certificates.X509Certificate
bool w_stS_s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stS_s_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};

    typedef Il2CppString* (*FuncToCall)(void*,struct S_s_ p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetArtifactFilePath(UnityEditor.GUID, System.String) declare in UnityEditor.AssetImporters.AssetImportContext
bool w_stS_u4u4u4u4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stS_u4u4u4u4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,struct S_u4u4u4u4_ p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetString(Name, System.Object[]) declare in PlasticGui.PlasticLocalization
bool w_stVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
    }
    
    // JSValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, js_args_len, 0);
                

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Trim(Char[]) declare in System.String
bool w_stVc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stVc");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive params
    Il2CppArray* p0 = Params<Il2CppChar>::PackPrimitive(apis, env, info, TIp0, js_args_len, 0);
                

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToXmlString(Boolean) declare in System.Security.Cryptography.AsymmetricAlgorithm
bool w_stb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,bool p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Boolean, Boolean) declare in System.ComponentModel.MaskedTextProvider
bool w_stbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stbb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,bool p0, bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Boolean, Boolean, Boolean, Int32, Int32) declare in System.ComponentModel.MaskedTextProvider
bool w_stbbbi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stbbbi4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppString* (*FuncToCall)(void*,bool p0, bool p1, bool p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Boolean, Boolean, Int32, Int32) declare in System.ComponentModel.MaskedTextProvider
bool w_stbbi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stbbi4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(void*,bool p0, bool p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Boolean, Int32, Int32) declare in System.ComponentModel.MaskedTextProvider
bool w_stbi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stbi4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,bool p0, int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Trim(Char) declare in System.String
bool w_stc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stc");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppChar p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Replace(Char, Char) declare in System.String
bool w_stcc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stcc");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppChar p0, Il2CppChar p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PadLeft(Int32) declare in System.String
bool w_sti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Unity.Plastic.Newtonsoft.Json.Formatting, Unity.Plastic.Newtonsoft.Json.JsonConverter[]) declare in Unity.Plastic.Newtonsoft.Json.Linq.JToken
bool w_sti4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sti4Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p0, Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetNameInfo(System.Security.Cryptography.X509Certificates.X509NameType, Boolean) declare in System.Security.Cryptography.X509Certificates.X509Certificate2
bool w_sti4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sti4b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p0, bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String PadLeft(Int32, Char) declare in System.String
bool w_sti4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sti4c");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p0, Il2CppChar p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Remove(Int32, Int32) declare in System.String
bool w_sti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetItemMergedSamplesMetadata(Int32, Int32, Int32) declare in UnityEditor.Profiling.HierarchyFrameDataView
bool w_sti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sti4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetRawContent(Int32, Int32, Int32, Int32) declare in Codice.CM.Client.Differences.VirtualSpace
bool w_sti4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sti4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Insert(Int32, System.String) declare in System.String
bool w_sti4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sti4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetBranchName(Int64) declare in Codice.Client.BaseCommands.BranchNameResolver
bool w_sti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sti8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,int64_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetUploadSize(Int64, Int64, ProgressData) declare in Codice.Client.BaseCommands.CheckIn.Progress.CheckinUploadProgressRender
bool w_sti8i8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sti8i8o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,int64_t p0, int64_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetPath(Int64, Codice.CM.Common.RepositorySpec) declare in Codice.CM.WorkspaceServer.WorkspaceRevisionResolver
bool w_sti8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sti8o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,int64_t p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToLower(System.Globalization.CultureInfo) declare in System.String
bool w_sto(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sto");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetLabel(UnityEditor.Search.SearchContext, Boolean) declare in UnityEditor.Search.SearchItem
bool w_stoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stoDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ResolveAlias(UnityEditor.Search.SearchExpression, System.String) declare in UnityEditor.Search.SearchExpressionContext
bool w_stoDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stoDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ConvertToInvariantString(System.ComponentModel.ITypeDescriptorContext, System.Object) declare in System.ComponentModel.TypeConverter
bool w_stoO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stoO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ReadContentAsString(System.String[], Int32 ByRef) declare in System.Xml.XmlDictionaryReader
bool w_stoPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stoPi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, int32_t* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext) declare in UnityEngine.UIElements.UxmlStringAttributeDescription
bool w_stoS_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stoS_oooo_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, struct S_oooo_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ImportAnyElement(System.Xml.Schema.XmlSchemaAny, Boolean, System.Xml.Serialization.XmlSchemas, System.Xml.Serialization.XmlSchemaImporter, System.CodeDom.CodeCompileUnit, System.CodeDom.CodeNamespace, System.Xml.Serialization.CodeGenerationOptions, System.CodeDom.Compiler.CodeDomProvider) declare in System.Xml.Serialization.Advanced.SchemaImporterExtension
bool w_stobooooi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stobooooi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, bool p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, int32_t p6, Il2CppObject* p7, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetHashCode(Byte[], Int32) declare in Codice.Client.BaseCommands.HashProvider
bool w_stoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stoi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetString(Byte[], Int32, Int32) declare in System.Text.ASCIIEncoding
bool w_stoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stoi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetSavedLicenseKey(System.Type, System.Reflection.Assembly) declare in System.ComponentModel.LicenseContext
bool w_stoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ConvertToString(System.ComponentModel.ITypeDescriptorContext, System.Globalization.CultureInfo, System.Object) declare in System.ComponentModel.TypeConverter
bool w_stooO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stooO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetErrorText(UnityEngine.Timeline.TrackAsset, UnityEngine.Object, UnityEditor.Timeline.TrackBindingErrors) declare in UnityEditor.Timeline.TrackEditor
bool w_stooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ImportSchemaType(System.Xml.Schema.XmlSchemaType, System.Xml.Schema.XmlSchemaObject, System.Xml.Serialization.XmlSchemas, System.Xml.Serialization.XmlSchemaImporter, System.CodeDom.CodeCompileUnit, System.CodeDom.CodeNamespace, System.Xml.Serialization.CodeGenerationOptions, System.CodeDom.Compiler.CodeDomProvider) declare in System.Xml.Serialization.Advanced.SchemaImporterExtension
bool w_stooooooi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stooooooi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, int32_t p6, Il2CppObject* p7, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ReadElementContentAsString(System.Xml.XmlReader, DocBody, System.String) declare in Puerts.DocResolver
bool w_stoos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stoos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String UploadString(System.Uri, System.String) declare in System.Net.WebClient
bool w_stos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String NumberFormat(System.Collections.Generic.IList`1[System.Xml.XPath.XPathItem], System.String, Double, System.String, System.String, Double) declare in System.Xml.Xsl.Runtime.XsltLibrary
bool w_stosr8ssr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stosr8ssr8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    double p5 = converter::Converter<double>::toCpp(apis, env, _sv5);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, double p2, Il2CppString* p3, Il2CppString* p4, double p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String UploadString(System.Uri, System.String, System.String) declare in System.Net.WebClient
bool w_stoss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stoss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetString(IntPtr, IntPtr, Boolean) declare in Puerts.GetValueFromResultImpl
bool w_stppb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stppb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String FormatNumberStatic(Double, Double) declare in System.Xml.Xsl.Runtime.XsltLibrary
bool w_str8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_str8r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,double p0, double p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String FormatNumberDynamic(Double, System.String, System.Xml.XmlQualifiedName, System.String) declare in System.Xml.Xsl.Runtime.XsltLibrary
bool w_str8sos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_str8sos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(void*,double p0, Il2CppString* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.String) declare in System.Byte
bool w_sts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_sts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String AddUnique(System.String, System.Object) declare in System.Xml.Serialization.CodeIdentifiers
bool w_stsO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ResolveModuleContent(System.String, System.String ByRef) declare in Puerts.JsEnv
bool w_stsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsPs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString** p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String OnGUI(System.String, UnityEngine.GUILayoutOption[]) declare in UnityEditor.IMGUI.Controls.SearchField
bool w_stsVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetString(System.String, Boolean) declare in System.Resources.ResourceSet
bool w_stsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetTag(System.String, Boolean, System.String) declare in UnityEngine.Material
bool w_stsbs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsbs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, bool p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetAscii(System.String, Int32) declare in System.Globalization.IdnMapping
bool w_stsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetAutoIndentedFormattedString(System.String, Int32, Int32 ByRef) declare in InGameCodeEditor.AutoIndent
bool w_stsi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsi4Pi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, int32_t* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetAscii(System.String, Int32, Int32) declare in System.Globalization.IdnMapping
bool w_stsi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(System.String, System.IFormatProvider) declare in System.Byte
bool w_stso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Replace(System.String, System.Text.RegularExpressions.MatchEvaluator, Int32) declare in System.Text.RegularExpressions.Regex
bool w_stsoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsoi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Replace(System.String, System.Text.RegularExpressions.MatchEvaluator, Int32, Int32) declare in System.Text.RegularExpressions.Regex
bool w_stsoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsoi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String DecryptSection(System.String, System.Configuration.ProtectedConfigurationProvider, System.Configuration.ProtectedConfigurationSection) declare in System.Configuration.Internal.DelegatingConfigHost
bool w_stsoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetSpecFromObjectInfo(System.String, Codice.CM.Common.ObjectInfo, Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.IUnityOrgResolver) declare in Codice.Client.Common.SpecGenerator
bool w_stsooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Replace(System.String, System.String) declare in System.String
bool w_stss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Replace(System.String, System.String, Boolean, System.Globalization.CultureInfo) declare in System.String
bool w_stssbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stssbo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, bool p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Replace(System.String, System.String, System.StringComparison) declare in System.String
bool w_stssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stssi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String Replace(System.String, System.String, Int32, Int32) declare in System.Text.RegularExpressions.Regex
bool w_stssi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stssi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetStatus(System.String, System.String, System.Collections.Generic.Dictionary`2[System.String,System.String]) declare in Codice.Client.BaseCommands.IssueTrackerCmdImpl
bool w_stsso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ImportSchemaType(System.String, System.String, System.Xml.Schema.XmlSchemaObject, System.Xml.Serialization.XmlSchemas, System.Xml.Serialization.XmlSchemaImporter, System.CodeDom.CodeCompileUnit, System.CodeDom.CodeNamespace, System.Xml.Serialization.CodeGenerationOptions, System.CodeDom.Compiler.CodeDomProvider) declare in System.Xml.Serialization.Advanced.SchemaImporterExtension
bool w_stssoooooi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stssoooooi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal o/O
    Il2CppObject* p8 = JsValueToCSRef(apis, TIp8, env, _sv8);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, int32_t p7, Il2CppObject* p8, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String UploadString(System.String, System.String, System.String) declare in System.Net.WebClient
bool w_stsss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String BuildWebApiTokenForCloudEditionForUser(System.String, Codice.CM.Common.SEIDWorkingMode, System.String) declare in Codice.Client.Common.CmConnection
bool w_stsu1s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stsu1s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p0, uint8_t p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetUserName(Codice.CM.Common.SEIDWorkingMode, System.String, System.String) declare in Codice.Client.Common.UserNameResolver
bool w_stu1ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stu1ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,uint8_t p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetAudioLanguage(UInt16) declare in UnityEngine.Video.VideoClip
bool w_stu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stu2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,uint16_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(UInt32) declare in Mono.Math.BigInteger
bool w_stu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stu4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,uint32_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(UInt32, System.String) declare in Mono.Math.BigInteger
bool w_stu4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stu4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,uint32_t p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetFileName(UInt64) declare in Codice.CM.Common.Serialization.ExternalDataInfo
bool w_stu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_stu8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,uint64_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Byte) declare in System.Convert
bool w_su1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_su1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(uint8_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Byte, Int32) declare in System.Convert
bool w_su1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_su1i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint8_t p0, int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(Byte, System.IFormatProvider) declare in System.Convert
bool w_su1o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_su1o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint8_t p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String BuildStatusComment(Codice.CM.Common.CodeReviewStatus, System.String) declare in Codice.CM.Common.TimelineCommentSpec
bool w_su1s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_su1s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint8_t p0, Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String GetSecurityConfigStr(Codice.CM.Common.SEIDWorkingMode, System.String, System.String) declare in Codice.Client.Common.UserInfo
bool w_su1ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_su1ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(uint8_t p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(UInt16) declare in System.Convert
bool w_su2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_su2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(uint16_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(UInt16, System.IFormatProvider) declare in System.Convert
bool w_su2o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_su2o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint16_t p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(UInt32) declare in System.Convert
bool w_su4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_su4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(uint32_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(UInt32, System.IFormatProvider) declare in System.Convert
bool w_su4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_su4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint32_t p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(UInt64) declare in System.Convert
bool w_su8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_su8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(uint64_t p0, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// System.String ToString(UInt64, System.IFormatProvider) declare in System.Convert
bool w_su8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_su8o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint64_t p0, Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<Il2CppString*>::toScript(apis, env, ret));
    return true;
}

// Byte get_Revision() declare in System.Security.AccessControl.GenericSecurityDescriptor
bool w_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef uint8_t (*FuncToCall)(const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(System.Object) declare in System.Convert
bool w_u1O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1O");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint8_t (*FuncToCall)(Il2CppObject* p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ReadByte(System.Object, Int32) declare in System.Runtime.InteropServices.Marshal
bool w_u1Oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1Oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint8_t (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(System.Object, System.IFormatProvider) declare in System.Convert
bool w_u1Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1Oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint8_t (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte VolatileRead(Byte ByRef) declare in System.Threading.Thread
bool w_u1Pu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1Pu1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    uint8_t up0 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv0);
    uint8_t* p0 = &up0;

    typedef uint8_t (*FuncToCall)(uint8_t* p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint8_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider) declare in System.Byte
bool w_u1S_S_p_i4_Di4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_S_p_i4_Di4Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef uint8_t (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte op_Explicit(System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlByte
bool w_u1S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_bu1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};

    typedef uint8_t (*FuncToCall)(struct S_bu1_ p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(System.Decimal) declare in System.Convert
bool w_u1S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef uint8_t (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte op_Explicit(System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_u1S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};

    typedef uint8_t (*FuncToCall)(struct S_i4o_ p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(System.DateTime) declare in System.Convert
bool w_u1S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef uint8_t (*FuncToCall)(struct S_u8_ p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(Boolean) declare in System.Convert
bool w_u1b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(bool p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(Char) declare in System.Convert
bool w_u1c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1c");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(Il2CppChar p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(SByte) declare in System.Convert
bool w_u1i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(int8_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(Int16) declare in System.Convert
bool w_u1i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(int16_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(Int32) declare in System.Convert
bool w_u1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(int32_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte GetByte(Int32, IntPtr, Puerts.IGetValueFromJs, IntPtr, Boolean) declare in Puerts.PrimitiveTypeTranslate
bool w_u1i4popb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1i4popb");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef uint8_t (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, void* p3, bool p4, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(Int64) declare in System.Convert
bool w_u1i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(int64_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte op_Explicit(System.Text.Json.Nodes.JsonNode) declare in System.Text.Json.Nodes.JsonNode
bool w_u1o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1o");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint8_t (*FuncToCall)(Il2CppObject* p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte GetByte(System.Array, Int32) declare in System.Buffer
bool w_u1oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint8_t (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// PlasticGui.WorkspaceWindow.PendingChanges.Changelists.ChangelistMenuOperations GetAvailableMenuOperations(PlasticGui.WorkspaceWindow.PendingChanges.SelectedChangesGroupInfo, System.Collections.Generic.List`1[Codice.Client.Commands.ChangeListInfo]) declare in PlasticGui.WorkspaceWindow.PendingChanges.Changelists.ChangelistMenuUpdater
bool w_u1oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint8_t (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte DeserializeCheckVersion(Codice.CM.Common.Serialization.PlasticBinaryReader, Byte, Byte) declare in PlasticPipe.PlasticProtocol.Messages.MethodVersion
bool w_u1ou1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1ou1u1");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef uint8_t (*FuncToCall)(Il2CppObject* p0, uint8_t p1, uint8_t p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ReadByte(IntPtr) declare in System.Runtime.InteropServices.Marshal
bool w_u1p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1p");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(void* p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ReadByte(IntPtr, Int32) declare in System.Runtime.InteropServices.Marshal
bool w_u1pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint8_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte GetByteField(IntPtr, IntPtr) declare in UnityEngine.AndroidJNI
bool w_u1pp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1pp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef uint8_t (*FuncToCall)(void* p0, void* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte CallByteMethod(IntPtr, IntPtr, UnityEngine.jvalue[]) declare in UnityEngine.AndroidJNI
bool w_u1ppo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1ppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef uint8_t (*FuncToCall)(void* p0, void* p1, Il2CppObject* p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(Single) declare in System.Convert
bool w_u1r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(float p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(Double) declare in System.Convert
bool w_u1r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(double p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte Parse(System.String) declare in System.Byte
bool w_u1s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(Il2CppString* p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte Parse(System.String, System.Globalization.NumberStyles) declare in System.Byte
bool w_u1si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1si4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint8_t (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider) declare in System.Byte
bool w_u1si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1si4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef uint8_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte Parse(System.String, System.IFormatProvider) declare in System.Byte
bool w_u1so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint8_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Codice.Client.BaseCommands.FileType GetFileType(System.String, System.String) declare in Codice.Client.BaseCommands.WellKnownFileTypes
bool w_u1ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1ss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef uint8_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// System.Security.SecurityRuleSet get_RuleSet() declare in System.Security.SecurityRulesAttribute
bool w_u1t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1t");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef uint8_t (*FuncToCall)(void*,const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(System.Object) declare in System.Runtime.Serialization.FormatterConverter
bool w_u1tO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1tO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint8_t (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte get_Item(Int32) declare in UnityEngine.Color32
bool w_u1ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1ti4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(void*,int32_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ReadByte(Int64) declare in System.IO.UnmanagedMemoryAccessor
bool w_u1ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1ti8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(void*,int64_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte GetByte(System.String) declare in System.Runtime.Serialization.SerializationInfo
bool w_u1ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Codice.Client.BaseCommands.FileType GetMatchedType(System.String, System.String, System.String) declare in Codice.Client.BaseCommands.FileTypeChecker
bool w_u1tsss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1tsss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef uint8_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte Adjust(Byte) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_u1tu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1tu1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(void*,uint8_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte NextByte(Byte, Byte) declare in NUnit.Framework.Internal.Randomizer
bool w_u1tu1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1tu1u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);

    typedef uint8_t (*FuncToCall)(void*,uint8_t p0, uint8_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(Byte) declare in System.Convert
bool w_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(uint8_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte Max(Byte, Byte) declare in System.Math
bool w_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1u1u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);

    typedef uint8_t (*FuncToCall)(uint8_t p0, uint8_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte Clamp(Byte, Byte, Byte) declare in System.Math
bool w_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1u1u1u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef uint8_t (*FuncToCall)(uint8_t p0, uint8_t p1, uint8_t p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(UInt16) declare in System.Convert
bool w_u1u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(uint16_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(UInt32) declare in System.Convert
bool w_u1u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(uint32_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// Byte ToByte(UInt64) declare in System.Convert
bool w_u1u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u1u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(uint64_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint8_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 get_controlledAudioTrackMaxCount() declare in UnityEngine.Video.VideoPlayer
bool w_u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef uint16_t (*FuncToCall)(const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(System.Object) declare in System.Convert
bool w_u2O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2O");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint16_t (*FuncToCall)(Il2CppObject* p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(System.Object, System.IFormatProvider) declare in System.Convert
bool w_u2Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2Oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint16_t (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 VolatileRead(UInt16 ByRef) declare in System.Threading.Thread
bool w_u2Pu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2Pu2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    uint16_t up0 = converter::Converter<std::reference_wrapper<uint16_t>>::toCpp(apis, env, _sv0);
    uint16_t* p0 = &up0;

    typedef uint16_t (*FuncToCall)(uint16_t* p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint16_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 GetCategoryByName(Char*, Int32) declare in Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility
bool w_u2Pvi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2Pvi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint16_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 CreateCategory(Char*, Int32, Unity.Profiling.ProfilerCategoryColor) declare in Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility
bool w_u2Pvi4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2Pvi4u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(apis, env, _sv2);

    typedef uint16_t (*FuncToCall)(void* p0, int32_t p1, uint16_t p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(System.ReadOnlySpan`1[System.Byte]) declare in System.BitConverter
bool w_u2S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef uint16_t (*FuncToCall)(struct S_S_p_i4_ p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider) declare in System.UInt16
bool w_u2S_S_p_i4_Di4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_S_p_i4_Di4Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef uint16_t (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(System.Decimal) declare in System.Convert
bool w_u2S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef uint16_t (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 op_Explicit(System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_u2S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};

    typedef uint16_t (*FuncToCall)(struct S_i4o_ p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 op_Implicit(Unity.Profiling.ProfilerCategory) declare in Unity.Profiling.ProfilerCategory
bool w_u2S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef uint16_t (*FuncToCall)(struct S_u2_ p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(System.DateTime) declare in System.Convert
bool w_u2S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef uint16_t (*FuncToCall)(struct S_u8_ p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(Boolean) declare in System.Convert
bool w_u2b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(bool p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(Char) declare in System.Convert
bool w_u2c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2c");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(Il2CppChar p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(SByte) declare in System.Convert
bool w_u2i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(int8_t p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(Int16) declare in System.Convert
bool w_u2i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(int16_t p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(Int32) declare in System.Convert
bool w_u2i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(int32_t p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 GetUInt16(Int32, IntPtr, Puerts.IGetValueFromJs, IntPtr, Boolean) declare in Puerts.PrimitiveTypeTranslate
bool w_u2i4popb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2i4popb");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef uint16_t (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, void* p3, bool p4, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(Int64) declare in System.Convert
bool w_u2i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(int64_t p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 op_Explicit(System.Text.Json.Nodes.JsonNode) declare in System.Text.Json.Nodes.JsonNode
bool w_u2o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2o");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint16_t (*FuncToCall)(Il2CppObject* p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(Byte[], Int32) declare in System.BitConverter
bool w_u2oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint16_t (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(Single) declare in System.Convert
bool w_u2r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(float p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(Double) declare in System.Convert
bool w_u2r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(double p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(System.String) declare in System.Convert
bool w_u2s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(Il2CppString* p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(System.String, Int32) declare in System.Convert
bool w_u2si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2si4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint16_t (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider) declare in System.UInt16
bool w_u2si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2si4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef uint16_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(System.String, System.IFormatProvider) declare in System.Convert
bool w_u2so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint16_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ReadUInt16() declare in System.IO.BinaryReader
bool w_u2t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2t");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef uint16_t (*FuncToCall)(void*,const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(System.Object) declare in System.Runtime.Serialization.FormatterConverter
bool w_u2tO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2tO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint16_t (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UnityEditor.ObjectChangeKind GetEventType(Int32) declare in UnityEditor.ObjectChangeEventStream
bool w_u2ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2ti4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(void*,int32_t p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ReadUInt16(Int64) declare in System.IO.UnmanagedMemoryAccessor
bool w_u2ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2ti8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(void*,int64_t p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 GetUInt16(System.String) declare in System.Runtime.Serialization.SerializationInfo
bool w_u2ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 GetAudioChannelCount(UInt16) declare in UnityEngine.Video.VideoClip
bool w_u2tu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2tu2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(void*,uint16_t p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 NextUShort(UInt16, UInt16) declare in NUnit.Framework.Internal.Randomizer
bool w_u2tu2u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2tu2u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);

    typedef uint16_t (*FuncToCall)(void*,uint16_t p0, uint16_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(Byte) declare in System.Convert
bool w_u2u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(uint8_t p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(UInt16) declare in System.Convert
bool w_u2u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(uint16_t p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 Max(UInt16, UInt16) declare in System.Math
bool w_u2u2u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2u2u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);

    typedef uint16_t (*FuncToCall)(uint16_t p0, uint16_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 Clamp(UInt16, UInt16, UInt16) declare in System.Math
bool w_u2u2u2u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2u2u2u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(apis, env, _sv2);

    typedef uint16_t (*FuncToCall)(uint16_t p0, uint16_t p1, uint16_t p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(UInt32) declare in System.Convert
bool w_u2u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(uint32_t p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt16 ToUInt16(UInt64) declare in System.Convert
bool w_u2u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u2u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(uint64_t p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint16_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 get_memoryBudgetKB() declare in UnityEngine.AssetBundle
bool w_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef uint32_t (*FuncToCall)(const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(System.Object) declare in System.Convert
bool w_u4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4O");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint32_t (*FuncToCall)(Il2CppObject* p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(System.Object, System.IFormatProvider) declare in System.Convert
bool w_u4Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4Oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint32_t (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 VolatileRead(UInt32 ByRef) declare in System.Threading.Thread
bool w_u4Pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4Pu4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    uint32_t up0 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv0);
    uint32_t* p0 = &up0;

    typedef uint32_t (*FuncToCall)(uint32_t* p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint32_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Void*, Int32, UInt32) declare in Unity.Mathematics.math
bool w_u4Pvi4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4Pvi4Du4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef uint32_t (*FuncToCall)(void* p0, int32_t p1, uint32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.RigidTransform) declare in Unity.Mathematics.math
bool w_u4S_S_S_r4r4r4r4__S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_S_r4r4r4r4__S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4r4r4r4__S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_S_r4r4r4r4__S_r4r4r4__>(apis, env, _sv0);
    S_S_S_r4r4r4r4__S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_S_r4r4r4r4__S_r4r4r4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_S_r4r4r4r4__S_r4r4r4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.bool2x4) declare in Unity.Mathematics.math
bool w_u4S_S_bb_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_bb_S_bb_S_bb_S_bb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb_S_bb__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_bb_S_bb_S_bb_S_bb__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.bool2x3) declare in Unity.Mathematics.math
bool w_u4S_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_bb_S_bb_S_bb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_bb_S_bb_S_bb__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.bool2x2) declare in Unity.Mathematics.math
bool w_u4S_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_bb_S_bb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_bb_S_bb__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.bool3x4) declare in Unity.Mathematics.math
bool w_u4S_S_bbb_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_bbb_S_bbb_S_bbb_S_bbb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.bool3x3) declare in Unity.Mathematics.math
bool w_u4S_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_bbb_S_bbb_S_bbb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.bool3x2) declare in Unity.Mathematics.math
bool w_u4S_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_bbb_S_bbb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_bbb_S_bbb__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.bool4x4) declare in Unity.Mathematics.math
bool w_u4S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.bool4x3) declare in Unity.Mathematics.math
bool w_u4S_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.bool4x2) declare in Unity.Mathematics.math
bool w_u4S_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_bbbb_S_bbbb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_bbbb_S_bbbb__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.int2x4) declare in Unity.Mathematics.math
bool w_u4S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.int2x3) declare in Unity.Mathematics.math
bool w_u4S_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.int2x2) declare in Unity.Mathematics.math
bool w_u4S_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_i4i4_S_i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_i4i4_S_i4i4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.int3x4) declare in Unity.Mathematics.math
bool w_u4S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.int3x3) declare in Unity.Mathematics.math
bool w_u4S_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.int3x2) declare in Unity.Mathematics.math
bool w_u4S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_i4i4i4_S_i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.int4x4) declare in Unity.Mathematics.math
bool w_u4S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.int4x3) declare in Unity.Mathematics.math
bool w_u4S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.int4x2) declare in Unity.Mathematics.math
bool w_u4S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(System.ReadOnlySpan`1[System.Byte]) declare in System.BitConverter
bool w_u4S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef uint32_t (*FuncToCall)(struct S_S_p_i4_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider) declare in System.UInt32
bool w_u4S_S_p_i4_Di4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_p_i4_Di4Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef uint32_t (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.float2x4) declare in Unity.Mathematics.math
bool w_u4S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.float2x3) declare in Unity.Mathematics.math
bool w_u4S_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.float2x2) declare in Unity.Mathematics.math
bool w_u4S_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r4r4_S_r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r4r4_S_r4r4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.float3x4) declare in Unity.Mathematics.math
bool w_u4S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.float3x3) declare in Unity.Mathematics.math
bool w_u4S_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.float3x2) declare in Unity.Mathematics.math
bool w_u4S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_u4S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.float4x3) declare in Unity.Mathematics.math
bool w_u4S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.float4x2) declare in Unity.Mathematics.math
bool w_u4S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.quaternion) declare in Unity.Mathematics.math
bool w_u4S_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r4r4r4r4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.double2x4) declare in Unity.Mathematics.math
bool w_u4S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.double2x3) declare in Unity.Mathematics.math
bool w_u4S_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.double2x2) declare in Unity.Mathematics.math
bool w_u4S_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r8r8_S_r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r8r8_S_r8r8__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.double3x4) declare in Unity.Mathematics.math
bool w_u4S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.double3x3) declare in Unity.Mathematics.math
bool w_u4S_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.double3x2) declare in Unity.Mathematics.math
bool w_u4S_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r8r8r8_S_r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.double4x4) declare in Unity.Mathematics.math
bool w_u4S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.double4x3) declare in Unity.Mathematics.math
bool w_u4S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.double4x2) declare in Unity.Mathematics.math
bool w_u4S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.half4) declare in Unity.Mathematics.math
bool w_u4S_S_u2_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_u2_S_u2_S_u2_S_u2__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2_S_u2__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_u2_S_u2_S_u2_S_u2__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.half3) declare in Unity.Mathematics.math
bool w_u4S_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_u2_S_u2_S_u2__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_u2_S_u2_S_u2__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.half2) declare in Unity.Mathematics.math
bool w_u4S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_u2_S_u2__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_u2_S_u2__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.uint2x4) declare in Unity.Mathematics.math
bool w_u4S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.uint2x3) declare in Unity.Mathematics.math
bool w_u4S_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.uint2x2) declare in Unity.Mathematics.math
bool w_u4S_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_u4u4_S_u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_u4u4_S_u4u4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.uint3x4) declare in Unity.Mathematics.math
bool w_u4S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.uint3x3) declare in Unity.Mathematics.math
bool w_u4S_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.uint3x2) declare in Unity.Mathematics.math
bool w_u4S_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_u4u4u4_S_u4u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.uint4x4) declare in Unity.Mathematics.math
bool w_u4S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.uint4x3) declare in Unity.Mathematics.math
bool w_u4S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.uint4x2) declare in Unity.Mathematics.math
bool w_u4S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef uint32_t (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_u4S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_bb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};

    typedef uint32_t (*FuncToCall)(struct S_bb_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_u4S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_bbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};

    typedef uint32_t (*FuncToCall)(struct S_bbb_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_u4S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_bbbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};

    typedef uint32_t (*FuncToCall)(struct S_bbbb_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.int2) declare in Unity.Mathematics.math
bool w_u4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef uint32_t (*FuncToCall)(struct S_i4i4_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_u4S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef uint32_t (*FuncToCall)(struct S_i4i4i4_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_u4S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};

    typedef uint32_t (*FuncToCall)(struct S_i4i4i4i4_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(System.Decimal) declare in System.Convert
bool w_u4S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef uint32_t (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 op_Explicit(System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_u4S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};

    typedef uint32_t (*FuncToCall)(struct S_i4o_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_u4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef uint32_t (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_u4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef uint32_t (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToHex(UnityEngine.Color) declare in UnityEngine.Rendering.ColorUtils
bool w_u4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef uint32_t (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_u4S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};

    typedef uint32_t (*FuncToCall)(struct S_r8r8_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_u4S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};

    typedef uint32_t (*FuncToCall)(struct S_r8r8r8_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_u4S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_r8r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};

    typedef uint32_t (*FuncToCall)(struct S_r8r8r8r8_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 hash(Unity.Mathematics.half) declare in Unity.Mathematics.math
bool w_u4S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef uint32_t (*FuncToCall)(struct S_u2_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 cmin(Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_u4S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};

    typedef uint32_t (*FuncToCall)(struct S_u4u4_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 dot(Unity.Mathematics.uint2, Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_u4S_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u4u4_S_u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef uint32_t (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 shuffle(Unity.Mathematics.uint2, Unity.Mathematics.uint2, ShuffleComponent) declare in Unity.Mathematics.math
bool w_u4S_u4u4_S_u4u4_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u4u4_S_u4u4_u1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef uint32_t (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, uint8_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 cmin(Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_u4S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};

    typedef uint32_t (*FuncToCall)(struct S_u4u4u4_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 dot(Unity.Mathematics.uint3, Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_u4S_u4u4u4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u4u4u4_S_u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};

    typedef uint32_t (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 shuffle(Unity.Mathematics.uint3, Unity.Mathematics.uint3, ShuffleComponent) declare in Unity.Mathematics.math
bool w_u4S_u4u4u4_S_u4u4u4_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u4u4u4_S_u4u4u4_u1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef uint32_t (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, uint8_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 cmin(Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_u4S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u4u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef uint32_t (*FuncToCall)(struct S_u4u4u4u4_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 dot(Unity.Mathematics.uint4, Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_u4S_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};

    typedef uint32_t (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 shuffle(Unity.Mathematics.uint4, Unity.Mathematics.uint4, ShuffleComponent) declare in Unity.Mathematics.math
bool w_u4S_u4u4u4u4_S_u4u4u4u4_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u4u4u4u4_S_u4u4u4u4_u1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef uint32_t (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, uint8_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(System.DateTime) declare in System.Convert
bool w_u4S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef uint32_t (*FuncToCall)(struct S_u8_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(Boolean) declare in System.Convert
bool w_u4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(bool p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(Char) declare in System.Convert
bool w_u4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4c");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(Il2CppChar p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(SByte) declare in System.Convert
bool w_u4i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(int8_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(Int16) declare in System.Convert
bool w_u4i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(int16_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(Int32) declare in System.Convert
bool w_u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(int32_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ComputeMipmapSize(Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat) declare in UnityEngine.Experimental.Rendering.GraphicsFormatUtility
bool w_u4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef uint32_t (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ComputeMipChainSize(Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32) declare in UnityEngine.Experimental.Rendering.GraphicsFormatUtility
bool w_u4i4i4i4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4i4i4Di4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef uint32_t (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ComputeMipmapSize(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat) declare in UnityEngine.Experimental.Rendering.GraphicsFormatUtility
bool w_u4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef uint32_t (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ComputeMipChainSize(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32) declare in UnityEngine.Experimental.Rendering.GraphicsFormatUtility
bool w_u4i4i4i4i4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4i4i4i4Di4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef uint32_t (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 GetUInt32(Int32, IntPtr, Puerts.IGetValueFromJs, IntPtr, Boolean) declare in Puerts.PrimitiveTypeTranslate
bool w_u4i4popb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4popb");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef uint32_t (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, void* p3, bool p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(Int64) declare in System.Convert
bool w_u4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(int64_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 op_Explicit(System.Xml.Linq.XAttribute) declare in System.Xml.Linq.XAttribute
bool w_u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4o");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint32_t (*FuncToCall)(Il2CppObject* p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(Byte[], Int32) declare in System.BitConverter
bool w_u4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ArchiveAndCompress(UnityEditor.Build.Content.ResourceFile[], System.String, UnityEngine.BuildCompression) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_u4osS_i4i4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4osS_i4i4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4i4u4_* pp2 = DataTransfer::GetPointer<S_i4i4u4_>(apis, env, _sv2);
    S_i4i4u4_ p2 = pp2 ? *pp2 : S_i4i4u4_ {};

    typedef uint32_t (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, struct S_i4i4u4_ p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ArchiveAndCompress(UnityEditor.Build.Content.ResourceFile[], System.String, UnityEngine.BuildCompression, Boolean) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_u4osS_i4i4u4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4osS_i4i4u4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4i4u4_* pp2 = DataTransfer::GetPointer<S_i4i4u4_>(apis, env, _sv2);
    S_i4i4u4_ p2 = pp2 ? *pp2 : S_i4i4u4_ {};
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef uint32_t (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, struct S_i4i4u4_ p2, bool p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 op_Modulus(Mono.Math.BigInteger, UInt32) declare in Mono.Math.BigInteger
bool w_u4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4ou4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(Il2CppObject* p0, uint32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 op_Explicit(UIntPtr) declare in System.UIntPtr
bool w_u4p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4p");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(void* p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ShowWindow(IntPtr, Int32) declare in JetBrains.Rider.Unity.Editor.NonUnity.User32Dll
bool w_u4pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 pesapi_get_value_uint32(IntPtr, IntPtr, IntPtr) declare in Puerts.NativeAPI
bool w_u4ppp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4ppp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef uint32_t (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(Single) declare in System.Convert
bool w_u4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(float p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(Double) declare in System.Convert
bool w_u4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(double p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(System.String) declare in System.Convert
bool w_u4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(Il2CppString* p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(System.String, Int32) declare in System.Convert
bool w_u4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4si4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider) declare in System.UInt32
bool w_u4si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4si4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef uint32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(System.String, System.IFormatProvider) declare in System.Convert
bool w_u4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint32_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 GetRegistryUInt32Value(System.String, System.String, UInt32, UnityEditorInternal.RegistryView) declare in UnityEditorInternal.RegistryUtil
bool w_u4ssu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4ssu4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef uint32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, uint32_t p2, int32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32() declare in System.UIntPtr
bool w_u4t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4t");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef uint32_t (*FuncToCall)(void*,const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(System.Object) declare in System.Runtime.Serialization.FormatterConverter
bool w_u4tO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4tO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint32_t (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ConsumeSampleFrames(Unity.Collections.NativeArray`1[System.Single]) declare in UnityEngine.Experimental.Audio.AudioSampleProvider
bool w_u4tS_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4tS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef uint32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 GetIndexStart(Int32) declare in UnityEngine.Mesh
bool w_u4ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4ti4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(void*,int32_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ReadUInt32(Int64) declare in System.IO.UnmanagedMemoryAccessor
bool w_u4ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4ti8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(void*,int64_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext) declare in UnityEngine.UIElements.UxmlUnsignedIntAttributeDescription
bool w_u4toS_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4toS_oooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};

    typedef uint32_t (*FuncToCall)(void*,Il2CppObject* p0, struct S_oooo_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ConvertToStartValue(DG.Tweening.Core.TweenerCore`3[System.UInt32,System.UInt32,DG.Tweening.Plugins.Options.UintOptions], UInt32) declare in DG.Tweening.Plugins.UintPlugin
bool w_u4tou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4tou4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(void*,Il2CppObject* p0, uint32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 GetUInt32(System.String) declare in System.Runtime.Serialization.SerializationInfo
bool w_u4ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 GetAudioSampleRate(UInt16) declare in UnityEngine.Video.VideoClip
bool w_u4tu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(void*,uint16_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 NextUInt(UInt32) declare in Unity.Mathematics.Random
bool w_u4tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(void*,uint32_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 NextUInt(UInt32, UInt32) declare in Unity.Mathematics.Random
bool w_u4tu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(void*,uint32_t p0, uint32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(Byte) declare in System.Convert
bool w_u4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(uint8_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(UInt16) declare in System.Convert
bool w_u4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(uint16_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(UInt32) declare in System.Convert
bool w_u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(uint32_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 rol(UInt32, Int32) declare in Unity.Mathematics.math
bool w_u4u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(uint32_t p0, int32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 GetLatestTimings(UInt32, UnityEngine.FrameTiming[]) declare in UnityEngine.FrameTimingManager
bool w_u4u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint32_t (*FuncToCall)(uint32_t p0, Il2CppObject* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 Max(UInt32, UInt32) declare in System.Math
bool w_u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(uint32_t p0, uint32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 select(UInt32, UInt32, Boolean) declare in Unity.Mathematics.math
bool w_u4u4u4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef uint32_t (*FuncToCall)(uint32_t p0, uint32_t p1, bool p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 Clamp(UInt32, UInt32, UInt32) declare in System.Math
bool w_u4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u4u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef uint32_t (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt32 ToUInt32(UInt64) declare in System.Convert
bool w_u4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u4u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(uint64_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint32_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 GetGpuTimerFrequency() declare in UnityEngine.FrameTimingManager
bool w_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef uint64_t (*FuncToCall)(const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(System.Object) declare in System.Convert
bool w_u8O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8O");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint64_t (*FuncToCall)(Il2CppObject* p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(System.Object, System.IFormatProvider) declare in System.Convert
bool w_u8Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8Oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint64_t (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 VolatileRead(UInt64 ByRef) declare in System.Threading.Thread
bool w_u8Pu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8Pu8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    uint64_t up0 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv0);
    uint64_t* p0 = &up0;

    typedef uint64_t (*FuncToCall)(uint64_t* p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint64_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 fread(Void*, UInt64, UInt64, IntPtr) declare in Mono.Unix.Native.Stdlib
bool w_u8Pvu8u8p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8Pvu8u8p");
    
    auto TIp3 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);

    typedef uint64_t (*FuncToCall)(void* p0, uint64_t p1, uint64_t p2, void* p3, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(System.ReadOnlySpan`1[System.Byte]) declare in System.BitConverter
bool w_u8S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef uint64_t (*FuncToCall)(struct S_S_p_i4_ p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider) declare in System.UInt64
bool w_u8S_S_p_i4_Di4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_S_p_i4_Di4Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef uint64_t (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 GetSceneCullingMask(UnityEngine.SceneManagement.Scene) declare in UnityEditor.SceneManagement.EditorSceneManager
bool w_u8S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};

    typedef uint64_t (*FuncToCall)(struct S_i4_ p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(System.Decimal) declare in System.Convert
bool w_u8S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef uint64_t (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 op_Explicit(System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_u8S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};

    typedef uint64_t (*FuncToCall)(struct S_i4o_ p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(System.DateTime) declare in System.Convert
bool w_u8S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef uint64_t (*FuncToCall)(struct S_u8_ p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(Boolean) declare in System.Convert
bool w_u8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(bool p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(Char) declare in System.Convert
bool w_u8c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8c");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(Il2CppChar p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(SByte) declare in System.Convert
bool w_u8i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(int8_t p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(Int16) declare in System.Convert
bool w_u8i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(int16_t p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(Int32) declare in System.Convert
bool w_u8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(int32_t p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 confstr(Mono.Unix.Native.ConfstrName, System.Text.StringBuilder, UInt64) declare in Mono.Unix.Native.Syscall
bool w_u8i4ou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8i4ou8");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);

    typedef uint64_t (*FuncToCall)(int32_t p0, Il2CppObject* p1, uint64_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 GetUInt64(Int32, IntPtr, Puerts.IGetValueFromJs, IntPtr, Boolean) declare in Puerts.PrimitiveTypeTranslate
bool w_u8i4popb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8i4popb");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef uint64_t (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, void* p3, bool p4, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(Int64) declare in System.Convert
bool w_u8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(int64_t p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 GetLocalIdentifierInFileForPersistentObject(UnityEngine.Object) declare in UnityEditor.Unsupported
bool w_u8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8o");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint64_t (*FuncToCall)(Il2CppObject* p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(Byte[], Int32) declare in System.BitConverter
bool w_u8oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint64_t (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 fread(Byte[], IntPtr) declare in Mono.Unix.Native.Stdlib
bool w_u8op(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8op");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef uint64_t (*FuncToCall)(Il2CppObject* p0, void* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 fread(Byte[], UInt64, UInt64, IntPtr) declare in Mono.Unix.Native.Stdlib
bool w_u8ou8u8p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8ou8u8p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);

    typedef uint64_t (*FuncToCall)(Il2CppObject* p0, uint64_t p1, uint64_t p2, void* p3, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 op_Explicit(UIntPtr) declare in System.UIntPtr
bool w_u8p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8p");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(void* p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 pesapi_get_value_uint64(IntPtr, IntPtr, IntPtr) declare in Puerts.NativeAPI
bool w_u8ppp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8ppp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef uint64_t (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 fread(IntPtr, UInt64, UInt64, IntPtr) declare in Mono.Unix.Native.Stdlib
bool w_u8pu8u8p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8pu8u8p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);

    typedef uint64_t (*FuncToCall)(void* p0, uint64_t p1, uint64_t p2, void* p3, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(Single) declare in System.Convert
bool w_u8r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(float p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(Double) declare in System.Convert
bool w_u8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(double p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(System.String) declare in System.Convert
bool w_u8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(Il2CppString* p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(System.String, Int32) declare in System.Convert
bool w_u8si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8si4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint64_t (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider) declare in System.UInt64
bool w_u8si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8si4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef uint64_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(System.String, System.IFormatProvider) declare in System.Convert
bool w_u8so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint64_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64() declare in System.UIntPtr
bool w_u8t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8t");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef uint64_t (*FuncToCall)(void*,const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(System.Object) declare in System.Runtime.Serialization.FormatterConverter
bool w_u8tO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8tO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint64_t (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 GetSampleStartTimeNs(Int32) declare in UnityEditor.Profiling.RawFrameDataView
bool w_u8ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8ti4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(void*,int32_t p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ReadUInt64(Int64) declare in System.IO.UnmanagedMemoryAccessor
bool w_u8ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8ti8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(void*,int64_t p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext) declare in UnityEngine.UIElements.UxmlUnsignedLongAttributeDescription
bool w_u8toS_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8toS_oooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};

    typedef uint64_t (*FuncToCall)(void*,Il2CppObject* p0, struct S_oooo_ p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ConvertToStartValue(DG.Tweening.Core.TweenerCore`3[System.UInt64,System.UInt64,DG.Tweening.Plugins.Options.NoOptions], UInt64) declare in DG.Tweening.Plugins.UlongPlugin
bool w_u8tou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8tou8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef uint64_t (*FuncToCall)(void*,Il2CppObject* p0, uint64_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 GetUInt64(System.String) declare in System.Runtime.Serialization.SerializationInfo
bool w_u8ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 NextULong(UInt64) declare in NUnit.Framework.Internal.Randomizer
bool w_u8tu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8tu8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(void*,uint64_t p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 NextULong(UInt64, UInt64) declare in NUnit.Framework.Internal.Randomizer
bool w_u8tu8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8tu8u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef uint64_t (*FuncToCall)(void*,uint64_t p0, uint64_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(Byte) declare in System.Convert
bool w_u8u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(uint8_t p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(UInt16) declare in System.Convert
bool w_u8u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(uint16_t p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(UInt32) declare in System.Convert
bool w_u8u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(uint32_t p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ToUInt64(UInt64) declare in System.Convert
bool w_u8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(uint64_t p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 rol(UInt64, Int32) declare in Unity.Mathematics.math
bool w_u8u8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint64_t (*FuncToCall)(uint64_t p0, int32_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 ModifyMaskIfGameObjectIsHiddenForPrefabModeInContext(UInt64, UnityEngine.GameObject) declare in UnityEditor.GameObjectUtility
bool w_u8u8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint64_t (*FuncToCall)(uint64_t p0, Il2CppObject* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 Max(UInt64, UInt64) declare in System.Math
bool w_u8u8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef uint64_t (*FuncToCall)(uint64_t p0, uint64_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 umul128(UInt64, UInt64, UInt64 ByRef) declare in Unity.Burst.Intrinsics.Common
bool w_u8u8u8Pu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8u8Pu8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    uint64_t up2 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv2);
    uint64_t* p2 = &up2;

    typedef uint64_t (*FuncToCall)(uint64_t p0, uint64_t p1, uint64_t* p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<uint64_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 select(UInt64, UInt64, Boolean) declare in Unity.Mathematics.math
bool w_u8u8u8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8u8b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef uint64_t (*FuncToCall)(uint64_t p0, uint64_t p1, bool p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// UInt64 Clamp(UInt64, UInt64, UInt64) declare in System.Math
bool w_u8u8u8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8u8u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);

    typedef uint64_t (*FuncToCall)(uint64_t p0, uint64_t p1, uint64_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<uint64_t>::toScript(apis, env, ret));
    return true;
}

// Void ClearCachedData() declare in System.TimeZoneInfo
bool w_v(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_v");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef void (*FuncToCall)(const void* method);
    ((FuncToCall)methodPointer)(  method);

    
    return true;
}

// Void SetGUIStyles(System.Nullable`1[UnityEngine.Vector2]) declare in DG.DOTweenEditor.UI.EditorGUIUtils
bool w_vDN_bS_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vDN_bS_r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    N_bS_r4r4__ p0 = OptionalParameter<N_bS_r4r4__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef void (*FuncToCall)(struct N_bS_r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void ShowDetails(Boolean) declare in UnityEditor.Progress
bool w_vDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vDb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef void (*FuncToCall)(bool p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Stop(Boolean, Boolean) declare in DG.DOTweenEditor.DOTweenEditorPreview
bool w_vDbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vDbDb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(bool p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Start(System.Action) declare in DG.DOTweenEditor.DOTweenEditorPreview
bool w_vDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vDo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal ref  with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 0, TIp0);
                

    typedef void (*FuncToCall)(Il2CppObject* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void True(System.Nullable`1[System.Boolean]) declare in NUnit.Framework.Assert
bool w_vN_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vN_bb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bb_* pp0 = DataTransfer::GetPointer<N_bb_>(apis, env, _sv0);
    N_bb_ p0 = pp0 ? *pp0 : N_bb_ {};

    typedef void (*FuncToCall)(struct N_bb_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void True(System.Nullable`1[System.Boolean], System.String, System.Object[]) declare in NUnit.Framework.Assert
bool w_vN_bb_sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vN_bb_sVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    N_bb_* pp0 = DataTransfer::GetPointer<N_bb_>(apis, env, _sv0);
    N_bb_ p0 = pp0 ? *pp0 : N_bb_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef void (*FuncToCall)(struct N_bb_ p0, Il2CppString* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void IsNaN(System.Nullable`1[System.Double]) declare in NUnit.Framework.Assert
bool w_vN_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vN_br8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_br8_* pp0 = DataTransfer::GetPointer<N_br8_>(apis, env, _sv0);
    N_br8_ p0 = pp0 ? *pp0 : N_br8_ {};

    typedef void (*FuncToCall)(struct N_br8_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void IsNaN(System.Nullable`1[System.Double], System.String, System.Object[]) declare in NUnit.Framework.Assert
bool w_vN_br8_sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vN_br8_sVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    N_br8_* pp0 = DataTransfer::GetPointer<N_br8_>(apis, env, _sv0);
    N_br8_ p0 = pp0 ? *pp0 : N_br8_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef void (*FuncToCall)(struct N_br8_ p0, Il2CppString* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void KeepAlive(System.Object) declare in System.GC
bool w_vO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef void (*FuncToCall)(Il2CppObject* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void LogWarning(System.Object, DG.Tweening.Tween) declare in DG.Tweening.Core.Debugger
bool w_vODo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vODo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef void (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void CopySerializedManagedFieldsOnly(System.Object, System.Object) declare in UnityEditor.EditorUtility
bool w_vOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AssertAreEqual(System.Object, System.Object, System.String) declare in Codice.CM.Common.CmAssert
bool w_vOOs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOOs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void AreEqual(System.Object, System.Object, System.String, System.Object[]) declare in NUnit.Framework.Assert
bool w_vOOsVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOOsVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef void (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void Enter(System.Object, Boolean ByRef) declare in System.Threading.Monitor
bool w_vOPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOPb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;

    typedef void (*FuncToCall)(Il2CppObject* p0, bool* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    
    return true;
}

// Void CopyObjectAddressToPtr(System.Object, Void*) declare in Unity.Collections.LowLevel.Unsafe.UnsafeUtility
bool w_vOPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOPv");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Combine(System.Object, System.Guid, Int32, System.Delegate) declare in System.Runtime.InteropServices.ComEventsHelper
bool w_vOS_i4i2i2u1u1u1u1u1u1u1u1_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOS_i4i2i2u1u1u1u1u1u1u1u1_i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(Il2CppObject* p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, int32_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void TryEnter(System.Object, System.TimeSpan, Boolean ByRef) declare in System.Threading.Monitor
bool w_vOS_i8_Pb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOS_i8_Pb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
    // JSValToCSVal P primitive
    bool up2 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv2);
    bool* p2 = &up2;

    typedef void (*FuncToCall)(Il2CppObject* p0, struct S_i8_ p1, bool* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<bool>::toScript(apis, env, *p2));
    
    return true;
}

// Void ChangeWrapperHandleStrength(System.Object, Boolean) declare in System.Runtime.InteropServices.Marshal
bool w_vOb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void TryEnter(System.Object, Int32, Boolean ByRef) declare in System.Threading.Monitor
bool w_vOi4Pb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4Pb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    bool up2 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv2);
    bool* p2 = &up2;

    typedef void (*FuncToCall)(Il2CppObject* p0, int32_t p1, bool* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<bool>::toScript(apis, env, *p2));
    
    return true;
}

// Void WriteInt16(System.Object, Int32, Char) declare in System.Runtime.InteropServices.Marshal
bool w_vOi4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4c");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppChar p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void WriteInt16(System.Object, Int32, Int16) declare in System.Runtime.InteropServices.Marshal
bool w_vOi4i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4i2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p0, int32_t p1, int16_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void WriteInt32(System.Object, Int32, Int32) declare in System.Runtime.InteropServices.Marshal
bool w_vOi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void WriteInt64(System.Object, Int32, Int64) declare in System.Runtime.InteropServices.Marshal
bool w_vOi4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p0, int32_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void WriteIntPtr(System.Object, Int32, IntPtr) declare in System.Runtime.InteropServices.Marshal
bool w_vOi4p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void WriteByte(System.Object, Int32, Byte) declare in System.Runtime.InteropServices.Marshal
bool w_vOi4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4u1");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p0, int32_t p1, uint8_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Log(System.Object, UnityEngine.Object) declare in UnityEngine.Debug
bool w_vOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void GetObjectData(System.Object, System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) declare in System.Runtime.Remoting.RemotingServices
bool w_vOoS_Oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOoS_Oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_Oi4_* pp2 = DataTransfer::GetPointer<S_Oi4_>(apis, env, _sv2);
    S_Oi4_ p2 = pp2 ? *pp2 : S_Oi4_ {};

    typedef void (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_Oi4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void ValidateObject(System.Object, System.ComponentModel.DataAnnotations.ValidationContext, Boolean) declare in System.ComponentModel.DataAnnotations.Validator
bool w_vOob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SerializeQueryResult(System.Object, Codice.CM.Common.Serialization.PlasticBinaryWriter, Codice.CM.Common.EnumQueryObjectType, Byte) declare in PlasticPipe.PlasticProtocol.Messages.Serialization.QuerySerialization
bool w_vOoi4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOoi4u1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, uint8_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void ValidateValue(System.Object, System.ComponentModel.DataAnnotations.ValidationContext, System.Collections.Generic.IEnumerable`1[System.ComponentModel.DataAnnotations.ValidationAttribute]) declare in System.ComponentModel.DataAnnotations.Validator
bool w_vOoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void ByVal(System.Object, NUnit.Framework.Constraints.IResolveConstraint, System.String, System.Object[]) declare in NUnit.Framework.Assert
bool w_vOosVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOosVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef void (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void GetNativeVariantForObject(System.Object, IntPtr) declare in System.Runtime.InteropServices.Marshal
bool w_vOp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void StructureToPtr(System.Object, IntPtr, Boolean) declare in System.Runtime.InteropServices.Marshal
bool w_vOpb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOpb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Write(System.Object, System.String) declare in System.Diagnostics.Debug
bool w_vOs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void NotNull(System.Object, System.String, System.Object[]) declare in NUnit.Framework.Assert
bool w_vOsVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vOsVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef void (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void VolatileWrite(System.Object ByRef, System.Object) declare in System.Threading.Thread
bool w_vPOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPOO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject** p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    return true;
}

// Void ApplySliceTransform(UnityEngine.Rendering.Universal.ShadowSliceData ByRef, Int32, Int32) declare in UnityEngine.Rendering.Universal.ShadowUtils
bool w_vPS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___* p0 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void SetActivityId(System.Guid ByRef) declare in System.Diagnostics.Eventing.EventProvider
bool w_vPS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i2i2u1u1u1u1u1u1u1u1_));
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void GetJobRange(Unity.Jobs.LowLevel.Unsafe.JobRanges ByRef, Int32, Int32 ByRef, Int32 ByRef) declare in Unity.Jobs.LowLevel.Unsafe.JobsUtility
bool w_vPS_i4i4i4p_i4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4i4i4p_i4Pi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4i4p_* p0 = DataTransfer::GetPointer<S_i4i4i4p_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4p_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4i4p_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef void (*FuncToCall)(struct S_i4i4i4p_* p0, int32_t p1, int32_t* p2, int32_t* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    return true;
}

// Void Draw(UnityEditorInternal.NativeProfilerTimeline_DrawArgs ByRef) declare in UnityEditorInternal.NativeProfilerTimeline
bool w_vPS_i4i4r4S_r4r4r4r4_S_r4r4r4r4_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4i4r4S_r4r4r4r4_S_r4r4r4r4_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_i4i4_* p0 = DataTransfer::GetPointer<S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_i4i4_));
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(struct S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_i4i4_* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void RenderPrimitives(UnityEngine.RenderParams ByRef, UnityEngine.MeshTopology, Int32, Int32) declare in UnityEngine.Graphics
bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4i4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4i4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(struct S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void RenderPrimitivesIndirect(UnityEngine.RenderParams ByRef, UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, Int32, Int32) declare in UnityEngine.Graphics
bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4oDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4oDi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(struct S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0, int32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void RenderPrimitivesIndexed(UnityEngine.RenderParams ByRef, UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, Int32, Int32, Int32) declare in UnityEngine.Graphics
bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4oi4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4oi4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef void (*FuncToCall)(struct S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0, int32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void RenderPrimitivesIndexedIndirect(UnityEngine.RenderParams ByRef, UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, UnityEngine.GraphicsBuffer, Int32, Int32) declare in UnityEngine.Graphics
bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4ooDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4ooDi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef void (*FuncToCall)(struct S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void RenderMeshPrimitives(UnityEngine.RenderParams ByRef, UnityEngine.Mesh, Int32, Int32) declare in UnityEngine.Graphics
bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_oi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_oi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(struct S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0, Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void RenderMesh(UnityEngine.RenderParams ByRef, UnityEngine.Mesh, Int32, UnityEngine.Matrix4x4, System.Nullable`1[UnityEngine.Matrix4x4]) declare in UnityEngine.Graphics
bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_oi4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_DN_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_oi4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_DN_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal valuetype  with default
    N_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p4 = OptionalParameter<N_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(struct S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0, Il2CppObject* p1, int32_t p2, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3, struct N_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void RenderMeshIndirect(UnityEngine.RenderParams ByRef, UnityEngine.Mesh, UnityEngine.GraphicsBuffer, Int32, Int32) declare in UnityEngine.Graphics
bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ooDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ooDi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(struct S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void GrabHandleInfo(Handle ByRef, Int32) declare in UnityEngine.Rendering.VirtualTexturing.Debugging
bool w_vPS_i8ssi4o_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i8ssi4o_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i8ssi4o_* p0 = DataTransfer::GetPointer<S_i8ssi4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i8ssi4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i8ssi4o_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_i8ssi4o_* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void Initialize(UnityEngine.LowLevel.PlayerLoopSystem ByRef, Cysharp.Threading.Tasks.InjectPlayerLoopTimings) declare in Cysharp.Threading.Tasks.PlayerLoopHelper
bool w_vPS_ooopp_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_ooopp_Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_ooopp_* p0 = DataTransfer::GetPointer<S_ooopp_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_ooopp_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_ooopp_));
        p0 = &up0;
    }
        
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(struct S_ooopp_* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void PrepareUndisposable(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle ByRef) declare in Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle
bool w_vPS_pi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_pi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_pi4i4_* p0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_pi4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_pi4i4_));
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(struct S_pi4i4_* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void Dispose(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle ByRef, Unity.Collections.LowLevel.Unsafe.DisposeSentinel ByRef) declare in Unity.Collections.LowLevel.Unsafe.DisposeSentinel
bool w_vPS_pi4i4_Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_pi4i4_Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_pi4i4_* p0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_pi4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_pi4i4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef void (*FuncToCall)(struct S_pi4i4_* p0, Il2CppObject** p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    return true;
}

// Void Create(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle ByRef, Unity.Collections.LowLevel.Unsafe.DisposeSentinel ByRef, Int32, Unity.Collections.Allocator) declare in Unity.Collections.LowLevel.Unsafe.DisposeSentinel
bool w_vPS_pi4i4_Poi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_pi4i4_Poi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_pi4i4_* p0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_pi4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_pi4i4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(struct S_pi4i4_* p0, Il2CppObject** p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    return true;
}

// Void SetStaticSafetyId(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle ByRef, Int32) declare in Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle
bool w_vPS_pi4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_pi4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_pi4i4_* p0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_pi4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_pi4i4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_pi4i4_* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef) declare in UnityEngine.Vector3
bool w_vPS_r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4_));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct S_r4r4r4_* p0, struct S_r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef) declare in UnityEngine.Vector3
bool w_vPS_r4r4r4_PS_r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4_PS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4_));
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct S_r4r4r4_* p0, struct S_r4r4r4_* p1, struct S_r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    return true;
}

// Void TransformHandle(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef) declare in UnityEditor.Handles
bool w_vPS_r4r4r4_PS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4r4_));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct S_r4r4r4_* p0, struct S_r4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void TransformHandle(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef, UnityEngine.Vector3 ByRef) declare in UnityEditor.Handles
bool w_vPS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4r4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4_));
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct S_r4r4r4_* p0, struct S_r4r4r4r4_* p1, struct S_r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    return true;
}

// Void TransformHandle(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef, Single ByRef) declare in UnityEditor.Handles
bool w_vPS_r4r4r4_PS_r4r4r4r4_Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4r4_Pr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4r4_));
        p1 = &up1;
    }
        
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;

    typedef void (*FuncToCall)(struct S_r4r4r4_* p0, struct S_r4r4r4r4_* p1, float* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    apis->update_boxed_value(env, _sv2, converter::Converter<float>::toScript(apis, env, *p2));
    
    return true;
}

// Void QuantisedVectorHash(UnityEngine.Vector3 ByRef, UnityEngine.Hash128 ByRef) declare in UnityEngine.HashUtilities
bool w_vPS_r4r4r4_PS_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_u8u8_* p1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8u8_));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct S_r4r4r4_* p0, struct S_u8u8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void TransformHandle(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion, UnityEngine.Vector3 ByRef) declare in UnityEditor.Handles
bool w_vPS_r4r4r4_S_r4r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_S_r4r4r4r4_PS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4_));
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct S_r4r4r4_* p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    return true;
}

// Void TransformHandle(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion, Single ByRef) declare in UnityEditor.Handles
bool w_vPS_r4r4r4_S_r4r4r4r4_Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_S_r4r4r4r4_Pr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;

    typedef void (*FuncToCall)(struct S_r4r4r4_* p0, struct S_r4r4r4r4_ p1, float* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    apis->update_boxed_value(env, _sv2, converter::Converter<float>::toScript(apis, env, *p2));
    
    return true;
}

// Void QuaternionNormalize(UnityEngine.Quaternion ByRef) declare in UnityEditor.MathUtils
bool w_vPS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4_));
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(struct S_r4r4r4r4_* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void SetDefaults(UnityEditor.UnwrapParam ByRef) declare in UnityEditor.UnwrapParam
bool w_vPS_r4r4r4r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4i4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4i4_));
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(struct S_r4r4r4r4i4_* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void Initialize(UnityEditorInternal.NativeProfilerTimeline_InitializeArgs ByRef) declare in UnityEditorInternal.NativeProfilerTimeline
bool w_vPS_r4r4r4r4r4poi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4r4poi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4poi4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4r4poi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4r4poi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4r4poi4_));
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(struct S_r4r4r4r4r4poi4_* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void QuantisedMatrixHash(UnityEngine.Matrix4x4 ByRef, UnityEngine.Hash128 ByRef) declare in UnityEngine.HashUtilities
bool w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_u8u8_* p1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8u8_));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, struct S_u8u8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void MatrixTimesTranslation(UnityEngine.Matrix4x4 ByRef, UnityEngine.Vector3) declare in UnityEngine.Rendering.CoreMatrixUtils
bool w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, struct S_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void CalculateProjectionMatrixFromPhysicalProperties(UnityEngine.Matrix4x4 ByRef, Single, UnityEngine.Vector2, UnityEngine.Vector2, Single, Single, GateFitParameters) declare in UnityEngine.Camera
bool w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4_S_r4r4_r4r4DS_i4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4_S_r4r4_r4r4DS_i4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 6) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal valuetype  with default
    S_i4r4_ p6 = OptionalParameter<S_i4r4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef void (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, float p1, struct S_r4r4_ p2, struct S_r4r4_ p3, float p4, float p5, struct S_i4r4_ p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void SetL0(UnityEngine.Rendering.SphericalHarmonicsL2 ByRef, UnityEngine.Vector3) declare in UnityEngine.Rendering.SphericalHarmonicsL2Utils
bool w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, struct S_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void SetL1(UnityEngine.Rendering.SphericalHarmonicsL2 ByRef, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Rendering.SphericalHarmonicsL2Utils
bool w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void SetCoefficient(UnityEngine.Rendering.SphericalHarmonicsL2 ByRef, Int32, UnityEngine.Vector3) declare in UnityEngine.Rendering.SphericalHarmonicsL2Utils
bool w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, int32_t p1, struct S_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void EnableKeyword(UnityEngine.Rendering.GlobalKeyword ByRef) declare in UnityEngine.Shader
bool w_vPS_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_su4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_su4_* p0 = DataTransfer::GetPointer<S_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_su4_));
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(struct S_su4_* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void SetKeyword(UnityEngine.Rendering.GlobalKeyword ByRef, Boolean) declare in UnityEngine.Shader
bool w_vPS_su4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_su4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_su4_* p0 = DataTransfer::GetPointer<S_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_su4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_su4_* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    return true;
}

// Void CompleteAll(Unity.Jobs.JobHandle ByRef, Unity.Jobs.JobHandle ByRef) declare in Unity.Jobs.JobHandle
bool w_vPS_u8i4i4p_PS_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u8i4i4p_PS_u8i4i4p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u8i4i4p_* p0 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8i4i4p_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u8i4i4p_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_u8i4i4p_* p1 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8i4i4p_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8i4i4p_));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct S_u8i4i4p_* p0, struct S_u8i4i4p_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void CompleteAll(Unity.Jobs.JobHandle ByRef, Unity.Jobs.JobHandle ByRef, Unity.Jobs.JobHandle ByRef) declare in Unity.Jobs.JobHandle
bool w_vPS_u8i4i4p_PS_u8i4i4p_PS_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u8i4i4p_PS_u8i4i4p_PS_u8i4i4p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u8i4i4p_* p0 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8i4i4p_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u8i4i4p_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_u8i4i4p_* p1 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8i4i4p_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8i4i4p_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_u8i4i4p_* p2 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_u8i4i4p_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_u8i4i4p_));
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct S_u8i4i4p_* p0, struct S_u8i4i4p_* p1, struct S_u8i4i4p_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    return true;
}

// Void AppendHash(UnityEngine.Hash128 ByRef, UnityEngine.Hash128 ByRef) declare in UnityEngine.HashUtilities
bool w_vPS_u8u8_PS_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u8u8_PS_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u8u8_* p0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8u8_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u8u8_));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_u8u8_* p1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8u8_));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct S_u8u8_* p0, struct S_u8u8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void Write(Boolean ByRef, Boolean) declare in System.Threading.Volatile
bool w_vPbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    bool up0 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv0);
    bool* p0 = &up0;
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(bool* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<bool>::toScript(apis, env, *p0));
    
    return true;
}

// Void VolatileWrite(SByte ByRef, SByte) declare in System.Threading.Thread
bool w_vPi1i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPi1i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    int8_t up0 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv0);
    int8_t* p0 = &up0;
    // JSValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(int8_t* p0, int8_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int8_t>::toScript(apis, env, *p0));
    
    return true;
}

// Void VolatileWrite(Int16 ByRef, Int16) declare in System.Threading.Thread
bool w_vPi2i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPi2i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    int16_t up0 = converter::Converter<std::reference_wrapper<int16_t>>::toCpp(apis, env, _sv0);
    int16_t* p0 = &up0;
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(int16_t* p0, int16_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int16_t>::toScript(apis, env, *p0));
    
    return true;
}

// Void GetMaxThreads(Int32 ByRef, Int32 ByRef) declare in System.Threading.ThreadPool
bool w_vPi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPi4Pi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef void (*FuncToCall)(int32_t* p0, int32_t* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    return true;
}

// Void VolatileWrite(Int32 ByRef, Int32) declare in System.Threading.Thread
bool w_vPi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPi4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(int32_t* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    
    return true;
}

// Void GetStats(Int64 ByRef, Int64 ByRef) declare in Codice.CM.Common.Serialization.TransferStats
bool w_vPi8Pi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPi8Pi8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv0);
    int64_t* p0 = &up0;
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv1);
    int64_t* p1 = &up1;

    typedef void (*FuncToCall)(int64_t* p0, int64_t* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int64_t>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<int64_t>::toScript(apis, env, *p1));
    
    return true;
}

// Void VolatileWrite(Int64 ByRef, Int64) declare in System.Threading.Thread
bool w_vPi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPi8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv0);
    int64_t* p0 = &up0;
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(int64_t* p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int64_t>::toScript(apis, env, *p0));
    
    return true;
}

// Void Clear(Unity.Collections.LowLevel.Unsafe.DisposeSentinel ByRef) declare in Unity.Collections.LowLevel.Unsafe.DisposeSentinel
bool w_vPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        

    typedef void (*FuncToCall)(Il2CppObject** p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    return true;
}

// Void EncryptUsingBufferPool(Byte[] ByRef, Int32 ByRef, Codice.CM.Common.IDataEncryptor, Codice.Utils.Buffers.FlexibleBufferPool) declare in Codice.CM.Common.Encryption.EncryptData
bool w_vPoPi4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPoPi4oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(Il2CppObject** p0, int32_t* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    return true;
}

// Void GetZoneAndOrigin(System.Collections.ArrayList ByRef, System.Collections.ArrayList ByRef) declare in System.Security.SecurityManager
bool w_vPoPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPoPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef void (*FuncToCall)(Il2CppObject** p0, Il2CppObject** p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    return true;
}

// Void SetRTHandleUserManagedWrapper(UnityEngine.Rendering.RTHandle ByRef, UnityEngine.Rendering.RenderTargetIdentifier) declare in UnityEngine.Rendering.RTHandleStaticHelpers
bool w_vPoS_i4i4i4pi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPoS_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(Il2CppObject** p0, struct S_i4i4i4pi4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    return true;
}

// Void DrawCascades(Cascade[] ByRef, Boolean, Single) declare in UnityEditor.Rendering.ShadowCascadeGUI
bool w_vPobr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPobr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject** p0, bool p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    return true;
}

// Void InterpAnimationCurve(UnityEngine.AnimationCurve ByRef, UnityEngine.AnimationCurve, Single) declare in UnityEngine.Rendering.KeyframeUtility
bool w_vPoor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPoor4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject** p0, Il2CppObject* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    return true;
}

// Void VolatileWrite(IntPtr ByRef, IntPtr) declare in System.Threading.Thread
bool w_vPpp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPpp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal P not primitive
    void** p0 = nullptr;
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef void (*FuncToCall)(void** p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, apis->create_binary(env, *p0, 0));
    
    return true;
}

// Void GetBrushWorldSizeLimits(Single ByRef, Single ByRef, Single, Int32, Int32, Int32) declare in UnityEngine.TerrainTools.TerrainPaintUtility
bool w_vPr4Pr4r4i4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPr4Pr4r4i4Di4Di4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv0);
    float* p0 = &up0;
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef void (*FuncToCall)(float* p0, float* p1, float p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<float>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<float>::toScript(apis, env, *p1));
    
    return true;
}

// Void MinMaxSlider(Single ByRef, Single ByRef, Single, Single, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_vPr4Pr4r4r4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPr4Pr4r4r4Vo");
    
    auto TIp4 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv0);
    float* p0 = &up0;
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef void (*FuncToCall)(float* p0, float* p1, float p2, float p3, Il2CppArray* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<float>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<float>::toScript(apis, env, *p1));
    
    return true;
}

// Void VolatileWrite(Single ByRef, Single) declare in System.Threading.Thread
bool w_vPr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPr4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv0);
    float* p0 = &up0;
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(float* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<float>::toScript(apis, env, *p0));
    
    return true;
}

// Void VolatileWrite(Double ByRef, Double) declare in System.Threading.Thread
bool w_vPr8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPr8r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    double up0 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv0);
    double* p0 = &up0;
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(double* p0, double p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<double>::toScript(apis, env, *p0));
    
    return true;
}

// Void CreateIndex(System.String ByRef, UnityEditor.Search.IndexingOptions ByRef, System.Collections.Generic.IEnumerable`1[System.String], System.Collections.Generic.IEnumerable`1[System.String], System.Collections.Generic.IEnumerable`1[System.String], System.Action`3[System.String,System.String,System.Action]) declare in UnityEditor.Search.SearchService
bool w_vPsPu1oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPsPu1oooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        
    // JSValToCSVal P primitive
    uint8_t up1 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv1);
    uint8_t* p1 = &up1;
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef void (*FuncToCall)(Il2CppString** p0, uint8_t* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<uint8_t>::toScript(apis, env, *p1));
    
    return true;
}

// Void CopyBlock(Byte ByRef, Byte ByRef, UInt32) declare in System.Runtime.CompilerServices.Unsafe
bool w_vPu1Pu1u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPu1Pu1u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P primitive
    uint8_t up0 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv0);
    uint8_t* p0 = &up0;
    // JSValToCSVal P primitive
    uint8_t up1 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv1);
    uint8_t* p1 = &up1;
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(uint8_t* p0, uint8_t* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint8_t>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<uint8_t>::toScript(apis, env, *p1));
    
    return true;
}

// Void VolatileWrite(Byte ByRef, Byte) declare in System.Threading.Thread
bool w_vPu1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPu1u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    uint8_t up0 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv0);
    uint8_t* p0 = &up0;
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(uint8_t* p0, uint8_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint8_t>::toScript(apis, env, *p0));
    
    return true;
}

// Void InitBlock(Byte ByRef, Byte, UInt32) declare in System.Runtime.CompilerServices.Unsafe
bool w_vPu1u1u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPu1u1u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P primitive
    uint8_t up0 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv0);
    uint8_t* p0 = &up0;
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(uint8_t* p0, uint8_t p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint8_t>::toScript(apis, env, *p0));
    
    return true;
}

// Void VolatileWrite(UInt16 ByRef, UInt16) declare in System.Threading.Thread
bool w_vPu2u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPu2u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    uint16_t up0 = converter::Converter<std::reference_wrapper<uint16_t>>::toCpp(apis, env, _sv0);
    uint16_t* p0 = &up0;
    // JSValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(uint16_t* p0, uint16_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint16_t>::toScript(apis, env, *p0));
    
    return true;
}

// Void GetRenderingResolution(UInt32 ByRef, UInt32 ByRef) declare in UnityEditor.PlayModeWindow
bool w_vPu4Pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPu4Pu4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    uint32_t up0 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv0);
    uint32_t* p0 = &up0;
    // JSValToCSVal P primitive
    uint32_t up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;

    typedef void (*FuncToCall)(uint32_t* p0, uint32_t* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint32_t>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<uint32_t>::toScript(apis, env, *p1));
    
    return true;
}

// Void VolatileWrite(UInt32 ByRef, UInt32) declare in System.Threading.Thread
bool w_vPu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPu4u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    uint32_t up0 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv0);
    uint32_t* p0 = &up0;
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(uint32_t* p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint32_t>::toScript(apis, env, *p0));
    
    return true;
}

// Void VolatileWrite(UInt64 ByRef, UInt64) declare in System.Threading.Thread
bool w_vPu8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPu8u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    uint64_t up0 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv0);
    uint64_t* p0 = &up0;
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(uint64_t* p0, uint64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint64_t>::toScript(apis, env, *p0));
    
    return true;
}

// Void Free(System.Threading.NativeOverlapped*) declare in System.Threading.Overlapped
bool w_vPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPv");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void ExpectAliased(Void*, Void*) declare in Unity.Burst.CompilerServices.Aliasing
bool w_vPvPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvPv");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void MemCpyReplicate(Void*, Void*, Int32, Int32) declare in Unity.Collections.LowLevel.Unsafe.UnsafeUtility
bool w_vPvPvi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvPvi4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void* p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void MemCpy(Void*, Void*, Int64) declare in Unity.Collections.LowLevel.Unsafe.UnsafeUtility
bool w_vPvPvi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvPvi8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void* p0, void* p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void MemoryCopy(Void*, Void*, Int64, Int64) declare in System.Buffer
bool w_vPvPvi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvPvi8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void* p0, void* p1, int64_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void CopyBlock(Void*, Void*, UInt32) declare in System.Runtime.CompilerServices.Unsafe
bool w_vPvPvu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvPvu4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void* p0, void* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void ForwardRawInput(UInt32*, UInt32*, UInt32, Byte*, UInt32) declare in UnityEngine.Windows.Input
bool w_vPvPvu4Pvu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvPvu4Pvu4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void* p0, void* p1, uint32_t p2, void* p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void MemoryCopy(Void*, Void*, UInt64, UInt64) declare in System.Buffer
bool w_vPvPvu8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvPvu8u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint64_t p3 = converter::Converter<uint64_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void* p0, void* p1, uint64_t p2, uint64_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void FreeTracked(Void*, Unity.Collections.Allocator) declare in Unity.Collections.LowLevel.Unsafe.UnsafeUtility
bool w_vPvi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void MemCpyStride(Void*, Int32, Void*, Int32, Int32, Int32) declare in Unity.Collections.LowLevel.Unsafe.UnsafeUtility
bool w_vPvi4Pvi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvi4Pvi4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void MemClear(Void*, Int64) declare in Unity.Collections.LowLevel.Unsafe.UnsafeUtility
bool w_vPvi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvi8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void* p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void MemSet(Void*, Byte, Int64) declare in Unity.Collections.LowLevel.Unsafe.UnsafeUtility
bool w_vPvu1i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvu1i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void* p0, uint8_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void InitBlock(Void*, Byte, UInt32) declare in System.Runtime.CompilerServices.Unsafe
bool w_vPvu1u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvu1u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void* p0, uint8_t p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void ComputeHash128(Void*, UInt64, UnityEngine.Hash128*) declare in UnityEngine.HashUnsafeUtilities
bool w_vPvu8Pv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvu8Pv");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef void (*FuncToCall)(void* p0, uint64_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void ComputeHash128(Void*, UInt64, UInt64*, UInt64*) declare in UnityEngine.HashUnsafeUtilities
bool w_vPvu8PvPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vPvu8PvPv");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);

    typedef void (*FuncToCall)(void* p0, uint64_t p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void ApplyAndDisposeWritableMeshData(MeshDataArray, UnityEngine.Mesh, UnityEngine.Rendering.MeshUpdateFlags) declare in UnityEngine.Mesh
bool w_vS_Pvi4i4i4S_pi4i4__oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4__oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4__* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4__>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4__ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4__ p0, Il2CppObject* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void CompleteAll(Unity.Collections.NativeArray`1[Unity.Jobs.JobHandle]) declare in Unity.Jobs.JobHandle
bool w_vS_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void InstanceIDsToValidArray(Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[System.Boolean]) declare in UnityEngine.Resources
bool w_vS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void LookupArtifacts(Unity.Collections.NativeArray`1[UnityEditor.GUID], Unity.Collections.NativeArray`1[UnityEditor.Experimental.ArtifactID], System.Type) declare in UnityEditor.Experimental.AssetDatabaseExperimental
bool w_vS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void MoveGameObjectsToScene(Unity.Collections.NativeArray`1[System.Int32], UnityEngine.SceneManagement.Scene) declare in UnityEngine.SceneManagement.SceneManager
bool w_vS_Pvi4i4i4S_pi4i4_i4_S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_S_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};

    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGameObjectsActive(Unity.Collections.NativeArray`1[System.Int32], Boolean) declare in UnityEngine.GameObject
bool w_vS_Pvi4i4i4S_pi4i4_i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void InsertionSort(Unity.Collections.NativeArray`1[System.UInt32], Int32) declare in UnityEngine.Rendering.CoreUnsafeUtils
bool w_vS_Pvi4i4i4S_pi4i4_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void MergeSort(Unity.Collections.NativeArray`1[System.UInt32], Int32, Unity.Collections.NativeArray`1[System.UInt32] ByRef) declare in UnityEngine.Rendering.CoreUnsafeUtils
bool w_vS_Pvi4i4i4S_pi4i4_i4_i4PS_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_i4PS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_Pvi4i4i4S_pi4i4_i4_* p2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_Pvi4i4i4S_pi4i4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_Pvi4i4i4S_pi4i4_i4_));
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, int32_t p1, struct S_Pvi4i4i4S_pi4i4_i4_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    return true;
}

// Void RadixSort(Unity.Collections.NativeArray`1[System.UInt32], Int32, Unity.Collections.NativeArray`1[System.UInt32] ByRef, Int32) declare in UnityEngine.Rendering.CoreUnsafeUtils
bool w_vS_Pvi4i4i4S_pi4i4_i4_i4PS_Pvi4i4i4S_pi4i4_i4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_i4PS_Pvi4i4i4S_pi4i4_i4_Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_Pvi4i4i4S_pi4i4_i4_* p2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_Pvi4i4i4S_pi4i4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_Pvi4i4i4S_pi4i4_i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, int32_t p1, struct S_Pvi4i4i4S_pi4i4_i4_* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    return true;
}

// Void InitializeLightConstants_Common(Unity.Collections.NativeArray`1[UnityEngine.Rendering.VisibleLight], Int32, UnityEngine.Vector4 ByRef, UnityEngine.Vector4 ByRef, UnityEngine.Vector4 ByRef, UnityEngine.Vector4 ByRef, UnityEngine.Vector4 ByRef) declare in UnityEngine.Rendering.Universal.UniversalRenderPipeline
bool w_vS_Pvi4i4i4S_pi4i4_i4_i4PS_r4r4r4r4_PS_r4r4r4r4_PS_r4r4r4r4_PS_r4r4r4r4_PS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_i4PS_r4r4r4r4_PS_r4r4r4r4_PS_r4r4r4r4_PS_r4r4r4r4_PS_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4r4_));
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_r4r4r4r4_));
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_r4r4r4r4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_r4r4r4r4_));
        p4 = &up4;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p5 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv5)); // valuetype ref
    S_r4r4r4r4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(S_r4r4r4r4_));
        p5 = &up5;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p6 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv6)); // valuetype ref
    S_r4r4r4r4_ up6;
    if (!p6) {
        memset(&up6, 0, sizeof(S_r4r4r4r4_));
        p6 = &up6;
    }
        

    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, int32_t p1, struct S_r4r4r4r4_* p2, struct S_r4r4r4r4_* p3, struct S_r4r4r4r4_* p4, struct S_r4r4r4r4_* p5, struct S_r4r4r4r4_* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
            
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
            
    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
            
    if (p5 == &up5)
    {
        apis->update_boxed_value(env, _sv5, DataTransfer::CopyValueType(apis, env, *p5, TIp5));
    }
            
    if (p6 == &up6)
    {
        apis->update_boxed_value(env, _sv6, DataTransfer::CopyValueType(apis, env, *p6, TIp6));
    }
    
    return true;
}

// Void InstanceIDToObjectList(Unity.Collections.NativeArray`1[System.Int32], System.Collections.Generic.List`1[UnityEngine.Object]) declare in UnityEngine.Resources
bool w_vS_Pvi4i4i4S_pi4i4_i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void ZeroMemory(System.Span`1[System.Byte]) declare in System.Security.Cryptography.CryptographicOperations
bool w_vS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef void (*FuncToCall)(struct S_S_p_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void InstanceIDsToValidArray(System.ReadOnlySpan`1[System.Int32], System.Span`1[System.Boolean]) declare in UnityEngine.Resources
bool w_vS_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_S_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};

    typedef void (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawLineStrip(System.ReadOnlySpan`1[UnityEngine.Vector3], Boolean) declare in UnityEngine.Gizmos
bool w_vS_S_p_i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_S_p_i4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void WriteInt16BigEndian(System.Span`1[System.Byte], Int16) declare in System.Buffers.Binary.BinaryPrimitives
bool w_vS_S_p_i4_i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_i2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_S_p_i4_ p0, int16_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void WriteInt32BigEndian(System.Span`1[System.Byte], Int32) declare in System.Buffers.Binary.BinaryPrimitives
bool w_vS_S_p_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void WriteInt64BigEndian(System.Span`1[System.Byte], Int64) declare in System.Buffers.Binary.BinaryPrimitives
bool w_vS_S_p_i4_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_S_p_i4_ p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void WriteUInt16BigEndian(System.Span`1[System.Byte], UInt16) declare in System.Buffers.Binary.BinaryPrimitives
bool w_vS_S_p_i4_u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_u2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_S_p_i4_ p0, uint16_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void WriteUInt32BigEndian(System.Span`1[System.Byte], UInt32) declare in System.Buffers.Binary.BinaryPrimitives
bool w_vS_S_p_i4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_u4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_S_p_i4_ p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void WriteUInt64BigEndian(System.Span`1[System.Byte], UInt64) declare in System.Buffers.Binary.BinaryPrimitives
bool w_vS_S_p_i4_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_u8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_S_p_i4_ p0, uint64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetTypedReference(TypedReference, System.Object) declare in System.TypedReference
bool w_vS_S_p_pp_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_pp_O");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_pp_* pp0 = DataTransfer::GetPointer<S_S_p_pp_>(apis, env, _sv0);
    S_S_p_pp_ p0 = pp0 ? *pp0 : S_S_p_pp_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(struct S_S_p_pp_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawRay(UnityEngine.Ray) declare in UnityEngine.Gizmos
bool w_vS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef void (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void RebuildBroadphaseRegions(UnityEngine.Bounds, Int32) declare in UnityEngine.Physics
bool w_vS_S_r4r4r4_S_r4r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_r4r4r4_S_r4r4r4__i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void CollectSourcesInStage(UnityEngine.Bounds, Int32, UnityEngine.AI.NavMeshCollectGeometry, Int32, Boolean, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildMarkup], Boolean, UnityEngine.SceneManagement.Scene, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildSource]) declare in UnityEditor.AI.NavMeshBuilder
bool w_vS_S_r4r4r4_S_r4r4r4__i4i4i4bobS_i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_r4r4r4_S_r4r4r4__i4i4i4bobS_i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];
    auto TIp8 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal struct
    S_i4_* pp7 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv7);
    S_i4_ p7 = pp7 ? *pp7 : S_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p8 = JsValueToCSRef(apis, TIp8, env, _sv8);

    typedef void (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, int32_t p1, int32_t p2, int32_t p3, bool p4, Il2CppObject* p5, bool p6, struct S_i4_ p7, Il2CppObject* p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void CollectSources(UnityEngine.Bounds, Int32, UnityEngine.AI.NavMeshCollectGeometry, Int32, Boolean, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildMarkup], Boolean, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildSource]) declare in UnityEngine.AI.NavMeshBuilder
bool w_vS_S_r4r4r4_S_r4r4r4__i4i4i4bobo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_r4r4r4_S_r4r4r4__i4i4i4bobo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef void (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, int32_t p1, int32_t p2, int32_t p3, bool p4, Il2CppObject* p5, bool p6, Il2CppObject* p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void CollectSourcesInStage(UnityEngine.Bounds, Int32, UnityEngine.AI.NavMeshCollectGeometry, Int32, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildMarkup], UnityEngine.SceneManagement.Scene, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildSource]) declare in UnityEditor.AI.NavMeshBuilder
bool w_vS_S_r4r4r4_S_r4r4r4__i4i4i4oS_i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_r4r4r4_S_r4r4r4__i4i4i4oS_i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal struct
    S_i4_* pp5 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv5);
    S_i4_ p5 = pp5 ? *pp5 : S_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef void (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, int32_t p1, int32_t p2, int32_t p3, Il2CppObject* p4, struct S_i4_ p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void CollectSources(UnityEngine.Bounds, Int32, UnityEngine.AI.NavMeshCollectGeometry, Int32, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildMarkup], System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildSource]) declare in UnityEngine.AI.NavMeshBuilder
bool w_vS_S_r4r4r4_S_r4r4r4__i4i4i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_r4r4r4_S_r4r4r4__i4i4i4oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef void (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, int32_t p1, int32_t p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Widen(System.Numerics.Vector`1[System.Byte], System.Numerics.Vector`1[System.UInt16] ByRef, System.Numerics.Vector`1[System.UInt16] ByRef) declare in System.Numerics.Vector
bool w_vS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__PS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__PS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__PS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__PS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp0 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(apis, env, _sv0);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p0 = pp0 ? *pp0 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
    // JSValToCSVal Pstruct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* p1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* p2 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__));
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p0, struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* p1, struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    return true;
}

// Void WaitOnGPUFence(UnityEngine.Rendering.GPUFence) declare in UnityEngine.Graphics
bool w_vS__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};

    typedef void (*FuncToCall)(struct S__ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void CloseConnection(UnityEngine.NetworkPlayer, Boolean) declare in UnityEngine.Network
bool w_vS__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS__b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S__ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void WaitOnGPUFence(UnityEngine.Rendering.GPUFence, UnityEngine.Rendering.SynchronisationStage) declare in UnityEngine.Graphics
bool w_vS__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS__i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S__ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetReceivingEnabled(UnityEngine.NetworkPlayer, Int32, Boolean) declare in UnityEngine.Network
bool w_vS__i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS__i4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(struct S__ p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void set_jobOptions(UnityEngine.PhysicsJobOptions2D) declare in UnityEngine.Physics2D
bool w_vS_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};

    typedef void (*FuncToCall)(struct S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void AsyncValidation(PlasticGui.WorkspaceWindow.QueryViews.Branches.BranchCreationData, PlasticGui.IPlasticDialogCloser, PlasticGui.IProgressControls) declare in PlasticGui.WorkspaceWindow.QueryViews.Branches.BranchCreationValidation
bool w_vS_booi8ssob_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_booi8ssob_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_booi8ssob_* pp0 = DataTransfer::GetPointer<S_booi8ssob_>(apis, env, _sv0);
    S_booi8ssob_ p0 = pp0 ? *pp0 : S_booi8ssob_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(struct S_booi8ssob_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void AsyncValidation(PlasticGui.WorkspaceWindow.QueryViews.Branches.BranchRenameData, PlasticGui.IPlasticDialogCloser, PlasticGui.IProgressControls) declare in PlasticGui.WorkspaceWindow.QueryViews.Branches.BranchRenameValidation
bool w_vS_boos_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_boos_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_boos_* pp0 = DataTransfer::GetPointer<S_boos_>(apis, env, _sv0);
    S_boos_ p0 = pp0 ? *pp0 : S_boos_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(struct S_boos_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void AsyncValidation(PlasticGui.WorkspaceWindow.Home.Workspaces.WorkspaceRenameData, PlasticGui.IPlasticDialogCloser, PlasticGui.IProgressControls) declare in PlasticGui.WorkspaceWindow.Home.Workspaces.WorkspaceRenameValidation
bool w_vS_bos_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_bos_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_bos_* pp0 = DataTransfer::GetPointer<S_bos_>(apis, env, _sv0);
    S_bos_ p0 = pp0 ? *pp0 : S_bos_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(struct S_bos_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void AsyncValidation(PlasticGui.WorkspaceWindow.Home.Repositories.RepositoryCreationData, PlasticGui.IPlasticDialogCloser, PlasticGui.IProgressControls) declare in PlasticGui.WorkspaceWindow.Home.Repositories.RepositoryCreationValidation
bool w_vS_bss_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_bss_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_bss_* pp0 = DataTransfer::GetPointer<S_bss_>(apis, env, _sv0);
    S_bss_ p0 = pp0 ? *pp0 : S_bss_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(struct S_bss_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void ForWorkspacesView(PlasticGui.WorkspaceWindow.Home.Workspaces.WorkspaceCreationData, PlasticGui.IProgressControls, PlasticGui.IWorkspacesRefreshableView) declare in PlasticGui.WorkspaceWindow.Home.CreateWorkspace
bool w_vS_bsssbb_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_bsssbb_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_bsssbb_* pp0 = DataTransfer::GetPointer<S_bsssbb_>(apis, env, _sv0);
    S_bsssbb_ p0 = pp0 ? *pp0 : S_bsssbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(struct S_bsssbb_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void RemoveNavMeshData(UnityEngine.AI.NavMeshDataInstance) declare in UnityEngine.AI.NavMesh
bool w_vS_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};

    typedef void (*FuncToCall)(struct S_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void MoveCacheBefore(UnityEngine.Cache, UnityEngine.Cache) declare in UnityEngine.Caching
bool w_vS_i4_S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4_S_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};

    typedef void (*FuncToCall)(struct S_i4_ p0, struct S_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetLightingSettingsForScene(UnityEngine.SceneManagement.Scene, UnityEngine.LightingSettings) declare in UnityEditor.Lightmapping
bool w_vS_i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(struct S_i4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetSceneCullingMask(UnityEngine.SceneManagement.Scene, UInt64) declare in UnityEditor.SceneManagement.EditorSceneManager
bool w_vS_i4_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4_u8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_i4_ p0, uint64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetCurrentThreadActivityId(System.Guid) declare in System.Diagnostics.Tracing.EventSource
bool w_vS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void SetCurrentThreadActivityId(System.Guid, System.Guid ByRef) declare in System.Diagnostics.Tracing.EventSource
bool w_vS_i4i2i2u1u1u1u1u1u1u1u1_PS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i2i2u1u1u1u1u1u1u1u1_PS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i2i2u1u1u1u1u1u1u1u1_));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void GuidToLongs(System.Guid, Int64 ByRef, Int64 ByRef) declare in Codice.Utils.ConfigurationSection
bool w_vS_i4i2i2u1u1u1u1u1u1u1u1_Pi8Pi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i2i2u1u1u1u1u1u1u1u1_Pi8Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv1);
    int64_t* p1 = &up1;
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv2);
    int64_t* p2 = &up2;

    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, int64_t* p1, int64_t* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int64_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int64_t>::toScript(apis, env, *p2));
    
    return true;
}

// Void EmitFrameMetaData(System.Guid, Int32, System.Array) declare in UnityEngine.Profiling.Profiler
bool w_vS_i4i2i2u1u1u1u1u1u1u1u1_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i2i2u1u1u1u1u1u1u1u1_i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetDebugFlagInteger(System.Guid, Int64) declare in UnityEngine.Rendering.VirtualTexturing.Procedural
bool w_vS_i4i2i2u1u1u1u1u1u1u1u1_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i2i2u1u1u1u1u1u1u1u1_i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SerializeGUID(System.Guid, Codice.CM.Common.Serialization.PlasticBinaryWriter) declare in Codice.CM.Common.Serialization.SerializedObjectManager
bool w_vS_i4i2i2u1u1u1u1u1u1u1u1_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i2i2u1u1u1u1u1u1u1u1_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void UploadRemotePackage(System.Guid, Codice.CM.Interfaces.IReplicationHandler, System.String, Int64, Boolean, UploadPackageProgressDelegate) declare in Codice.CM.Common.Serialization.Replication.PackageIO
bool w_vS_i4i2i2u1u1u1u1u1u1u1u1_osi8bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i2i2u1u1u1u1u1u1u1u1_osi8bo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppObject* p1, Il2CppString* p2, int64_t p3, bool p4, Il2CppObject* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SetDebugFlagDouble(System.Guid, Double) declare in UnityEngine.Rendering.VirtualTexturing.Procedural
bool w_vS_i4i2i2u1u1u1u1u1u1u1u1_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i2i2u1u1u1u1u1u1u1u1_r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, double p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SaveComment(System.Guid, System.String) declare in PlasticGui.PendingChangesCommentsStorage
bool w_vS_i4i2i2u1u1u1u1u1u1u1u1_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i2i2u1u1u1u1u1u1u1u1_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void set_state(State) declare in UnityEngine.Random
bool w_vS_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};

    typedef void (*FuncToCall)(struct S_i4i4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Write(System.Decimal) declare in System.Console
bool w_vS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef void (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Greater(System.Decimal, System.Decimal) declare in NUnit.Framework.Assert
bool w_vS_i4i4i4i4u8_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};

    typedef void (*FuncToCall)(struct S_i4i4i4i4u8_ p0, struct S_i4i4i4i4u8_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Greater(System.Decimal, System.Decimal, System.String, System.Object[]) declare in NUnit.Framework.Assert
bool w_vS_i4i4i4i4u8_S_i4i4i4i4u8_sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4i4u8_S_i4i4i4i4u8_sVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef void (*FuncToCall)(struct S_i4i4i4i4u8_ p0, struct S_i4i4i4i4u8_ p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void Zero(System.Decimal, System.String, System.Object[]) declare in NUnit.Framework.Assert
bool w_vS_i4i4i4i4u8_sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4i4u8_sVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef void (*FuncToCall)(struct S_i4i4i4i4u8_ p0, Il2CppString* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetRTHandleStaticWrapper(UnityEngine.Rendering.RenderTargetIdentifier) declare in UnityEngine.Rendering.RTHandleStaticHelpers
bool w_vS_i4i4i4pi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(struct S_i4i4i4pi4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void ShowSelector(UnityEditor.Presets.PresetType, UnityEditor.Presets.Preset, Boolean, UnityEditor.Presets.PresetSelectorReceiver) declare in UnityEditor.Presets.PresetSelector
bool w_vS_i4os_obo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4os_obo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4os_* pp0 = DataTransfer::GetPointer<S_i4os_>(apis, env, _sv0);
    S_i4os_ p0 = pp0 ? *pp0 : S_i4os_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(struct S_i4os_ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer) declare in UnityEngine.Graphics
bool w_vS_i4p_S_i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4p_S_i4p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4p_* pp0 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv0);
    S_i4p_ p0 = pp0 ? *pp0 : S_i4p_ {};
    // JSValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};

    typedef void (*FuncToCall)(struct S_i4p_ p0, struct S_i4p_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32) declare in UnityEngine.Graphics
bool w_vS_i4p_S_i4p_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4p_S_i4p_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4p_* pp0 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv0);
    S_i4p_ p0 = pp0 ? *pp0 : S_i4p_ {};
    // JSValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(struct S_i4p_ p0, struct S_i4p_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace) declare in UnityEngine.Graphics
bool w_vS_i4p_S_i4p_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4p_S_i4p_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4p_* pp0 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv0);
    S_i4p_ p0 = pp0 ? *pp0 : S_i4p_ {};
    // JSValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(struct S_i4p_ p0, struct S_i4p_ p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace, Int32) declare in UnityEngine.Graphics
bool w_vS_i4p_S_i4p_i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4p_S_i4p_i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i4p_* pp0 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv0);
    S_i4p_ p0 = pp0 ? *pp0 : S_i4p_ {};
    // JSValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(struct S_i4p_ p0, struct S_i4p_ p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Sleep(System.TimeSpan) declare in System.Threading.Thread
bool w_vS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};

    typedef void (*FuncToCall)(struct S_i8_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void WriteFileData(FileData, Int32, Codice.CM.Common.Serialization.PlasticBinaryWriter) declare in Codice.CM.Common.Serialization.PacketFileReader
bool w_vS_i8i2u8bo_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i8i2u8bo_i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i8i2u8bo_* pp0 = DataTransfer::GetPointer<S_i8i2u8bo_>(apis, env, _sv0);
    S_i8i2u8bo_ p0 = pp0 ? *pp0 : S_i8i2u8bo_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(struct S_i8i2u8bo_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderTargetSetup) declare in UnityEngine.Graphics
bool w_vS_oS_i4p_i4i4i4ooi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_oS_i4p_i4i4i4ooi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oS_i4p_i4i4i4ooi4i4_* pp0 = DataTransfer::GetPointer<S_oS_i4p_i4i4i4ooi4i4_>(apis, env, _sv0);
    S_oS_i4p_i4i4i4ooi4i4_ p0 = pp0 ? *pp0 : S_oS_i4p_i4i4i4ooi4i4_ {};

    typedef void (*FuncToCall)(struct S_oS_i4p_i4i4i4ooi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Initialize(JetBrains.Lifetimes.Lifetime) declare in JetBrains.Rider.Unity.Editor.Profiler.ProfilerWindowEventsHandler
bool w_vS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef void (*FuncToCall)(struct S_o_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Inputs(BakedLitProperties, UnityEditor.MaterialEditor) declare in UnityEditor.Rendering.Universal.ShaderGUI.BakedLitGUI
bool w_vS_o_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_o_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(struct S_o_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Advise(JetBrains.Lifetimes.Lifetime, JetBrains.Rider.Model.Unity.BackendUnity.UnityProfilerModel, JetBrains.Rider.Model.Unity.BackendUnity.BackendUnityModel) declare in JetBrains.Rider.Unity.Editor.Profiler.ProfilerWindowEventsHandler
bool w_vS_o_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_o_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(struct S_o_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Write(JetBrains.Rd.SerializationCtx, JetBrains.Serialization.UnsafeWriter, JetBrains.Rd.RdContextBase) declare in JetBrains.Rd.RdContextBase
bool w_vS_oo_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_oo_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_oo_* pp0 = DataTransfer::GetPointer<S_oo_>(apis, env, _sv0);
    S_oo_ p0 = pp0 ? *pp0 : S_oo_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(struct S_oo_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void RegisterContext(UnityEditor.Timeline.Actions.ActionContext, System.String) declare in UnityEditor.Timeline.UndoExtensions
bool w_vS_oooooN_br8__s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_oooooN_br8__s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_oooooN_br8__* pp0 = DataTransfer::GetPointer<S_oooooN_br8__>(apis, env, _sv0);
    S_oooooN_br8__ p0 = pp0 ? *pp0 : S_oooooN_br8__ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_oooooN_br8__ p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Advanced(SimpleLitProperties) declare in UnityEditor.Rendering.Universal.ShaderGUI.SimpleLitGUI
bool w_vS_oooooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vS_oooooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oooooo_* pp0 = DataTransfer::GetPointer<S_oooooo_>(apis, env, _sv0);
    S_oooooo_ p0 = pp0 ? *pp0 : S_oooooo_ {};

    typedef void (*FuncToCall)(struct S_oooooo_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

}

