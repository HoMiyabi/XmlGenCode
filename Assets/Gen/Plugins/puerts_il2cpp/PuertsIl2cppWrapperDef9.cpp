// Auto Gen

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "PuertsValueType.h"
#if defined(__EMSCRIPTEN__)
#include "pesapi_webgl.h"
using namespace pesapi::webglimpl;
#endif

namespace puerts
{


// Void Enter(Boolean ByRef) declare in System.Threading.SpinLock
bool w_vtPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    bool up0 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv0);
    bool* p0 = &up0;

    typedef void (*FuncToCall)(void*,bool* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<bool>::toScript(apis, env, *p0));
    
    return true;
}

// Void Deconstruct(Boolean ByRef, System.String ByRef, Boolean ByRef) declare in JetBrains.Rider.Model.Unity.ProfilingData
bool w_vtPbPsPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPbPsPb");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P primitive
    bool up0 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv0);
    bool* p0 = &up0;
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal P primitive
    bool up2 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv2);
    bool* p2 = &up2;

    typedef void (*FuncToCall)(void*,bool* p0, Il2CppString** p1, bool* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<bool>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<bool>::toScript(apis, env, *p2));
    
    return true;
}

// Void Deconstruct(Boolean ByRef, System.String ByRef, System.String ByRef) declare in JetBrains.Rider.Model.Unity.RunMethodResult
bool w_vtPbPsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPbPsPs");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P primitive
    bool up0 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv0);
    bool* p0 = &up0;
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        

    typedef void (*FuncToCall)(void*,bool* p0, Il2CppString** p1, Il2CppString** p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<bool>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    
    return true;
}

// Void Serialize(Char ByRef) declare in UnityEngine.BitStream
bool w_vtPc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPc");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    Il2CppChar up0 = converter::Converter<std::reference_wrapper<Il2CppChar>>::toCpp(apis, env, _sv0);
    Il2CppChar* p0 = &up0;

    typedef void (*FuncToCall)(void*,Il2CppChar* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppChar>::toScript(apis, env, *p0));
    
    return true;
}

// Void Serialize(Int16 ByRef) declare in UnityEngine.BitStream
bool w_vtPi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    int16_t up0 = converter::Converter<std::reference_wrapper<int16_t>>::toCpp(apis, env, _sv0);
    int16_t* p0 = &up0;

    typedef void (*FuncToCall)(void*,int16_t* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int16_t>::toScript(apis, env, *p0));
    
    return true;
}

// Void Serialize(Int32 ByRef) declare in UnityEngine.BitStream
bool w_vtPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;

    typedef void (*FuncToCall)(void*,int32_t* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    
    return true;
}

// Void GetPEKind(System.Reflection.PortableExecutableKinds ByRef, System.Reflection.ImageFileMachine ByRef) declare in System.Reflection.Module
bool w_vtPi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi4Pi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef void (*FuncToCall)(void*,int32_t* p0, int32_t* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    return true;
}

// Void GetStatus(Int32 ByRef, Int32 ByRef, Int32 ByRef) declare in PlasticPipe.Server.WorkerThreadPool
bool w_vtPi4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi4Pi4Pi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef void (*FuncToCall)(void*,int32_t* p0, int32_t* p1, int32_t* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    return true;
}

// Void Deconstruct(Int32 ByRef, Int32 ByRef, System.String ByRef, Int32 ByRef, JetBrains.Rider.Model.Unity.SnapshotStatus ByRef, Single ByRef) declare in JetBrains.Rider.Model.Unity.UnityProfilerSnapshotStatus
bool w_vtPi4Pi4PsPi4Pi4Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi4Pi4PsPi4Pi4Pr4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;
    // JSValToCSVal P primitive
    int32_t up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;
    // JSValToCSVal P primitive
    float up5 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv5);
    float* p5 = &up5;

    typedef void (*FuncToCall)(void*,int32_t* p0, int32_t* p1, Il2CppString** p2, int32_t* p3, int32_t* p4, float* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    apis->update_boxed_value(env, _sv4, converter::Converter<int32_t>::toScript(apis, env, *p4));
    apis->update_boxed_value(env, _sv5, converter::Converter<float>::toScript(apis, env, *p5));
    
    return true;
}

// Void CalculateCheckedItemSizeAndCount(Int32 ByRef, Int64 ByRef) declare in GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Configuration.ConfigurationTreeModel
bool w_vtPi4Pi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi4Pi8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv1);
    int64_t* p1 = &up1;

    typedef void (*FuncToCall)(void*,int32_t* p0, int64_t* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<int64_t>::toScript(apis, env, *p1));
    
    return true;
}

// Void Deconstruct(Int32 ByRef, Double ByRef, Single ByRef, Int32 ByRef, System.String ByRef, System.Collections.Generic.List`1[JetBrains.Rider.Model.Unity.BackendUnity.MarkerToNamePair] ByRef, System.Collections.Generic.List`1[JetBrains.Rider.Model.Unity.BackendUnity.SampleInfo] ByRef, JetBrains.Rider.Model.Unity.UnityProfilerSnapshotStatus ByRef) declare in JetBrains.Rider.Model.Unity.BackendUnity.UnityProfilerSnapshot
bool w_vtPi4Pr8Pr4Pi4PsPoPoPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi4Pr8Pr4Pi4PsPoPoPo");
    
    auto TIp4 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
        if (!apis->is_boxed_value(env, _sv7)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
    // JSValToCSVal P primitive
    double up1 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv1);
    double* p1 = &up1;
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;
    // JSValToCSVal Ps
    Il2CppString* up4 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv4); // string ref
    Il2CppString** p4 = &up4;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up5 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv5)); // object ref
    Il2CppObject** p5 = &up5;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up6 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv6)); // object ref
    Il2CppObject** p6 = &up6;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up7 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv7)); // object ref
    Il2CppObject** p7 = &up7;
        

    typedef void (*FuncToCall)(void*,int32_t* p0, double* p1, float* p2, int32_t* p3, Il2CppString** p4, Il2CppObject** p5, Il2CppObject** p6, Il2CppObject** p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<double>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<float>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    apis->update_boxed_value(env, _sv4, converter::Converter<Il2CppString*>::toScript(apis, env, *p4));
    apis->update_boxed_value(env, _sv5, CSRefToJsValue(apis, env, TIp5, *p5));
    apis->update_boxed_value(env, _sv6, CSRefToJsValue(apis, env, TIp6, *p6));
    apis->update_boxed_value(env, _sv7, CSRefToJsValue(apis, env, TIp7, *p7));
    
    return true;
}

// Void Deconstruct(Int32 ByRef, System.String ByRef) declare in JetBrains.Rider.Model.Unity.BackendUnity.MarkerToNamePair
bool w_vtPi4Ps(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi4Ps");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        

    typedef void (*FuncToCall)(void*,int32_t* p0, Il2CppString** p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    
    return true;
}

// Void Pack(Int32 ByRef, Int32, Int32, Boolean) declare in TreeEditor.TextureAtlas
bool w_vtPi4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi4i4i4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t* p0, int32_t p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    
    return true;
}

// Void Deconstruct(Int64 ByRef, JetBrains.Rider.Model.Unity.LogEventType ByRef, JetBrains.Rider.Model.Unity.LogEventMode ByRef, System.String ByRef, System.String ByRef) declare in JetBrains.Rider.Model.Unity.LogEvent
bool w_vtPi8Pi4Pi4PsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi8Pi4Pi4PsPs");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv0);
    int64_t* p0 = &up0;
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        
    // JSValToCSVal Ps
    Il2CppString* up4 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv4); // string ref
    Il2CppString** p4 = &up4;
        

    typedef void (*FuncToCall)(void*,int64_t* p0, int32_t* p1, int32_t* p2, Il2CppString** p3, Il2CppString** p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int64_t>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<Il2CppString*>::toScript(apis, env, *p3));
    apis->update_boxed_value(env, _sv4, converter::Converter<Il2CppString*>::toScript(apis, env, *p4));
    
    return true;
}

// Void ConfigureMaskFromClip(UnityEngine.AvatarMask ByRef) declare in UnityEditor.ModelImporterClipAnimation
bool w_vtPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        

    typedef void (*FuncToCall)(void*,Il2CppObject** p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    return true;
}

// Void Deserialize(System.Collections.Generic.Dictionary`2[System.Guid,System.Boolean] ByRef, System.Collections.Generic.Dictionary`2[System.Guid,System.Boolean] ByRef) declare in Codice.Client.BaseCommands.BranchExplorer.Layout.HiddenBranchSerializer
bool w_vtPoPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPoPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef void (*FuncToCall)(void*,Il2CppObject** p0, Il2CppObject** p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    return true;
}

// Void Serialize(Single ByRef) declare in UnityEngine.BitStream
bool w_vtPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPr4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv0);
    float* p0 = &up0;

    typedef void (*FuncToCall)(void*,float* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<float>::toScript(apis, env, *p0));
    
    return true;
}

// Void ToAngleAxis(Single ByRef, UnityEngine.Vector3 ByRef) declare in UnityEngine.Quaternion
bool w_vtPr4PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPr4PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv0);
    float* p0 = &up0;
    // JSValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4_));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,float* p0, struct S_r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<float>::toScript(apis, env, *p0));
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void Serialize(Single ByRef, Single) declare in UnityEngine.BitStream
bool w_vtPr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPr4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv0);
    float* p0 = &up0;
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,float* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<float>::toScript(apis, env, *p0));
    
    return true;
}

// Void Deconstruct(Double ByRef, Int32 ByRef, Int64 ByRef, Int32 ByRef) declare in JetBrains.Rider.Model.Unity.BackendUnity.SampleInfo
bool w_vtPr8Pi4Pi8Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPr8Pi4Pi8Pi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal P primitive
    double up0 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv0);
    double* p0 = &up0;
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv2);
    int64_t* p2 = &up2;
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef void (*FuncToCall)(void*,double* p0, int32_t* p1, int64_t* p2, int32_t* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<double>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int64_t>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    return true;
}

// Void Deconstruct(System.String ByRef, Int32 ByRef, Int32 ByRef) declare in JetBrains.Rider.Model.Unity.BackendUnity.RdOpenFileArgs
bool w_vtPsPi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPsPi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef void (*FuncToCall)(void*,Il2CppString** p0, int32_t* p1, int32_t* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    return true;
}

// Void Deconstruct(System.String ByRef, UnityEngine.Component ByRef) declare in KiraraDirectBinder.KiraraDirectBinderItem
bool w_vtPsPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPsPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef void (*FuncToCall)(void*,Il2CppString** p0, Il2CppObject** p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    return true;
}

// Void Deconstruct(System.String ByRef, System.Collections.Generic.List`1[System.String] ByRef, System.Collections.Generic.List`1[System.String] ByRef) declare in JetBrains.Rider.Model.Unity.BackendUnity.UnityPlatformInfo
bool w_vtPsPoPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPsPoPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef void (*FuncToCall)(void*,Il2CppString** p0, Il2CppObject** p1, Il2CppObject** p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    return true;
}

// Void Deconstruct(System.String ByRef, System.Collections.Generic.List`1[System.String] ByRef, System.Collections.Generic.List`1[System.String] ByRef, System.Collections.Generic.List`1[System.String] ByRef) declare in JetBrains.Rider.Model.Unity.BackendUnity.TestFilter
bool w_vtPsPoPoPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPsPoPoPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv3)); // object ref
    Il2CppObject** p3 = &up3;
        

    typedef void (*FuncToCall)(void*,Il2CppString** p0, Il2CppObject** p1, Il2CppObject** p2, Il2CppObject** p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    apis->update_boxed_value(env, _sv3, CSRefToJsValue(apis, env, TIp3, *p3));
    
    return true;
}

// Void Deconstruct(System.String ByRef, System.Collections.Generic.List`1[System.String] ByRef, System.String ByRef) declare in JetBrains.Rider.Model.Unity.BackendUnity.UnitTestLaunchClientControllerInfo
bool w_vtPsPoPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPsPoPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        

    typedef void (*FuncToCall)(void*,Il2CppString** p0, Il2CppObject** p1, Il2CppString** p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    
    return true;
}

// Void ReadContentAsQualifiedName(System.String ByRef, System.String ByRef) declare in System.Xml.XmlDictionaryReader
bool w_vtPsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPsPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        

    typedef void (*FuncToCall)(void*,Il2CppString** p0, Il2CppString** p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    
    return true;
}

// Void Deconstruct(System.String ByRef, System.String ByRef, System.String ByRef) declare in JetBrains.Rider.Model.Unity.RunMethodData
bool w_vtPsPsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPsPsPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        

    typedef void (*FuncToCall)(void*,Il2CppString** p0, Il2CppString** p1, Il2CppString** p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    
    return true;
}

// Void Deconstruct(System.String ByRef, System.String ByRef, System.String ByRef, Int32 ByRef, JetBrains.Rider.Model.Unity.BackendUnity.Status ByRef, System.String ByRef) declare in JetBrains.Rider.Model.Unity.BackendUnity.TestResult
bool w_vtPsPsPsPi4Pi4Ps(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPsPsPsPi4Pi4Ps");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;
    // JSValToCSVal P primitive
    int32_t up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;
    // JSValToCSVal Ps
    Il2CppString* up5 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv5); // string ref
    Il2CppString** p5 = &up5;
        

    typedef void (*FuncToCall)(void*,Il2CppString** p0, Il2CppString** p1, Il2CppString** p2, int32_t* p3, int32_t* p4, Il2CppString** p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    apis->update_boxed_value(env, _sv4, converter::Converter<int32_t>::toScript(apis, env, *p4));
    apis->update_boxed_value(env, _sv5, converter::Converter<Il2CppString*>::toScript(apis, env, *p5));
    
    return true;
}

// Void Deconstruct(System.String ByRef, System.String ByRef, System.String ByRef, System.String ByRef, System.String ByRef, System.Nullable`1[System.Int32] ByRef) declare in JetBrains.Rider.Model.Unity.UnityApplicationData
bool w_vtPsPsPsPsPsPN_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPsPsPsPsPsPN_bi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    // JSValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        
    // JSValToCSVal Ps
    Il2CppString* up4 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv4); // string ref
    Il2CppString** p4 = &up4;
        
    // JSValToCSVal Pstruct
    N_bi4_* p5 = DataTransfer::GetPointer<N_bi4_>(apis, env, apis->unboxing(env, _sv5)); // valuetype ref
    N_bi4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(N_bi4_));
        p5 = &up5;
    }
        

    typedef void (*FuncToCall)(void*,Il2CppString** p0, Il2CppString** p1, Il2CppString** p2, Il2CppString** p3, Il2CppString** p4, struct N_bi4_* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<Il2CppString*>::toScript(apis, env, *p3));
    apis->update_boxed_value(env, _sv4, converter::Converter<Il2CppString*>::toScript(apis, env, *p4));
    if (p5 == &up5)
    {
        if (!p5->hasValue) apis->update_boxed_value(env, _sv5, apis->create_null(env));
        if (p5 == &up5) apis->update_boxed_value(env, _sv5, DataTransfer::CopyNullableValueType(apis, env, *p5, TIp5));
    }
    
    return true;
}

// Void InitForConfiguration(System.String ByRef, System.String ByRef, System.String ByRef, System.Configuration.Internal.IInternalConfigRoot, System.Object[]) declare in System.Configuration.Internal.DelegatingConfigHost
bool w_vtPsPsPsoVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPsPsPsoVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,Il2CppString** p0, Il2CppString** p1, Il2CppString** p2, Il2CppObject* p3, Il2CppArray* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    
    return true;
}

// Void FreeNativeOverlapped(System.Threading.NativeOverlapped*) declare in System.Threading.ThreadPoolBoundHandle
bool w_vtPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPv");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Void*, System.Runtime.InteropServices.GCHandle, System.Buffers.IPinnable) declare in System.Buffers.MemoryHandle
bool w_vtPvDS_p_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPvDS_p_Do");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    S_p_ p1 = OptionalParameter<S_p_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef void (*FuncToCall)(void*,void* p0, struct S_p_ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetExceptions(Byte*, Int32) declare in System.Reflection.Emit.DynamicILInfo
bool w_vtPvi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPvi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Convert(Byte*, Int32, Char*, Int32, Boolean, Int32 ByRef, Int32 ByRef, Boolean ByRef) declare in System.Text.Decoder
bool w_vtPvi4Pvi4bPi4Pi4Pb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPvi4Pvi4bPi4Pi4Pb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
        if (!apis->is_boxed_value(env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P primitive
    int32_t up5 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv5);
    int32_t* p5 = &up5;
    // JSValToCSVal P primitive
    int32_t up6 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv6);
    int32_t* p6 = &up6;
    // JSValToCSVal P primitive
    bool up7 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv7);
    bool* p7 = &up7;

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, int32_t p3, bool p4, int32_t* p5, int32_t* p6, bool* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    apis->update_boxed_value(env, _sv5, converter::Converter<int32_t>::toScript(apis, env, *p5));
    apis->update_boxed_value(env, _sv6, converter::Converter<int32_t>::toScript(apis, env, *p6));
    apis->update_boxed_value(env, _sv7, converter::Converter<bool>::toScript(apis, env, *p7));
    
    return true;
}

// Void SetCode(Byte*, Int32, Int32) declare in System.Reflection.Emit.DynamicILInfo
bool w_vtPvi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPvi4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(SByte*, Int32, Int32, System.Text.Encoding) declare in System.String
bool w_vtPvi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPvi4i4o");
    
    auto TIp3 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Byte*, Int64) declare in System.IO.UnmanagedMemoryStream
bool w_vtPvi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPvi8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,void* p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Byte*, Int64, Int64, System.IO.FileAccess) declare in System.IO.UnmanagedMemoryStream
bool w_vtPvi8i8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPvi8i8i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,void* p0, int64_t p1, int64_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Append(Void*, UInt64) declare in UnityEngine.Hash128
bool w_vtPvu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtPvu8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,void* p0, uint64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Buffers.ReadOnlySequence`1[System.Byte], System.Text.Json.JsonReaderOptions) declare in System.Text.Json.Utf8JsonReader
bool w_vtS_OOi4i4_DS_i4u1bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_OOi4i4_DS_i4u1bb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_OOi4i4_* pp0 = DataTransfer::GetPointer<S_OOi4i4_>(apis, env, _sv0);
    S_OOi4i4_ p0 = pp0 ? *pp0 : S_OOi4i4_ {};
    // JSValToCSVal valuetype  with default
    S_i4u1bb_ p1 = OptionalParameter<S_i4u1bb_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,struct S_OOi4i4_ p0, struct S_i4u1bb_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteRawValue(System.Buffers.ReadOnlySequence`1[System.Byte], Boolean) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_OOi4i4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_OOi4i4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_OOi4i4_* pp0 = DataTransfer::GetPointer<S_OOi4i4_>(apis, env, _sv0);
    S_OOi4i4_ p0 = pp0 ? *pp0 : S_OOi4i4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,struct S_OOi4i4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Buffers.ReadOnlySequence`1[System.Byte], Boolean, System.Text.Json.JsonReaderState) declare in System.Text.Json.Utf8JsonReader
bool w_vtS_OOi4i4_bS_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_OOi4i4_bS_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_OOi4i4_* pp0 = DataTransfer::GetPointer<S_OOi4i4_>(apis, env, _sv0);
    S_OOi4i4_ p0 = pp0 ? *pp0 : S_OOi4i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__* pp2 = DataTransfer::GetPointer<S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__>(apis, env, _sv2);
    S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__ p2 = pp2 ? *pp2 : S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__ {};

    typedef void (*FuncToCall)(void*,struct S_OOi4i4_ p0, bool p1, struct S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.Buffers.ReadOnlySequence`1[System.Byte], Boolean, Boolean) declare in System.IO.Pipelines.ReadResult
bool w_vtS_OOi4i4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_OOi4i4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_OOi4i4_* pp0 = DataTransfer::GetPointer<S_OOi4i4_>(apis, env, _sv0);
    S_OOi4i4_ p0 = pp0 ? *pp0 : S_OOi4i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_OOi4i4_ p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_Context(System.Runtime.Serialization.StreamingContext) declare in System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
bool w_vtS_Oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4_* pp0 = DataTransfer::GetPointer<S_Oi4_>(apis, env, _sv0);
    S_Oi4_ p0 = pp0 ? *pp0 : S_Oi4_ {};

    typedef void (*FuncToCall)(void*,struct S_Oi4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(System.Runtime.Serialization.StreamingContext, Int32, Boolean, System.Runtime.Serialization.Formatters.FormatterAssemblyStyle, System.Runtime.Serialization.ISurrogateSelector) declare in System.Runtime.Serialization.NetDataContractSerializer
bool w_vtS_Oi4_i4bi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Oi4_i4bi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4_* pp0 = DataTransfer::GetPointer<S_Oi4_>(apis, env, _sv0);
    S_Oi4_ p0 = pp0 ? *pp0 : S_Oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_Oi4_ p0, int32_t p1, bool p2, int32_t p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetBuffer(System.Memory`1[System.Byte]) declare in System.Net.Sockets.SocketAsyncEventArgs
bool w_vtS_Oi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Oi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_Oi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(System.ReadOnlyMemory`1[System.Byte], System.String) declare in Microsoft.Extensions.AI.DataContent
bool w_vtS_Oi4i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Oi4i4_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_Oi4i4_ p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(ReadOnly) declare in UnityEngine.Networking.UploadHandlerRaw
bool w_vtS_Pvi4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4S_pi4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4S_pi4i4__* pp0 = DataTransfer::GetPointer<S_Pvi4S_pi4i4__>(apis, env, _sv0);
    S_Pvi4S_pi4i4__ p0 = pp0 ? *pp0 : S_Pvi4S_pi4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_Pvi4S_pi4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void GetInternalAvatarPose(Unity.Collections.NativeArray`1[System.Single]) declare in UnityEngine.HumanPoseHandler
bool w_vtS_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void BeginSubPass(Unity.Collections.NativeArray`1[System.Int32], Boolean) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_vtS_Pvi4i4i4S_pi4i4_i4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetBoneWeights(Unity.Collections.NativeArray`1[System.Byte], Unity.Collections.NativeArray`1[UnityEngine.BoneWeight1]) declare in UnityEngine.Mesh
bool w_vtS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void BeginSubPass(Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[System.Int32], Boolean) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_vtS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void CalculateInterpolatedLightAndOcclusionProbes(Unity.Collections.NativeArray`1[UnityEngine.Vector3], Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[UnityEngine.Rendering.SphericalHarmonicsL2], Unity.Collections.NativeArray`1[UnityEngine.Vector4]) declare in UnityEngine.LightProbesQuery
bool w_vtS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv3);
    S_Pvi4i4i4S_pi4i4_i4_ p3 = pp3 ? *pp3 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void BeginSubPass(Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[System.Int32], Boolean, Boolean) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_vtS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetCustomShape(Unity.Collections.NativeArray`1[UnityEngine.PhysicsShape2D], Unity.Collections.NativeArray`1[UnityEngine.Vector2], Int32, Int32) declare in UnityEngine.CustomCollider2D
bool w_vtS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Unity.Collections.NativeArray`1[System.Byte], Boolean) declare in UnityEngine.Networking.UploadHandlerRaw
bool w_vtS_Pvi4i4i4S_pi4i4_i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void BeginSubPass(Unity.Collections.NativeArray`1[System.Int32], Boolean, Boolean) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_vtS_Pvi4i4i4S_pi4i4_i4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32) declare in UnityEngine.ParticleSystem
bool w_vtS_Pvi4i4i4S_pi4i4_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32, Int32) declare in UnityEngine.ParticleSystem
bool w_vtS_Pvi4i4i4S_pi4i4_i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPositions(Unity.Collections.NativeSlice`1[UnityEngine.Vector3]) declare in UnityEngine.TrailRenderer
bool w_vtS_Pvi4i4i4i4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4i4S_pi4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4i4S_pi4i4__* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, _sv0);
    S_Pvi4i4i4i4S_pi4i4__ p0 = pp0 ? *pp0 : S_Pvi4i4i4i4S_pi4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4i4S_pi4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void MoveLocationsInSameAreas(Unity.Collections.NativeSlice`1[UnityEngine.Experimental.AI.NavMeshLocation], Unity.Collections.NativeSlice`1[UnityEngine.Vector3], Int32) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_vtS_Pvi4i4i4i4S_pi4i4__S_Pvi4i4i4i4S_pi4i4__Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4i4S_pi4i4__S_Pvi4i4i4i4S_pi4i4__Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4i4S_pi4i4__* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, _sv0);
    S_Pvi4i4i4i4S_pi4i4__ p0 = pp0 ? *pp0 : S_Pvi4i4i4i4S_pi4i4__ {};
    // JSValToCSVal struct
    S_Pvi4i4i4i4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, _sv1);
    S_Pvi4i4i4i4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pvi4i4i4i4S_pi4i4__ {};
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4i4S_pi4i4__ p0, struct S_Pvi4i4i4i4S_pi4i4__ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void MoveLocations(Unity.Collections.NativeSlice`1[UnityEngine.Experimental.AI.NavMeshLocation], Unity.Collections.NativeSlice`1[UnityEngine.Vector3], Unity.Collections.NativeSlice`1[System.Int32]) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_vtS_Pvi4i4i4i4S_pi4i4__S_Pvi4i4i4i4S_pi4i4__S_Pvi4i4i4i4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4i4S_pi4i4__S_Pvi4i4i4i4S_pi4i4__S_Pvi4i4i4i4S_pi4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4i4S_pi4i4__* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, _sv0);
    S_Pvi4i4i4i4S_pi4i4__ p0 = pp0 ? *pp0 : S_Pvi4i4i4i4S_pi4i4__ {};
    // JSValToCSVal struct
    S_Pvi4i4i4i4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, _sv1);
    S_Pvi4i4i4i4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pvi4i4i4i4S_pi4i4__ {};
    // JSValToCSVal struct
    S_Pvi4i4i4i4S_pi4i4__* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, _sv2);
    S_Pvi4i4i4i4S_pi4i4__ p2 = pp2 ? *pp2 : S_Pvi4i4i4i4S_pi4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4i4S_pi4i4__ p0, struct S_Pvi4i4i4i4S_pi4i4__ p1, struct S_Pvi4i4i4i4S_pi4i4__ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Emit(EmitParams, Int32) declare in UnityEngine.ParticleSystem
bool w_vtS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_bbbbbbbbbbb_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_bbbbbbbbbbb_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_bbbbbbbbbbb_* pp0 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_bbbbbbbbbbb_>(apis, env, _sv0);
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_bbbbbbbbbbb_ p0 = pp0 ? *pp0 : S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_bbbbbbbbbbb_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_bbbbbbbbbbb_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.RigidTransform) declare in Unity.Mathematics.float4x4
bool w_vtS_S_S_r4r4r4r4__S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_S_r4r4r4r4__S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4r4r4r4__S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_S_r4r4r4r4__S_r4r4r4__>(apis, env, _sv0);
    S_S_S_r4r4r4r4__S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_S_r4r4r4r4__S_r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_S_r4r4r4r4__S_r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool2x4) declare in Unity.Mathematics.double2x4
bool w_vtS_S_bb_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_bb_S_bb_S_bb_S_bb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb_S_bb__ {};

    typedef void (*FuncToCall)(void*,struct S_S_bb_S_bb_S_bb_S_bb__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool2x3) declare in Unity.Mathematics.double2x3
bool w_vtS_S_bb_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_bb_S_bb_S_bb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb_S_bb__ {};

    typedef void (*FuncToCall)(void*,struct S_S_bb_S_bb_S_bb__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool2x2) declare in Unity.Mathematics.double2x2
bool w_vtS_S_bb_S_bb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_bb_S_bb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bb_S_bb__* pp0 = DataTransfer::GetPointer<S_S_bb_S_bb__>(apis, env, _sv0);
    S_S_bb_S_bb__ p0 = pp0 ? *pp0 : S_S_bb_S_bb__ {};

    typedef void (*FuncToCall)(void*,struct S_S_bb_S_bb__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool3x4) declare in Unity.Mathematics.double3x4
bool w_vtS_S_bbb_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_bbb_S_bbb_S_bbb_S_bbb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb_S_bbb__ {};

    typedef void (*FuncToCall)(void*,struct S_S_bbb_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool3x3) declare in Unity.Mathematics.double3x3
bool w_vtS_S_bbb_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_bbb_S_bbb_S_bbb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb_S_bbb__ {};

    typedef void (*FuncToCall)(void*,struct S_S_bbb_S_bbb_S_bbb__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool3x2) declare in Unity.Mathematics.double3x2
bool w_vtS_S_bbb_S_bbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_bbb_S_bbb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbb_S_bbb__* pp0 = DataTransfer::GetPointer<S_S_bbb_S_bbb__>(apis, env, _sv0);
    S_S_bbb_S_bbb__ p0 = pp0 ? *pp0 : S_S_bbb_S_bbb__ {};

    typedef void (*FuncToCall)(void*,struct S_S_bbb_S_bbb__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool4x4) declare in Unity.Mathematics.double4x4
bool w_vtS_S_bbbb_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_bbbb_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef void (*FuncToCall)(void*,struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool4x3) declare in Unity.Mathematics.double4x3
bool w_vtS_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef void (*FuncToCall)(void*,struct S_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool4x2) declare in Unity.Mathematics.double4x2
bool w_vtS_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_bbbb_S_bbbb__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb__ {};

    typedef void (*FuncToCall)(void*,struct S_S_bbbb_S_bbbb__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int2x4) declare in Unity.Mathematics.double2x4
bool w_vtS_S_i4i4_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4i4_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_i4i4_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int2x3) declare in Unity.Mathematics.double2x3
bool w_vtS_S_i4i4_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4i4_S_i4i4_S_i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4_S_i4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_i4i4_S_i4i4_S_i4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int2x2) declare in Unity.Mathematics.double2x2
bool w_vtS_S_i4i4_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4i4_S_i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_S_i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4_S_i4i4__>(apis, env, _sv0);
    S_S_i4i4_S_i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4_S_i4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_i4i4_S_i4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int3x4) declare in Unity.Mathematics.double3x4
bool w_vtS_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int3x3) declare in Unity.Mathematics.double3x3
bool w_vtS_S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void ClampToBounds(UnityEngine.BoundsInt) declare in UnityEngine.BoundsInt
bool w_vtS_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4i4i4_S_i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_i4i4i4_S_i4i4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetTilesBlock(UnityEngine.BoundsInt, UnityEngine.Tilemaps.TileBase[]) declare in UnityEngine.Tilemaps.Tilemap
bool w_vtS_S_i4i4i4_S_i4i4i4__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4i4i4_S_i4i4i4__o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_i4i4i4_S_i4i4i4__ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetTile(UnityEngine.Tilemaps.TileChangeData, Boolean) declare in UnityEngine.Tilemaps.Tilemap
bool w_vtS_S_i4i4i4_oS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4i4i4_oS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_oS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_oS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>(apis, env, _sv0);
    S_S_i4i4i4_oS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_oS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_i4i4i4_oS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int4x4) declare in Unity.Mathematics.double4x4
bool w_vtS_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int4x3) declare in Unity.Mathematics.double4x3
bool w_vtS_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int4x2) declare in Unity.Mathematics.double4x2
bool w_vtS_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void InitBase(UnityEngine.Experimental.Rendering.XRPassCreateInfo) declare in UnityEngine.Experimental.Rendering.XRPass
bool w_vtS_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__>(apis, env, _sv0);
    S_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__ p0 = pp0 ? *pp0 : S_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__ {};

    typedef void (*FuncToCall)(void*,struct S_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_Path(Unity.Properties.PropertyPath) declare in Unity.Properties.PathVisitor
bool w_vtS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* pp0 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(apis, env, _sv0);
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ p0 = pp0 ? *pp0 : S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void ImportParameters(System.Security.Cryptography.ECParameters) declare in System.Security.Cryptography.ECDiffieHellman
bool w_vtS_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__* pp0 = DataTransfer::GetPointer<S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__>(apis, env, _sv0);
    S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ p0 = pp0 ? *pp0 : S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ {};

    typedef void (*FuncToCall)(void*,struct S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void NextBytes(System.Span`1[System.Byte]) declare in System.Random
bool w_vtS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(System.ReadOnlySpan`1[System.Byte], System.Text.Json.JsonReaderOptions) declare in System.Text.Json.Utf8JsonReader
bool w_vtS_S_p_i4_DS_i4u1bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_DS_i4u1bb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal valuetype  with default
    S_i4u1bb_ p1 = OptionalParameter<S_i4u1bb_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_i4u1bb_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteRawValue(System.ReadOnlySpan`1[System.Char], Boolean) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.ReadOnlySpan`1[System.Byte], Boolean, Boolean) declare in System.Numerics.BigInteger
bool w_vtS_S_p_i4_DbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_DbDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ImportPkcs8PrivateKey(System.ReadOnlySpan`1[System.Byte], Int32 ByRef) declare in System.Security.Cryptography.AsymmetricAlgorithm
bool w_vtS_S_p_i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, int32_t* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    return true;
}

// Void TransformDirections(System.ReadOnlySpan`1[UnityEngine.Vector3], System.Span`1[UnityEngine.Vector3]) declare in UnityEngine.Transform
bool w_vtS_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_S_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan`1[System.Byte], System.ReadOnlySpan`1[System.Byte], Int32 ByRef) declare in System.Security.Cryptography.AsymmetricAlgorithm
bool w_vtS_S_p_i4_S_S_p_i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_S_S_p_i4_Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, int32_t* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    return true;
}

// Void Decrypt(System.ReadOnlySpan`1[System.Byte], System.ReadOnlySpan`1[System.Byte], System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Byte], System.ReadOnlySpan`1[System.Byte]) declare in System.Security.Cryptography.AesCcm
bool w_vtS_S_p_i4_S_S_p_i4_S_S_p_i4_S_S_p_i4_DS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_S_S_p_i4_S_S_p_i4_S_S_p_i4_DS_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
    // JSValToCSVal valuetype  with default
    S_S_p_i4_ p4 = OptionalParameter<S_S_p_i4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_S_p_i4_ p3, struct S_S_p_i4_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Convert(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Char], Boolean, Int32 ByRef, Int32 ByRef, Boolean ByRef) declare in System.Text.Decoder
bool w_vtS_S_p_i4_S_S_p_i4_bPi4Pi4Pb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_S_S_p_i4_bPi4Pi4Pb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;
    // JSValToCSVal P primitive
    int32_t up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;
    // JSValToCSVal P primitive
    bool up5 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv5);
    bool* p5 = &up5;

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, bool p2, int32_t* p3, int32_t* p4, bool* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    apis->update_boxed_value(env, _sv4, converter::Converter<int32_t>::toScript(apis, env, *p4));
    apis->update_boxed_value(env, _sv5, converter::Converter<bool>::toScript(apis, env, *p5));
    
    return true;
}

// Void WriteString(System.ReadOnlySpan`1[System.Char], System.DateTimeOffset) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_S_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_S_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_S_u8_i2_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteString(System.ReadOnlySpan`1[System.Char], System.Guid) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_S_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.ReadOnlySpan`1[System.Char], System.Decimal) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_S_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_i4i4i4i4u8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteString(System.ReadOnlySpan`1[System.Char], System.Text.Json.JsonEncodedText) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_S_os_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_S_os_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_os_* pp1 = DataTransfer::GetPointer<S_os_>(apis, env, _sv1);
    S_os_ p1 = pp1 ? *pp1 : S_os_ {};

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_os_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteString(System.ReadOnlySpan`1[System.Char], System.DateTime) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_S_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_u8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteBoolean(System.ReadOnlySpan`1[System.Char], Boolean) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.ReadOnlySpan`1[System.Byte], Boolean, System.Text.Json.JsonReaderState) declare in System.Text.Json.Utf8JsonReader
bool w_vtS_S_p_i4_bS_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_bS_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__* pp2 = DataTransfer::GetPointer<S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__>(apis, env, _sv2);
    S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__ p2 = pp2 ? *pp2 : S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, bool p1, struct S_i8i8bbbbu1u1S_i4u1bb_S_ou8i4__ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void WriteNumber(System.ReadOnlySpan`1[System.Char], Int32) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.ReadOnlySpan`1[System.Char], Int64) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.ReadOnlySpan`1[System.Char], Single) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.ReadOnlySpan`1[System.Char], Double) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, double p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteString(System.ReadOnlySpan`1[System.Char], System.String) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.ReadOnlySpan`1[System.Char], UInt32) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_u4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.ReadOnlySpan`1[System.Char], UInt64) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_S_p_i4_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_u8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p0, uint64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetValueDirect(TypedReference, System.Object) declare in System.Reflection.FieldInfo
bool w_vtS_S_p_pp_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_pp_O");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_pp_* pp0 = DataTransfer::GetPointer<S_S_p_pp_>(apis, env, _sv0);
    S_S_p_pp_ p0 = pp0 ? *pp0 : S_S_p_pp_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_p_pp_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void OnGraphStart(UnityEngine.Playables.Playable) declare in UnityEngine.Playables.PlayableBehaviour
bool w_vtS_S_pu4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_pu4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_pu4__* pp0 = DataTransfer::GetPointer<S_S_pu4__>(apis, env, _sv0);
    S_S_pu4__ p0 = pp0 ? *pp0 : S_S_pu4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_pu4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void OnBehaviourDelay(UnityEngine.Playables.Playable, UnityEngine.Playables.FrameData) declare in UnityEngine.Playables.PlayableBehaviour
bool w_vtS_S_pu4__S_u8r8r4r4r8r4r4i4S_S_pu4___(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_pu4__S_u8r8r4r4r8r4r4i4S_S_pu4___");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_pu4__* pp0 = DataTransfer::GetPointer<S_S_pu4__>(apis, env, _sv0);
    S_S_pu4__ p0 = pp0 ? *pp0 : S_S_pu4__ {};
    // JSValToCSVal struct
    S_u8r8r4r4r8r4r4i4S_S_pu4___* pp1 = DataTransfer::GetPointer<S_u8r8r4r4r8r4r4i4S_S_pu4___>(apis, env, _sv1);
    S_u8r8r4r4r8r4r4i4S_S_pu4___ p1 = pp1 ? *pp1 : S_u8r8r4r4r8r4r4i4S_S_pu4___ {};

    typedef void (*FuncToCall)(void*,struct S_S_pu4__ p0, struct S_u8r8r4r4r8r4r4i4S_S_pu4___ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ProcessFrame(UnityEngine.Playables.Playable, UnityEngine.Playables.FrameData, System.Object) declare in UnityEngine.Playables.PlayableBehaviour
bool w_vtS_S_pu4__S_u8r8r4r4r8r4r4i4S_S_pu4___O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_pu4__S_u8r8r4r4r8r4r4i4S_S_pu4___O");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_pu4__* pp0 = DataTransfer::GetPointer<S_S_pu4__>(apis, env, _sv0);
    S_S_pu4__ p0 = pp0 ? *pp0 : S_S_pu4__ {};
    // JSValToCSVal struct
    S_u8r8r4r4r8r4r4i4S_S_pu4___* pp1 = DataTransfer::GetPointer<S_u8r8r4r4r8r4r4i4S_S_pu4___>(apis, env, _sv1);
    S_u8r8r4r4r8r4r4i4S_S_pu4___ p1 = pp1 ? *pp1 : S_u8r8r4r4r8r4r4i4S_S_pu4___ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_S_pu4__ p0, struct S_u8r8r4r4r8r4r4i4S_S_pu4___ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void OnNotify(UnityEngine.Playables.Playable, UnityEngine.Playables.INotification, System.Object) declare in UnityEngine.Timeline.SignalReceiver
bool w_vtS_S_pu4__oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_pu4__oO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_pu4__* pp0 = DataTransfer::GetPointer<S_S_pu4__>(apis, env, _sv0);
    S_S_pu4__ p0 = pp0 ? *pp0 : S_S_pu4__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_S_pu4__ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_jointPosition(UnityEngine.ArticulationReducedSpace) declare in UnityEngine.ArticulationBody
bool w_vtS_S_r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4_i4_* pp0 = DataTransfer::GetPointer<S_S_r4_i4_>(apis, env, _sv0);
    S_S_r4_i4_ p0 = pp0 ? *pp0 : S_S_r4_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_value(UnityEngine.UIElements.TransformOrigin) declare in UnityEngine.UIElements.StyleTransformOrigin
bool w_vtS_S_r4i4_S_r4i4_r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4i4_S_r4i4_r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4i4_S_r4i4_r4_* pp0 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4_>(apis, env, _sv0);
    S_S_r4i4_S_r4i4_r4_ p0 = pp0 ? *pp0 : S_S_r4i4_S_r4i4_r4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4i4_S_r4i4_r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_value(UnityEngine.UIElements.Translate) declare in UnityEngine.UIElements.StyleTranslate
bool w_vtS_S_r4i4_S_r4i4_r4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4i4_S_r4i4_r4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4i4_S_r4i4_r4b_* pp0 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4b_>(apis, env, _sv0);
    S_S_r4i4_S_r4i4_r4b_ p0 = pp0 ? *pp0 : S_S_r4i4_S_r4i4_r4b_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4i4_S_r4i4_r4b_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_value(UnityEngine.UIElements.Rotate) declare in UnityEngine.UIElements.StyleRotate
bool w_vtS_S_r4i4_S_r4r4r4_b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4i4_S_r4r4r4_b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4i4_S_r4r4r4_b_* pp0 = DataTransfer::GetPointer<S_S_r4i4_S_r4r4r4_b_>(apis, env, _sv0);
    S_S_r4i4_S_r4r4r4_b_ p0 = pp0 ? *pp0 : S_S_r4i4_S_r4r4r4_b_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4i4_S_r4r4r4_b_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.float2x4) declare in Unity.Mathematics.double2x4
bool w_vtS_S_r4r4_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.float2x3) declare in Unity.Mathematics.double2x3
bool w_vtS_S_r4r4_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4_S_r4r4_S_r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4_S_r4r4_S_r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.float2x2) declare in Unity.Mathematics.double2x2
bool w_vtS_S_r4r4_S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4_S_r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4_S_r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_value(UnityEngine.UIElements.TextShadow) declare in UnityEngine.UIElements.StyleTextShadow
bool w_vtS_S_r4r4_r4S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4_r4S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_r4S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_r4S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4_r4S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_r4S_r4r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4_r4S_r4r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetNextVertex(UnityEngine.UIElements.Vertex) declare in UnityEngine.UIElements.MeshWriteData
bool w_vtS_S_r4r4r4_S_i4u1u1u1u1_S_r4r4_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_r4r4r4r4_r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_S_i4u1u1u1u1_S_r4r4_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_r4r4r4r4_r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_i4u1u1u1u1_S_r4r4_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_r4r4r4r4_r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_i4u1u1u1u1_S_r4r4_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_r4r4r4r4_r4_>(apis, env, _sv0);
    S_S_r4r4r4_S_i4u1u1u1u1_S_r4r4_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_r4r4r4r4_r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_i4u1u1u1u1_S_r4r4_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_r4r4r4r4_r4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_i4u1u1u1u1_S_r4r4_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_S_r4r4r4r4_r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Emit(Particle) declare in UnityEngine.ParticleSystem
bool w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.float3x4) declare in Unity.Mathematics.double3x4
bool w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.float3x3) declare in Unity.Mathematics.double3x3
bool w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.float3x3, Unity.Mathematics.float3) declare in Unity.Mathematics.float4x4
bool w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddVert(UnityEngine.UIVertex) declare in UnityEngine.UI.VertexHelper
bool w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetUIVertex(UnityEngine.UIVertex, Int32) declare in UnityEngine.UI.VertexHelper
bool w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_localBounds(UnityEngine.Bounds) declare in UnityEngine.Animation
bool w_vtS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_value(UnityEngine.UIElements.Scale) declare in UnityEngine.UIElements.StyleScale
bool w_vtS_S_r4r4r4_b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_b_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_b_>(apis, env, _sv0);
    S_S_r4r4r4_b_ p0 = pp0 ? *pp0 : S_S_r4r4r4_b_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_b_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void AddTreeInstance(UnityEngine.TreeInstance) declare in UnityEngine.Terrain
bool w_vtS_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_>(apis, env, _sv0);
    S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_cameraProperties(UnityEngine.Rendering.CameraProperties) declare in UnityEngine.Rendering.ScriptableCullingParameters
bool w_vtS_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_colors(UnityEngine.UI.ColorBlock) declare in UnityEngine.UI.Selectable
bool w_vtS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_colorGradient(TMPro.VertexGradient) declare in TMPro.TMP_Text
bool w_vtS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.float4x3) declare in Unity.Mathematics.double4x3
bool w_vtS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.float4x2) declare in Unity.Mathematics.double4x2
bool w_vtS_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.quaternion) declare in Unity.Mathematics.float3x3
bool w_vtS_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.quaternion, Unity.Mathematics.float3) declare in Unity.Mathematics.float4x4
bool w_vtS_S_r4r4r4r4__S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4r4__S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4r4__ p0, struct S_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Settings) declare in UnityEditor.Rendering.InspectorCurveEditor
bool w_vtS_S_r4r4r4r4_oS_r4r4r4r4_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4r4_oS_r4r4r4r4_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_oS_r4r4r4r4_r4r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_oS_r4r4r4r4_r4r4_>(apis, env, _sv0);
    S_S_r4r4r4r4_oS_r4r4r4r4_r4r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_oS_r4r4r4r4_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4r4_oS_r4r4r4r4_r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_sortingSettings(UnityEngine.Rendering.SortingSettings) declare in UnityEngine.Rendering.DrawingSettings
bool w_vtS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_>(apis, env, _sv0);
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p0 = pp0 ? *pp0 : S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double2x4) declare in Unity.Mathematics.float2x4
bool w_vtS_S_r8r8_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r8r8_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r8r8_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double2x3) declare in Unity.Mathematics.float2x3
bool w_vtS_S_r8r8_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r8r8_S_r8r8_S_r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8_S_r8r8__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r8r8_S_r8r8_S_r8r8__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double2x2) declare in Unity.Mathematics.float2x2
bool w_vtS_S_r8r8_S_r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r8r8_S_r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8_S_r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8_S_r8r8__>(apis, env, _sv0);
    S_S_r8r8_S_r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8_S_r8r8__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r8r8_S_r8r8__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double3x4) declare in Unity.Mathematics.float3x4
bool w_vtS_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double3x3) declare in Unity.Mathematics.float3x3
bool w_vtS_S_r8r8r8_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r8r8r8_S_r8r8r8_S_r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r8r8r8_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double3x2) declare in Unity.Mathematics.float3x2
bool w_vtS_S_r8r8r8_S_r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r8r8r8_S_r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8_S_r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8_S_r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8_S_r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8_S_r8r8r8__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r8r8r8_S_r8r8r8__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double4x4) declare in Unity.Mathematics.float4x4
bool w_vtS_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double4x3) declare in Unity.Mathematics.float4x3
bool w_vtS_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double4x2) declare in Unity.Mathematics.float4x2
bool w_vtS_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef void (*FuncToCall)(void*,struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(System.Diagnostics.ActivityContext, System.Diagnostics.ActivityTagsCollection) declare in System.Diagnostics.ActivityLink
bool w_vtS_S_s_S_s_i4sb_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_s_S_s_i4sb_Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_s_S_s_i4sb_* pp0 = DataTransfer::GetPointer<S_S_s_S_s_i4sb_>(apis, env, _sv0);
    S_S_s_S_s_i4sb_ p0 = pp0 ? *pp0 : S_S_s_S_s_i4sb_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef void (*FuncToCall)(void*,struct S_S_s_S_s_i4sb_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_blendState(UnityEngine.Rendering.BlendState) declare in UnityEngine.Rendering.RenderStateBlock
bool w_vtS_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_* pp0 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_>(apis, env, _sv0);
    S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ p0 = pp0 ? *pp0 : S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ {};

    typedef void (*FuncToCall)(void*,struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_xyzw(Unity.Mathematics.half4) declare in Unity.Mathematics.half4
bool w_vtS_S_u2_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u2_S_u2_S_u2_S_u2__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2_S_u2__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u2_S_u2_S_u2_S_u2__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_xyz(Unity.Mathematics.half3) declare in Unity.Mathematics.half3
bool w_vtS_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u2_S_u2_S_u2__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u2_S_u2_S_u2__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.half3, Unity.Mathematics.half) declare in Unity.Mathematics.half4
bool w_vtS_S_u2_S_u2_S_u2__S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u2_S_u2_S_u2__S_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};

    typedef void (*FuncToCall)(void*,struct S_S_u2_S_u2_S_u2__ p0, struct S_u2_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_xy(Unity.Mathematics.half2) declare in Unity.Mathematics.half2
bool w_vtS_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u2_S_u2__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u2_S_u2__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.half2, Unity.Mathematics.half2) declare in Unity.Mathematics.half4
bool w_vtS_S_u2_S_u2__S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u2_S_u2__S_S_u2_S_u2__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u2_S_u2__ p0, struct S_S_u2_S_u2__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.half2, Unity.Mathematics.half) declare in Unity.Mathematics.half3
bool w_vtS_S_u2_S_u2__S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u2_S_u2__S_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};

    typedef void (*FuncToCall)(void*,struct S_S_u2_S_u2__ p0, struct S_u2_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.half2, Unity.Mathematics.half, Unity.Mathematics.half) declare in Unity.Mathematics.half4
bool w_vtS_S_u2_S_u2__S_u2_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u2_S_u2__S_u2_S_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp2 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv2);
    S_u2_ p2 = pp2 ? *pp2 : S_u2_ {};

    typedef void (*FuncToCall)(void*,struct S_S_u2_S_u2__ p0, struct S_u2_ p1, struct S_u2_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ReleaseSharedTexture(UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_vtS_S_u4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4i4__* pp0 = DataTransfer::GetPointer<S_S_u4i4__>(apis, env, _sv0);
    S_S_u4i4__ p0 = pp0 ? *pp0 : S_S_u4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void RefreshSharedTextureDesc(UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle, UnityEngine.Experimental.Rendering.RenderGraphModule.TextureDesc ByRef) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph
bool w_vtS_S_u4i4__PS_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4i4__PS_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4i4__* pp0 = DataTransfer::GetPointer<S_S_u4i4__>(apis, env, _sv0);
    S_S_u4i4__ p0 = pp0 ? *pp0 : S_S_u4i4__ {};
    // JSValToCSVal Pstruct
    S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__* p1 = DataTransfer::GetPointer<S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,struct S_S_u4i4__ p0, struct S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void .ctor(Unity.Mathematics.uint2x4) declare in Unity.Mathematics.double2x4
bool w_vtS_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint2x3) declare in Unity.Mathematics.double2x3
bool w_vtS_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u4u4_S_u4u4_S_u4u4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint2x2) declare in Unity.Mathematics.double2x2
bool w_vtS_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4u4_S_u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4__>(apis, env, _sv0);
    S_S_u4u4_S_u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4_S_u4u4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u4u4_S_u4u4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint3x4) declare in Unity.Mathematics.double3x4
bool w_vtS_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint3x3) declare in Unity.Mathematics.double3x3
bool w_vtS_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint3x2) declare in Unity.Mathematics.double3x2
bool w_vtS_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4u4u4_S_u4u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4_S_u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4_S_u4u4u4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u4u4u4_S_u4u4u4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint4x4) declare in Unity.Mathematics.double4x4
bool w_vtS_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint4x3) declare in Unity.Mathematics.double4x3
bool w_vtS_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint4x2) declare in Unity.Mathematics.double4x2
bool w_vtS_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef void (*FuncToCall)(void*,struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_serializationObject(UnityEditor.Build.Content.ObjectIdentifier) declare in UnityEditor.Build.Content.SerializationInfo
bool w_vtS_S_u4u4u4u4_i8i4s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4u4u4u4_i8i4s_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_i8i4s_* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(apis, env, _sv0);
    S_S_u4u4u4u4_i8i4s_ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_i8i4s_ {};

    typedef void (*FuncToCall)(void*,struct S_S_u4u4u4u4_i8i4s_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void DependsOnArtifact(UnityEditor.Experimental.ArtifactKey) declare in UnityEditor.AssetImporters.AssetImportContext
bool w_vtS_S_u4u4u4u4_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u4u4u4u4_o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_o_* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_o_>(apis, env, _sv0);
    S_S_u4u4u4u4_o_ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_o_ {};

    typedef void (*FuncToCall)(void*,struct S_S_u4u4u4u4_o_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void WriteValue(System.DateTimeOffset) declare in System.Xml.XmlWriter
bool w_vtS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};

    typedef void (*FuncToCall)(void*,struct S_S_u8_i2_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEditor.GlobalObjectId, UnityEngine.Object, System.Type) declare in UnityEditor.SearchService.ObjectSelectorTargetInfo
bool w_vtS_S_u8u8_S_u4u4u4u4_i4_DoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u8u8_S_u4u4u4u4_i4_DoDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8u8_S_u4u4u4u4_i4_* pp0 = DataTransfer::GetPointer<S_S_u8u8_S_u4u4u4u4_i4_>(apis, env, _sv0);
    S_S_u8u8_S_u4u4u4u4_i4_ p0 = pp0 ? *pp0 : S_S_u8u8_S_u4u4u4u4_i4_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef void (*FuncToCall)(void*,struct S_S_u8u8_S_u4u4u4u4_i4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Tick(UnityEditor.Experimental.Rendering.SceneStateHash, UnityEditor.Experimental.Rendering.IScriptableBakedReflectionSystemStageNotifier) declare in UnityEditor.Experimental.Rendering.ScriptableBakedReflectionSystem
bool w_vtS_S_u8u8_S_u8u8_S_u8u8__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_u8u8_S_u8u8_S_u8u8__o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8u8_S_u8u8_S_u8u8__* pp0 = DataTransfer::GetPointer<S_S_u8u8_S_u8u8_S_u8u8__>(apis, env, _sv0);
    S_S_u8u8_S_u8u8_S_u8u8__ p0 = pp0 ? *pp0 : S_S_u8u8_S_u8u8_S_u8u8__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_u8u8_S_u8u8_S_u8u8__ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_viewID(UnityEngine.NetworkViewID) declare in UnityEngine.NetworkView
bool w_vtS__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};

    typedef void (*FuncToCall)(void*,struct S__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void WaitOnGPUFence(UnityEngine.Rendering.GPUFence, UnityEngine.Rendering.SynchronisationStage) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS__i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S__ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.NoOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[UnityEngine.Quaternion], DG.Tweening.Core.DOSetter`1[UnityEngine.Quaternion], Single, UnityEngine.Quaternion, UnityEngine.Quaternion, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.CustomPlugins.PureQuaternionPlugin
bool w_vtS__oboor4S_r4r4r4r4_S_r4r4r4r4_r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS__oboor4S_r4r4r4r4_S_r4r4r4r4_r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv7);
    S_r4r4r4r4_ p7 = pp7 ? *pp7 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S__ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, struct S_r4r4r4r4_ p6, struct S_r4r4r4r4_ p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.NoOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[System.Int32], DG.Tweening.Core.DOSetter`1[System.Int32], Single, Int32, Int32, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.IntPlugin
bool w_vtS__oboor4i4i4r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS__oboor4i4i4r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S__ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, int32_t p6, int32_t p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.NoOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[System.Int64], DG.Tweening.Core.DOSetter`1[System.Int64], Single, Int64, Int64, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.LongPlugin
bool w_vtS__oboor4i8i8r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS__oboor4i8i8r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int64_t p7 = converter::Converter<int64_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S__ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, int64_t p6, int64_t p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.NoOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[UnityEngine.RectOffset], DG.Tweening.Core.DOSetter`1[UnityEngine.RectOffset], Single, UnityEngine.RectOffset, UnityEngine.RectOffset, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.RectOffsetPlugin
bool w_vtS__oboor4oor4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS__oboor4oor4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S__ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, Il2CppObject* p6, Il2CppObject* p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.NoOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[System.Double], DG.Tweening.Core.DOSetter`1[System.Double], Single, Double, Double, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.DoublePlugin
bool w_vtS__oboor4r8r8r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS__oboor4r8r8r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    double p6 = converter::Converter<double>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    double p7 = converter::Converter<double>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S__ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, double p6, double p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.NoOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[System.UInt64], DG.Tweening.Core.DOSetter`1[System.UInt64], Single, UInt64, UInt64, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.UlongPlugin
bool w_vtS__oboor4u8u8r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS__oboor4u8u8r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    uint64_t p6 = converter::Converter<uint64_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    uint64_t p7 = converter::Converter<uint64_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S__ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, uint64_t p6, uint64_t p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void .ctor(System.Text.Json.Nodes.JsonNodeOptions, System.ReadOnlySpan`1[System.Text.Json.Nodes.JsonNode]) declare in System.Text.Json.Nodes.JsonArray
bool w_vtS_b_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_b_S_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_b_* pp0 = DataTransfer::GetPointer<S_b_>(apis, env, _sv0);
    S_b_ p0 = pp0 ? *pp0 : S_b_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_b_ p0, struct S_S_p_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Text.Json.Nodes.JsonNodeOptions, System.Text.Json.Nodes.JsonNode[]) declare in System.Text.Json.Nodes.JsonArray
bool w_vtS_b_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_b_Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal struct
    S_b_* pp0 = DataTransfer::GetPointer<S_b_>(apis, env, _sv0);
    S_b_ p0 = pp0 ? *pp0 : S_b_ {};
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,struct S_b_ p0, Il2CppArray* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[UnityEngine.Color], DG.Tweening.Core.DOSetter`1[UnityEngine.Color], Single, UnityEngine.Color, UnityEngine.Color, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.ColorPlugin
bool w_vtS_b_oboor4S_r4r4r4r4_S_r4r4r4r4_r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_b_oboor4S_r4r4r4r4_S_r4r4r4r4_r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S_b_* pp0 = DataTransfer::GetPointer<S_b_>(apis, env, _sv0);
    S_b_ p0 = pp0 ? *pp0 : S_b_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv7);
    S_r4r4r4r4_ p7 = pp7 ? *pp7 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S_b_ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, struct S_r4r4r4r4_ p6, struct S_r4r4r4r4_ p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.FloatOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[System.Single], DG.Tweening.Core.DOSetter`1[System.Single], Single, Single, Single, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.FloatPlugin
bool w_vtS_b_oboor4r4r4r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_b_oboor4r4r4r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S_b_* pp0 = DataTransfer::GetPointer<S_b_>(apis, env, _sv0);
    S_b_ p0 = pp0 ? *pp0 : S_b_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S_b_ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, float p6, float p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.UintOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[System.UInt32], DG.Tweening.Core.DOSetter`1[System.UInt32], Single, UInt32, UInt32, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.UintPlugin
bool w_vtS_b_oboor4u4u4r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_b_oboor4u4u4r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S_b_* pp0 = DataTransfer::GetPointer<S_b_>(apis, env, _sv0);
    S_b_ p0 = pp0 ? *pp0 : S_b_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    uint32_t p6 = converter::Converter<uint32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S_b_ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, uint32_t p6, uint32_t p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void set_xy(Unity.Mathematics.bool2) declare in Unity.Mathematics.bool2
bool w_vtS_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};

    typedef void (*FuncToCall)(void*,struct S_bb_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool2, Unity.Mathematics.bool2) declare in Unity.Mathematics.bool2x2
bool w_vtS_bb_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bb_S_bb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};

    typedef void (*FuncToCall)(void*,struct S_bb_ p0, struct S_bb_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool2, Unity.Mathematics.bool2, Unity.Mathematics.bool2) declare in Unity.Mathematics.bool2x3
bool w_vtS_bb_S_bb_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bb_S_bb_S_bb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp2 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv2);
    S_bb_ p2 = pp2 ? *pp2 : S_bb_ {};

    typedef void (*FuncToCall)(void*,struct S_bb_ p0, struct S_bb_ p1, struct S_bb_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool2, Unity.Mathematics.bool2, Unity.Mathematics.bool2, Unity.Mathematics.bool2) declare in Unity.Mathematics.bool2x4
bool w_vtS_bb_S_bb_S_bb_S_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bb_S_bb_S_bb_S_bb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp2 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv2);
    S_bb_ p2 = pp2 ? *pp2 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp3 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv3);
    S_bb_ p3 = pp3 ? *pp3 : S_bb_ {};

    typedef void (*FuncToCall)(void*,struct S_bb_ p0, struct S_bb_ p1, struct S_bb_ p2, struct S_bb_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool2, Boolean) declare in Unity.Mathematics.bool3
bool w_vtS_bb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bb_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_bb_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool2, Boolean, Boolean) declare in Unity.Mathematics.bool4
bool w_vtS_bb_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bb_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_bb_ p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Optimize(UnityEditor.Search.QueryGraphOptimizationOptions) declare in UnityEditor.Search.QueryGraph
bool w_vtS_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};

    typedef void (*FuncToCall)(void*,struct S_bbb_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool3, Unity.Mathematics.bool3) declare in Unity.Mathematics.bool3x2
bool w_vtS_bbb_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bbb_S_bbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};

    typedef void (*FuncToCall)(void*,struct S_bbb_ p0, struct S_bbb_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool3, Unity.Mathematics.bool3, Unity.Mathematics.bool3) declare in Unity.Mathematics.bool3x3
bool w_vtS_bbb_S_bbb_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bbb_S_bbb_S_bbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp2 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv2);
    S_bbb_ p2 = pp2 ? *pp2 : S_bbb_ {};

    typedef void (*FuncToCall)(void*,struct S_bbb_ p0, struct S_bbb_ p1, struct S_bbb_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool3, Unity.Mathematics.bool3, Unity.Mathematics.bool3, Unity.Mathematics.bool3) declare in Unity.Mathematics.bool3x4
bool w_vtS_bbb_S_bbb_S_bbb_S_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bbb_S_bbb_S_bbb_S_bbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp2 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv2);
    S_bbb_ p2 = pp2 ? *pp2 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp3 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv3);
    S_bbb_ p3 = pp3 ? *pp3 : S_bbb_ {};

    typedef void (*FuncToCall)(void*,struct S_bbb_ p0, struct S_bbb_ p1, struct S_bbb_ p2, struct S_bbb_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool3, Boolean) declare in Unity.Mathematics.bool4
bool w_vtS_bbb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bbb_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_bbb_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_xyzw(Unity.Mathematics.bool4) declare in Unity.Mathematics.bool4
bool w_vtS_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bbbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};

    typedef void (*FuncToCall)(void*,struct S_bbbb_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool4, Unity.Mathematics.bool4) declare in Unity.Mathematics.bool4x2
bool w_vtS_bbbb_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bbbb_S_bbbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp1 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv1);
    S_bbbb_ p1 = pp1 ? *pp1 : S_bbbb_ {};

    typedef void (*FuncToCall)(void*,struct S_bbbb_ p0, struct S_bbbb_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool4, Unity.Mathematics.bool4, Unity.Mathematics.bool4) declare in Unity.Mathematics.bool4x3
bool w_vtS_bbbb_S_bbbb_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bbbb_S_bbbb_S_bbbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp1 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv1);
    S_bbbb_ p1 = pp1 ? *pp1 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp2 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv2);
    S_bbbb_ p2 = pp2 ? *pp2 : S_bbbb_ {};

    typedef void (*FuncToCall)(void*,struct S_bbbb_ p0, struct S_bbbb_ p1, struct S_bbbb_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.bool4, Unity.Mathematics.bool4, Unity.Mathematics.bool4, Unity.Mathematics.bool4) declare in Unity.Mathematics.bool4x4
bool w_vtS_bbbb_S_bbbb_S_bbbb_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bbbb_S_bbbb_S_bbbb_S_bbbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp1 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv1);
    S_bbbb_ p1 = pp1 ? *pp1 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp2 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv2);
    S_bbbb_ p2 = pp2 ? *pp2 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp3 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv3);
    S_bbbb_ p3 = pp3 ? *pp3 : S_bbbb_ {};

    typedef void (*FuncToCall)(void*,struct S_bbbb_ p0, struct S_bbbb_ p1, struct S_bbbb_ p2, struct S_bbbb_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEditor.Search.QueryValidationOptions) declare in UnityEditor.Search.QueryEngine
bool w_vtS_bbbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bbbbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbbb_* pp0 = DataTransfer::GetPointer<S_bbbbb_>(apis, env, _sv0);
    S_bbbbb_ p0 = pp0 ? *pp0 : S_bbbbb_ {};

    typedef void (*FuncToCall)(void*,struct S_bbbbb_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Update(UnityEngine.Rendering.GlobalDynamicResolutionSettings, System.Action) declare in UnityEngine.Rendering.DynamicResolutionHandler
bool w_vtS_bbbu4i4br4br4r4r4u1u1br4r4r4r4r4_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bbbu4i4br4br4r4r4u1u1br4r4r4r4r4_Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbu4i4br4br4r4r4u1u1br4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_bbbu4i4br4br4r4r4u1u1br4r4r4r4r4_>(apis, env, _sv0);
    S_bbbu4i4br4br4r4r4u1u1br4r4r4r4r4_ p0 = pp0 ? *pp0 : S_bbbu4i4br4br4r4r4u1u1br4r4r4r4r4_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef void (*FuncToCall)(void*,struct S_bbbu4i4br4br4r4r4u1u1br4r4r4r4r4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.StringOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[System.String], DG.Tweening.Core.DOSetter`1[System.String], Single, System.String, System.String, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.StringPlugin
bool w_vtS_bi4oi4i4_oboor4ssr4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bi4oi4i4_oboor4ssr4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4oi4i4_* pp0 = DataTransfer::GetPointer<S_bi4oi4i4_>(apis, env, _sv0);
    S_bi4oi4i4_ p0 = pp0 ? *pp0 : S_bi4oi4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6);
    // JSValToCSVal s
    Il2CppString* p7 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S_bi4oi4i4_ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, Il2CppString* p6, Il2CppString* p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void CreateBranch(PlasticGui.WorkspaceWindow.QueryViews.Branches.BranchCreationData, System.Action, PlasticGui.EndOperationDelegateForUpdatedItems) declare in PlasticGui.WorkspaceWindow.QueryViews.Branches.BranchOperations
bool w_vtS_booi8ssob_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_booi8ssob_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_booi8ssob_* pp0 = DataTransfer::GetPointer<S_booi8ssob_>(apis, env, _sv0);
    S_booi8ssob_ p0 = pp0 ? *pp0 : S_booi8ssob_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_booi8ssob_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void RenameBranch(PlasticGui.WorkspaceWindow.QueryViews.Branches.BranchRenameData) declare in PlasticGui.WorkspaceWindow.QueryViews.Branches.BranchOperations
bool w_vtS_boos_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_boos_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_boos_* pp0 = DataTransfer::GetPointer<S_boos_>(apis, env, _sv0);
    S_boos_ p0 = pp0 ? *pp0 : S_boos_ {};

    typedef void (*FuncToCall)(void*,struct S_boos_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void RenameWorkspace(PlasticGui.WorkspaceWindow.Home.Workspaces.WorkspaceRenameData) declare in PlasticGui.WorkspaceWindow.Home.Workspaces.WorkspaceOperations
bool w_vtS_bos_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bos_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bos_* pp0 = DataTransfer::GetPointer<S_bos_>(apis, env, _sv0);
    S_bos_ p0 = pp0 ? *pp0 : S_bos_ {};

    typedef void (*FuncToCall)(void*,struct S_bos_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void CreateRepository(PlasticGui.WorkspaceWindow.Home.Repositories.RepositoryCreationData) declare in PlasticGui.WorkspaceWindow.Home.Repositories.RepositoryOperations
bool w_vtS_bss_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bss_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bss_* pp0 = DataTransfer::GetPointer<S_bss_>(apis, env, _sv0);
    S_bss_ p0 = pp0 ? *pp0 : S_bss_ {};

    typedef void (*FuncToCall)(void*,struct S_bss_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void CreateRepositoryAndWorkspace(PlasticGui.WorkspaceWindow.Home.Repositories.RepositoryCreationData, PlasticGui.WorkspaceWindow.Home.Workspaces.WorkspaceCreationData, System.Action`1[Codice.CM.Common.WorkspaceInfo]) declare in PlasticGui.WorkspaceWindow.Home.Repositories.RepositoryOperations
bool w_vtS_bss_S_bsssbb_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bss_S_bsssbb_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_bss_* pp0 = DataTransfer::GetPointer<S_bss_>(apis, env, _sv0);
    S_bss_ p0 = pp0 ? *pp0 : S_bss_ {};
    // JSValToCSVal struct
    S_bsssbb_* pp1 = DataTransfer::GetPointer<S_bsssbb_>(apis, env, _sv1);
    S_bsssbb_ p1 = pp1 ? *pp1 : S_bsssbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_bss_ p0, struct S_bsssbb_ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void CreateWorkspace(PlasticGui.WorkspaceWindow.Home.Workspaces.WorkspaceCreationData) declare in PlasticGui.WorkspaceWindow.Home.Workspaces.WorkspaceOperations
bool w_vtS_bsssbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bsssbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bsssbb_* pp0 = DataTransfer::GetPointer<S_bsssbb_>(apis, env, _sv0);
    S_bsssbb_ p0 = pp0 ? *pp0 : S_bsssbb_ {};

    typedef void (*FuncToCall)(void*,struct S_bsssbb_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void DownloadRepository(PlasticGui.WorkspaceWindow.Home.Workspaces.WorkspaceCreationData, System.Action`1[Codice.CM.Common.WorkspaceInfo]) declare in PlasticGui.WorkspaceWindow.Home.Repositories.RepositoryOperations
bool w_vtS_bsssbb_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bsssbb_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_bsssbb_* pp0 = DataTransfer::GetPointer<S_bsssbb_>(apis, env, _sv0);
    S_bsssbb_ p0 = pp0 ? *pp0 : S_bsssbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_bsssbb_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_sortingLayerRange(UnityEngine.Rendering.SortingLayerRange) declare in UnityEngine.Rendering.FilteringSettings
bool w_vtS_i2i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i2i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i2i2_* pp0 = DataTransfer::GetPointer<S_i2i2_>(apis, env, _sv0);
    S_i2i2_ p0 = pp0 ? *pp0 : S_i2i2_ {};

    typedef void (*FuncToCall)(void*,struct S_i2i2_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_Item(Section, Int32) declare in System.Collections.Specialized.BitVector32
bool w_vtS_i2i2_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i2i2_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i2i2_* pp0 = DataTransfer::GetPointer<S_i2i2_>(apis, env, _sv0);
    S_i2i2_ p0 = pp0 ? *pp0 : S_i2i2_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i2i2_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Transactions.TransactionOptions) declare in System.Transactions.CommittableTransaction
bool w_vtS_i4S_i8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4S_i8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_i8__* pp0 = DataTransfer::GetPointer<S_i4S_i8__>(apis, env, _sv0);
    S_i4S_i8__ p0 = pp0 ? *pp0 : S_i4S_i8__ {};

    typedef void (*FuncToCall)(void*,struct S_i4S_i8__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_value(UnityEngine.UIElements.BackgroundSize) declare in UnityEngine.UIElements.StyleBackgroundSize
bool w_vtS_i4S_r4i4_S_r4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4S_r4i4_S_r4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_r4i4_S_r4i4__* pp0 = DataTransfer::GetPointer<S_i4S_r4i4_S_r4i4__>(apis, env, _sv0);
    S_i4S_r4i4_S_r4i4__ p0 = pp0 ? *pp0 : S_i4S_r4i4_S_r4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_i4S_r4i4_S_r4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_value(UnityEngine.UIElements.BackgroundPosition) declare in UnityEngine.UIElements.StyleBackgroundPosition
bool w_vtS_i4S_r4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4S_r4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_r4i4__* pp0 = DataTransfer::GetPointer<S_i4S_r4i4__>(apis, env, _sv0);
    S_i4S_r4i4__ p0 = pp0 ? *pp0 : S_i4S_r4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_i4S_r4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_lodParameters(UnityEngine.Rendering.LODParameters) declare in UnityEngine.Rendering.ScriptableCullingParameters
bool w_vtS_i4S_r4r4r4_r4r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4S_r4r4r4_r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_r4r4r4_r4r4i4_* pp0 = DataTransfer::GetPointer<S_i4S_r4r4r4_r4r4i4_>(apis, env, _sv0);
    S_i4S_r4r4r4_r4r4i4_ p0 = pp0 ? *pp0 : S_i4S_r4r4r4_r4r4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4S_r4r4r4_r4r4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_splitData(UnityEngine.Rendering.ShadowSplitData) declare in UnityEngine.Rendering.ShadowDrawingSettings
bool w_vtS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>(apis, env, _sv0);
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p0 = pp0 ? *pp0 : S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void MarkLabel(System.Reflection.Emit.Label) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.LayerMask, Boolean) declare in UnityEngine.Rendering.LayerMaskParameter
bool w_vtS_i4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.SceneManagement.Scene, ReadOnly) declare in UnityEditor.UpdatePrefabInstancesEventArgs
bool w_vtS_i4_S_Pvi4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_Pvi4S_pi4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_Pvi4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pvi4S_pi4i4__>(apis, env, _sv1);
    S_Pvi4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pvi4S_pi4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_Pvi4S_pi4i4__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.ShaderTagId, UnityEngine.Rendering.SortingSettings) declare in UnityEngine.Rendering.DrawingSettings
bool w_vtS_i4_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_>(apis, env, _sv1);
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Index, System.Index) declare in System.Range
bool w_vtS_i4_S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.ShaderTagId, UnityEngine.Rendering.CullingResults, UnityEngine.Camera) declare in UnityEngine.Rendering.RendererUtils.RendererListDesc
bool w_vtS_i4_S_pPvS_pi4i4__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_pPvS_pi4i4__o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_pPvS_pi4i4__* pp1 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, _sv1);
    S_pPvS_pi4i4__ p1 = pp1 ? *pp1 : S_pPvS_pi4i4__ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_pPvS_pi4i4__ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.PhysicsScene, UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32, Int32) declare in UnityEngine.RaycastCommand
bool w_vtS_i4_S_r4r4r4_S_r4r4r4_Dr4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_r4r4r4_S_r4r4r4_Dr4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (js_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(UnityEngine.PhysicsScene, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.QueryParameters, Single) declare in UnityEngine.RaycastCommand
bool w_vtS_i4_S_r4r4r4_S_r4r4r4_S_i4bi4b_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_r4r4r4_S_r4r4r4_S_i4bi4b_Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_i4bi4b_* pp3 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv3);
    S_i4bi4b_ p3 = pp3 ? *pp3 : S_i4bi4b_ {};
    // JSValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_i4bi4b_ p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(UnityEngine.PhysicsScene, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.QueryParameters) declare in UnityEngine.OverlapBoxCommand
bool w_vtS_i4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4bi4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4bi4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_i4bi4b_* pp4 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv4);
    S_i4bi4b_ p4 = pp4 ? *pp4 : S_i4bi4b_ {};

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, struct S_i4bi4b_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(UnityEngine.PhysicsScene, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3, Single, Int32) declare in UnityEngine.BoxcastCommand
bool w_vtS_i4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_Dr4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_Dr4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (js_args_len > 5 && !converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(UnityEngine.PhysicsScene, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3, UnityEngine.QueryParameters, Single) declare in UnityEngine.BoxcastCommand
bool w_vtS_i4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_S_i4bi4b_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_S_i4bi4b_Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
        if (js_args_len > 6 && !converter::Converter<float>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_i4bi4b_* pp5 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv5);
    S_i4bi4b_ p5 = pp5 ? *pp5 : S_i4bi4b_ {};
    // JSValToCSVal primitive with default
    float p6 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4_ p4, struct S_i4bi4b_ p5, float p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(UnityEngine.PhysicsScene, UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.QueryParameters) declare in UnityEngine.OverlapCapsuleCommand
bool w_vtS_i4_S_r4r4r4_S_r4r4r4_r4S_i4bi4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_r4r4r4_S_r4r4r4_r4S_i4bi4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_i4bi4b_* pp4 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv4);
    S_i4bi4b_ p4 = pp4 ? *pp4 : S_i4bi4b_ {};

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_i4bi4b_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(UnityEngine.PhysicsScene, UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32) declare in UnityEngine.CapsulecastCommand
bool w_vtS_i4_S_r4r4r4_S_r4r4r4_r4S_r4r4r4_Dr4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_r4r4r4_S_r4r4r4_r4S_r4r4r4_Dr4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (js_args_len > 5 && !converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, float p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(UnityEngine.PhysicsScene, UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.QueryParameters, Single) declare in UnityEngine.CapsulecastCommand
bool w_vtS_i4_S_r4r4r4_S_r4r4r4_r4S_r4r4r4_S_i4bi4b_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_r4r4r4_S_r4r4r4_r4S_r4r4r4_S_i4bi4b_Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
        if (js_args_len > 6 && !converter::Converter<float>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_i4bi4b_* pp5 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv5);
    S_i4bi4b_ p5 = pp5 ? *pp5 : S_i4bi4b_ {};
    // JSValToCSVal primitive with default
    float p6 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, struct S_i4bi4b_ p5, float p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(UnityEngine.PhysicsScene, UnityEngine.Vector3, Single, UnityEngine.QueryParameters) declare in UnityEngine.OverlapSphereCommand
bool w_vtS_i4_S_r4r4r4_r4S_i4bi4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_r4r4r4_r4S_i4bi4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_i4bi4b_* pp3 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv3);
    S_i4bi4b_ p3 = pp3 ? *pp3 : S_i4bi4b_ {};

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_r4r4r4_ p1, float p2, struct S_i4bi4b_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.PhysicsScene, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32) declare in UnityEngine.SpherecastCommand
bool w_vtS_i4_S_r4r4r4_r4S_r4r4r4_Dr4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_r4r4r4_r4S_r4r4r4_Dr4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, float p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(UnityEngine.PhysicsScene, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.QueryParameters, Single) declare in UnityEngine.SpherecastCommand
bool w_vtS_i4_S_r4r4r4_r4S_r4r4r4_S_i4bi4b_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_S_r4r4r4_r4S_r4r4r4_S_i4bi4b_Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (js_args_len > 5 && !converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_i4bi4b_* pp4 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv4);
    S_i4bi4b_ p4 = pp4 ? *pp4 : S_i4bi4b_ {};
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, struct S_i4bi4b_ p4, float p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DefineField(System.Diagnostics.SymbolStore.SymbolToken, System.String, System.Reflection.FieldAttributes, Byte[], System.Diagnostics.SymbolStore.SymAddressKind, Int32, Int32, Int32) declare in Mono.CompilerServices.SymbolWriter.SymbolWriterImpl
bool w_vtS_i4_si4oi4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_si4oi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, Il2CppString* p1, int32_t p2, Il2CppObject* p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken, System.String, Byte[]) declare in Mono.CompilerServices.SymbolWriter.SymbolWriterImpl
bool w_vtS_i4_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4_ p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.VectorOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[UnityEngine.Vector2], DG.Tweening.Core.DOSetter`1[UnityEngine.Vector2], Single, UnityEngine.Vector2, UnityEngine.Vector2, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.Vector2Plugin
bool w_vtS_i4b_oboor4S_r4r4_S_r4r4_r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4b_oboor4S_r4r4_S_r4r4_r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S_i4b_* pp0 = DataTransfer::GetPointer<S_i4b_>(apis, env, _sv0);
    S_i4b_ p0 = pp0 ? *pp0 : S_i4b_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv6);
    S_r4r4_ p6 = pp6 ? *pp6 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv7);
    S_r4r4_ p7 = pp7 ? *pp7 : S_r4r4_ {};
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S_i4b_ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, struct S_r4r4_ p6, struct S_r4r4_ p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.VectorOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[UnityEngine.Vector3], DG.Tweening.Core.DOSetter`1[UnityEngine.Vector3], Single, UnityEngine.Vector3, UnityEngine.Vector3, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.Vector3Plugin
bool w_vtS_i4b_oboor4S_r4r4r4_S_r4r4r4_r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4b_oboor4S_r4r4r4_S_r4r4r4_r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S_i4b_* pp0 = DataTransfer::GetPointer<S_i4b_>(apis, env, _sv0);
    S_i4b_ p0 = pp0 ? *pp0 : S_i4b_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv6);
    S_r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv7);
    S_r4r4r4_ p7 = pp7 ? *pp7 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S_i4b_ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, struct S_r4r4r4_ p6, struct S_r4r4r4_ p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.VectorOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[UnityEngine.Vector4], DG.Tweening.Core.DOSetter`1[UnityEngine.Vector4], Single, UnityEngine.Vector4, UnityEngine.Vector4, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.Vector4Plugin
bool w_vtS_i4b_oboor4S_r4r4r4r4_S_r4r4r4r4_r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4b_oboor4S_r4r4r4r4_S_r4r4r4r4_r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S_i4b_* pp0 = DataTransfer::GetPointer<S_i4b_>(apis, env, _sv0);
    S_i4b_ p0 = pp0 ? *pp0 : S_i4b_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv7);
    S_r4r4r4r4_ p7 = pp7 ? *pp7 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S_i4b_ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, struct S_r4r4r4r4_ p6, struct S_r4r4r4r4_ p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.Vector3ArrayOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[UnityEngine.Vector3], DG.Tweening.Core.DOSetter`1[UnityEngine.Vector3], Single, UnityEngine.Vector3[], UnityEngine.Vector3[], Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.Vector3ArrayPlugin
bool w_vtS_i4bo_oboor4oor4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4bo_oboor4oor4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S_i4bo_* pp0 = DataTransfer::GetPointer<S_i4bo_>(apis, env, _sv0);
    S_i4bo_ p0 = pp0 ? *pp0 : S_i4bo_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S_i4bo_ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, Il2CppObject* p6, Il2CppObject* p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void set_navigation(UnityEngine.UI.Navigation) declare in UnityEngine.UI.Selectable
bool w_vtS_i4boooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4boooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4boooo_* pp0 = DataTransfer::GetPointer<S_i4boooo_>(apis, env, _sv0);
    S_i4boooo_ p0 = pp0 ? *pp0 : S_i4boooo_ {};

    typedef void (*FuncToCall)(void*,struct S_i4boooo_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_InheritedObjectAceType(System.Guid) declare in System.Security.AccessControl.ObjectAce
bool w_vtS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(System.Guid, System.Guid, System.Diagnostics.PerformanceData.CounterSetInstanceType) declare in System.Diagnostics.PerformanceData.CounterSet
bool w_vtS_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPreallocatedIndex(System.Guid, Int32) declare in Codice.Client.BaseCommands.BranchExplorer.Layout.PersistentBranchLayout
bool w_vtS_i4i2i2u1u1u1u1u1u1u1u1_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i2i2u1u1u1u1u1u1u1u1_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteData(System.Guid, Int32, FileData) declare in Codice.CM.Common.Serialization.ExternalStorageDataWriter
bool w_vtS_i4i2i2u1u1u1u1u1u1u1u1_i4S_i8i2u8bo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i2i2u1u1u1u1u1u1u1u1_i4S_i8i2u8bo_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i8i2u8bo_* pp2 = DataTransfer::GetPointer<S_i8i2u8bo_>(apis, env, _sv2);
    S_i8i2u8bo_ p2 = pp2 ? *pp2 : S_i8i2u8bo_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, int32_t p1, struct S_i8i2u8bo_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Register(System.Guid, UnityEngine.Events.UnityAction`1[UnityEngine.Networking.PlayerConnection.MessageEventArgs]) declare in UnityEngine.Networking.PlayerConnection.PlayerConnection
bool w_vtS_i4i2i2u1u1u1u1u1u1u1u1_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i2i2u1u1u1u1u1u1u1u1_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Send(System.Guid, Byte[], Int32) declare in UnityEditor.Networking.PlayerConnection.EditorConnection
bool w_vtS_i4i2i2u1u1u1u1u1u1u1u1_oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i2i2u1u1u1u1u1u1u1u1_oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppObject* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.Guid, System.Collections.Generic.List`1[JetBrains.Rider.Model.Unity.BackendUnity.TestFilter], JetBrains.Rider.Model.Unity.BackendUnity.TestMode, JetBrains.Rider.Model.Unity.BackendUnity.UnitTestLaunchClientControllerInfo) declare in JetBrains.Rider.Model.Unity.BackendUnity.UnitTestLaunch
bool w_vtS_i4i2i2u1u1u1u1u1u1u1u1_oi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i2i2u1u1u1u1u1u1u1u1_oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppObject* p1, int32_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void RenameWorkspace(System.Guid, System.String) declare in PlasticGui.WorkspaceWindow.Topbar.RecentWorkspacesList
bool w_vtS_i4i2i2u1u1u1u1u1u1u1u1_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i2i2u1u1u1u1u1u1u1u1_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Guid, System.String, System.String, System.String, Codice.CM.Common.RepId, Int32, Codice.CM.Common.Workspaces.UvcsConnectionTargetType, Int32, Codice.CM.Common.Workspaces.UvcsConnectionWorkspaceType, Int32, System.DateTime) declare in Codice.CM.Common.Workspaces.UvcsConnectionInfo
bool w_vtS_i4i2i2u1u1u1u1u1u1u1u1_sssS_u4u4_i4u1i4u1i4S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i2i2u1u1u1u1u1u1u1u1_sssS_u4u4_i4u1i4u1i4S_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp10 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);

    if (checkJSArgument) {
        if (js_args_len != 11) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv10, TIp10, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_u4u4_* pp4 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv4);
    S_u4u4_ p4 = pp4 ? *pp4 : S_u4u4_ {};
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    uint8_t p6 = converter::Converter<uint8_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    uint8_t p8 = converter::Converter<uint8_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal struct
    S_u8_* pp10 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv10);
    S_u8_ p10 = pp10 ? *pp10 : S_u8_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, struct S_u4u4_ p4, int32_t p5, uint8_t p6, int32_t p7, uint8_t p8, int32_t p9, struct S_u8_ p10, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void AddInProgressMergeLink(System.Guid, Codice.CM.Common.MergeType, System.Guid) declare in Codice.Client.BaseCommands.BranchExplorer.ExplorerTree.BrExTree
bool w_vtS_i4i2i2u1u1u1u1u1u1u1u1_u1S_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i2i2u1u1u1u1u1u1u1u1_u1S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv2);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p2 = pp2 ? *pp2 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, uint8_t p1, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.QuaternionOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[UnityEngine.Quaternion], DG.Tweening.Core.DOSetter`1[UnityEngine.Quaternion], Single, UnityEngine.Vector3, UnityEngine.Vector3, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.QuaternionPlugin
bool w_vtS_i4i4S_r4r4r4_bS_r4r4r4__oboor4S_r4r4r4_S_r4r4r4_r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4S_r4r4r4_bS_r4r4r4__oboor4S_r4r4r4_S_r4r4r4_r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4S_r4r4r4_bS_r4r4r4__* pp0 = DataTransfer::GetPointer<S_i4i4S_r4r4r4_bS_r4r4r4__>(apis, env, _sv0);
    S_i4i4S_r4r4r4_bS_r4r4r4__ p0 = pp0 ? *pp0 : S_i4i4S_r4r4r4_bS_r4r4r4__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv6);
    S_r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv7);
    S_r4r4r4_ p7 = pp7 ? *pp7 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S_i4i4S_r4r4r4_bS_r4r4r4__ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, struct S_r4r4r4_ p6, struct S_r4r4r4_ p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void set_min(UnityEngine.Vector2Int) declare in UnityEngine.RectInt
bool w_vtS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetMinMax(UnityEngine.Vector2Int, UnityEngine.Vector2Int) declare in UnityEngine.RectInt
bool w_vtS_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_S_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p0, struct S_i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int2, Unity.Mathematics.int2, Unity.Mathematics.int2) declare in Unity.Mathematics.int2x3
bool w_vtS_i4i4_S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_S_i4i4_S_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p0, struct S_i4i4_ p1, struct S_i4i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int2, Unity.Mathematics.int2, Unity.Mathematics.int2, Unity.Mathematics.int2) declare in Unity.Mathematics.int2x4
bool w_vtS_i4i4_S_i4i4_S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_S_i4i4_S_i4i4_S_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv3);
    S_i4i4_ p3 = pp3 ? *pp3 : S_i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p0, struct S_i4i4_ p1, struct S_i4i4_ p2, struct S_i4i4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int2, Int32) declare in Unity.Mathematics.int3
bool w_vtS_i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int2, Int32, Int32) declare in Unity.Mathematics.int4
bool w_vtS_i4i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetDetailLayer(UnityEngine.Vector2Int, Int32, Int32[,]) declare in UnityEngine.TerrainData
bool w_vtS_i4i4_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetReferenceValue(UnityEngine.PropertyName, UnityEngine.Object) declare in UnityEngine.Playables.PlayableDirector
bool w_vtS_i4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetMuscle(UnityEngine.Animations.MuscleHandle, Single) declare in UnityEngine.Animations.AnimationHumanStream
bool w_vtS_i4i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetPackingSettings(UnityEngine.U2D.SpriteAtlas, UnityEditor.U2D.SpriteAtlasPackingSettings) declare in UnityEditor.U2D.SpriteAtlasExtensions
bool w_vtS_i4i4bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4bbbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4bbbb_* pp0 = DataTransfer::GetPointer<S_i4i4bbbb_>(apis, env, _sv0);
    S_i4i4bbbb_ p0 = pp0 ? *pp0 : S_i4i4bbbb_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4bbbb_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Mono.Cecil.Cil.ImageDebugDirectory, Byte[]) declare in Mono.Cecil.Cil.ImageDebugHeaderEntry
bool w_vtS_i4i4i2i2i4i4i4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i2i2i4i4i4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i2i2i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i2i2i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i2i2i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i2i2i4i4i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4i2i2i4i4i4i4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_min(UnityEngine.Vector3Int) declare in UnityEngine.BoundsInt
bool w_vtS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetMinMax(UnityEngine.Vector3Int, UnityEngine.Vector3Int) declare in UnityEngine.BoundsInt
bool w_vtS_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_S_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int3, Unity.Mathematics.int3, Unity.Mathematics.int3) declare in Unity.Mathematics.int3x3
bool w_vtS_i4i4i4_S_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_S_i4i4i4_S_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, struct S_i4i4i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int3, Unity.Mathematics.int3, Unity.Mathematics.int3, Unity.Mathematics.int3) declare in Unity.Mathematics.int3x4
bool w_vtS_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_S_i4i4i4_S_i4i4i4_S_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv3);
    S_i4i4i4_ p3 = pp3 ? *pp3 : S_i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, struct S_i4i4i4_ p2, struct S_i4i4i4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetColor(UnityEngine.Vector3Int, UnityEngine.Color) declare in UnityEngine.Tilemaps.Tilemap
bool w_vtS_i4i4i4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetTransformMatrix(UnityEngine.Vector3Int, UnityEngine.Matrix4x4) declare in UnityEngine.Tilemaps.Tilemap
bool w_vtS_i4i4i4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetTileFlags(UnityEngine.Vector3Int, UnityEngine.Tilemaps.TileFlags) declare in UnityEngine.Tilemaps.Tilemap
bool w_vtS_i4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void InsertCells(UnityEngine.Vector3Int, Int32, Int32, Int32) declare in UnityEngine.Tilemaps.Tilemap
bool w_vtS_i4i4i4_i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void RefreshTile(UnityEngine.Vector3Int, UnityEngine.Tilemaps.ITilemap) declare in UnityEngine.Tilemaps.TileBase
bool w_vtS_i4i4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void GetTileData(UnityEngine.Vector3Int, UnityEngine.Tilemaps.ITilemap, UnityEngine.Tilemaps.TileData ByRef) declare in UnityEngine.Tilemaps.Tile
bool w_vtS_i4i4i4_oPS_i4S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_oPS_i4S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Pstruct
    S_i4S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4_* p2 = DataTransfer::GetPointer<S_i4S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_i4S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_i4S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4_));
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, Il2CppObject* p1, struct S_i4S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4_* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    return true;
}

// Void .ctor(UnityEngine.Vector3Int, UnityEngine.Tilemaps.TileBase, UnityEngine.Color, UnityEngine.Matrix4x4) declare in UnityEngine.Tilemaps.TileChangeData
bool w_vtS_i4i4i4_oS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_oS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, Il2CppObject* p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void BoxFill(UnityEngine.Vector3Int, UnityEngine.Tilemaps.TileBase, Int32, Int32, Int32, Int32) declare in UnityEngine.Tilemaps.Tilemap
bool w_vtS_i4i4i4_oi4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_oi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SetAnimationTime(UnityEngine.Vector3Int, Single) declare in UnityEngine.Tilemaps.Tilemap
bool w_vtS_i4i4i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Experimental.Rendering.RenderGraphModule.TextureDesc) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.TextureDesc
bool w_vtS_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__>(apis, env, _sv0);
    S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__ p0 = pp0 ? *pp0 : S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4S_r4r4_oi4i4i4i4i4bbbbi4r4i4bbi4i4sS_bi4r4_bbbS_r4r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void ClampToBounds(UnityEngine.RectInt) declare in UnityEngine.RectInt
bool w_vtS_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void CopyActiveRenderTextureToHeightmap(UnityEngine.RectInt, UnityEngine.Vector2Int, UnityEngine.TerrainHeightmapSyncControl) declare in UnityEngine.TerrainData
bool w_vtS_i4i4i4i4_S_i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4_S_i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4_ p0, struct S_i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int4, Unity.Mathematics.int4) declare in Unity.Mathematics.int4x2
bool w_vtS_i4i4i4i4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int4, Unity.Mathematics.int4, Unity.Mathematics.int4) declare in Unity.Mathematics.int4x3
bool w_vtS_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv2);
    S_i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, struct S_i4i4i4i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.int4, Unity.Mathematics.int4, Unity.Mathematics.int4, Unity.Mathematics.int4) declare in Unity.Mathematics.int4x4
bool w_vtS_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv2);
    S_i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv3);
    S_i4i4i4i4_ p3 = pp3 ? *pp3 : S_i4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, struct S_i4i4i4i4_ p2, struct S_i4i4i4i4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void DirtyHeightmapRegion(UnityEngine.RectInt, UnityEngine.TerrainHeightmapSyncControl) declare in UnityEngine.TerrainData
bool w_vtS_i4i4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[UnityEngine.Vector3], DG.Tweening.Core.DOSetter`1[UnityEngine.Vector3], Single, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Core.PathCore.Path, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.PathPlugin
bool w_vtS_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_oboor4oor4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_oboor4oor4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_>(apis, env, _sv0);
    S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_ p0 = pp0 ? *pp0 : S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, Il2CppObject* p6, Il2CppObject* p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void SetOrientation(DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Tween, DG.Tweening.Plugins.Core.PathCore.Path, Single, UnityEngine.Vector3, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.PathPlugin
bool w_vtS_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_oor4S_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_oor4S_r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_>(apis, env, _sv0);
    S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_ p0 = pp0 ? *pp0 : S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4bS_r4r4r4_or4bS_r4r4r4r4_bobbbS_r4r4r4r4_r4bb_ p0, Il2CppObject* p1, Il2CppObject* p2, float p3, struct S_r4r4r4_ p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void set_bakingOutput(UnityEngine.LightBakingOutput) declare in UnityEngine.Light
bool w_vtS_i4i4i4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4b_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4b_>(apis, env, _sv0);
    S_i4i4i4i4b_ p0 = pp0 ? *pp0 : S_i4i4i4i4b_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4b_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetTextureSettings(UnityEngine.U2D.SpriteAtlas, UnityEditor.U2D.SpriteAtlasTextureSettings) declare in UnityEditor.U2D.SpriteAtlasExtensions
bool w_vtS_i4i4i4i4i4bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4i4bbbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4i4bbbb_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4bbbb_>(apis, env, _sv0);
    S_i4i4i4i4i4bbbb_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4bbbb_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4i4bbbb_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_descriptor(UnityEngine.RenderTextureDescriptor) declare in UnityEngine.RenderTexture
bool w_vtS_i4i4i4i4i4i4i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Setup(UnityEngine.RenderTextureDescriptor, UnityEngine.Rendering.Universal.RenderTargetHandle) declare in UnityEngine.Rendering.Universal.Internal.FinalBlitPass
bool w_vtS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4i4i4pi4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4i4i4pi4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4S_i4i4i4pi4i4i4__* pp1 = DataTransfer::GetPointer<S_i4S_i4i4i4pi4i4i4__>(apis, env, _sv1);
    S_i4S_i4i4i4pi4i4i4__ p1 = pp1 ? *pp1 : S_i4S_i4i4i4pi4i4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0, struct S_i4S_i4i4i4pi4i4i4__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Setup(UnityEngine.RenderTextureDescriptor, UnityEngine.Rendering.RTHandle) declare in UnityEngine.Rendering.Universal.Internal.DepthOnlyPass
bool w_vtS_i4i4i4i4i4i4i4i4i4i4i4i4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4i4i4i4i4i4i4i4i4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_Value(System.Decimal) declare in System.Runtime.Remoting.Metadata.W3cXsd2001.SoapInteger
bool w_vtS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4u8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_depthRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier) declare in UnityEngine.Rendering.RenderTargetBinding
bool w_vtS_i4i4i4pi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Setup(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.Universal.RenderTargetHandle, UnityEngine.Rendering.Universal.Downsampling) declare in UnityEngine.Rendering.Universal.Internal.CopyColorPass
bool w_vtS_i4i4i4pi4i4i4_S_i4S_i4i4i4pi4i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4S_i4i4i4pi4i4i4__i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_i4S_i4i4i4pi4i4i4__* pp1 = DataTransfer::GetPointer<S_i4S_i4i4i4pi4i4i4__>(apis, env, _sv1);
    S_i4S_i4i4i4pi4i4i4__ p1 = pp1 ? *pp1 : S_i4S_i4i4i4pi4i4i4__ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, struct S_i4S_i4i4i4pi4i4i4__ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ConvertTexture(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, struct S_i4i4i4pi4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4_S_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, struct S_i4i4i4pi4i4i4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Vector2, UnityEngine.Vector2, Int32, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4_S_r4r4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4_S_r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, struct S_i4i4i4pi4i4i4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, struct S_i4i4i4pi4i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.CubemapFace) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, struct S_i4i4i4pi4i4i4_ p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.CubemapFace, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, struct S_i4i4i4pi4i4i4_ p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Material) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, struct S_i4i4i4pi4i4i4_ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Material, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, struct S_i4i4i4pi4i4i4_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Material, Int32, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_oi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, struct S_i4i4i4pi4i4i4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SwitchOutOfFastMemory(UnityEngine.Rendering.CommandBuffer, UnityEngine.Rendering.RenderTargetIdentifier, Boolean) declare in UnityEngine.Rendering.CommandBufferExtensions
bool w_vtS_i4i4i4pi4i4i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ConfigureTarget(UnityEngine.Rendering.RenderTargetIdentifier, Boolean, Boolean) declare in UnityEngine.Rendering.AttachmentDescriptor
bool w_vtS_i4i4i4pi4i4i4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.CubemapFace, Int32) declare in UnityEngine.Rendering.RenderTargetIdentifier
bool w_vtS_i4i4i4pi4i4i4_i4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void ConvertTexture(UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.Rendering.RenderTargetIdentifier, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4S_i4i4i4pi4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4S_i4i4i4pi4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv2);
    S_i4i4i4pi4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, int32_t p1, struct S_i4i4i4pi4i4i4_ p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4i4S_i4i4i4pi4i4i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4i4S_i4i4i4pi4i4i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv3);
    S_i4i4i4pi4i4i4_ p3 = pp3 ? *pp3 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, int32_t p1, int32_t p2, struct S_i4i4i4pi4i4i4_ p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.CubemapFace, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void CopyTexture(UnityEngine.Rendering.RenderTargetIdentifier, Int32, Int32, Int32, Int32, Int32, Int32, UnityEngine.Rendering.RenderTargetIdentifier, Int32, Int32, Int32, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4i4i4i4i4i4S_i4i4i4pi4i4i4_i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4i4i4i4i4i4S_i4i4i4pi4i4i4_i4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp7 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp7 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv7);
    S_i4i4i4pi4i4i4_ p7 = pp7 ? *pp7 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, struct S_i4i4i4pi4i4i4_ p7, int32_t p8, int32_t p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void SwitchIntoFastMemory(UnityEngine.Rendering.CommandBuffer, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.FastMemoryFlags, Single, Boolean) declare in UnityEngine.Rendering.CommandBufferExtensions
bool w_vtS_i4i4i4pi4i4i4_i4r4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4r4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, int32_t p1, float p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void ProcessVTFeedback(UnityEngine.Rendering.RenderTargetIdentifier, IntPtr, Int32, Int32, Int32, Int32, Int32, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_pi4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_pi4i4i4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p0, void* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void set_rasterState(UnityEngine.Rendering.RasterState) declare in UnityEngine.Rendering.RenderStateBlock
bool w_vtS_i4i4r4u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4r4u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4r4u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i4r4u1u1u1u1_>(apis, env, _sv0);
    S_i4i4r4u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i4r4u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4r4u1u1u1u1_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_CurrentCheckinBlock(Codice.Client.Commands.CurrentUploadBlock) declare in Codice.Client.GameUI.Checkin.CheckinProgress
bool w_vtS_i4i4si8i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4si8i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4si8i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4si8i4i4_>(apis, env, _sv0);
    S_i4i4si8i4i4_ p0 = pp0 ? *pp0 : S_i4i4si8i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4si8i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_defaultSampleSettings(UnityEditor.AudioImporterSampleSettings) declare in UnityEditor.AudioImporter
bool w_vtS_i4i4u4i4r4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4u4i4r4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4u4i4r4i4b_* pp0 = DataTransfer::GetPointer<S_i4i4u4i4r4i4b_>(apis, env, _sv0);
    S_i4i4u4i4r4i4b_ p0 = pp0 ? *pp0 : S_i4i4u4i4r4i4b_ {};

    typedef void (*FuncToCall)(void*,struct S_i4i4u4i4r4i4b_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace, Int32) declare in UnityEngine.Rendering.RenderTargetIdentifier
bool w_vtS_i4p_Di4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4p_Di4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4p_* pp0 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv0);
    S_i4p_ p0 = pp0 ? *pp0 : S_i4p_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,struct S_i4p_ p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTargetBuffers(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer) declare in UnityEngine.Camera
bool w_vtS_i4p_S_i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4p_S_i4p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4p_* pp0 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv0);
    S_i4p_ p0 = pp0 ? *pp0 : S_i4p_ {};
    // JSValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};

    typedef void (*FuncToCall)(void*,struct S_i4p_ p0, struct S_i4p_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32) declare in UnityEngine.RenderTargetSetup
bool w_vtS_i4p_S_i4p_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4p_S_i4p_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4p_* pp0 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv0);
    S_i4p_ p0 = pp0 ? *pp0 : S_i4p_ {};
    // JSValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4p_ p0, struct S_i4p_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace) declare in UnityEngine.RenderTargetSetup
bool w_vtS_i4p_S_i4p_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4p_S_i4p_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4p_* pp0 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv0);
    S_i4p_ p0 = pp0 ? *pp0 : S_i4p_ {};
    // JSValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_i4p_ p0, struct S_i4p_ p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace, Int32) declare in UnityEngine.RenderTargetSetup
bool w_vtS_i4p_S_i4p_i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4p_S_i4p_i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i4p_* pp0 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv0);
    S_i4p_ p0 = pp0 ? *pp0 : S_i4p_ {};
    // JSValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_i4p_ p0, struct S_i4p_ p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void set_directionX(MinMaxCurve) declare in UnityEngine.ParticleSystemForceField
bool w_vtS_i4r4oor4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4r4oor4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4r4oor4r4_* pp0 = DataTransfer::GetPointer<S_i4r4oor4r4_>(apis, env, _sv0);
    S_i4r4oor4r4_ p0 = pp0 ? *pp0 : S_i4r4oor4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4r4oor4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void LogDebug(Microsoft.Extensions.Logging.ILogger, Microsoft.Extensions.Logging.EventId, System.Exception, System.String, System.Object[]) declare in Microsoft.Extensions.Logging.LoggerExtensions
bool w_vtS_i4s_osVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4s_osVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4s_* pp0 = DataTransfer::GetPointer<S_i4s_>(apis, env, _sv0);
    S_i4s_ p0 = pp0 ? *pp0 : S_i4s_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,struct S_i4s_ p0, Il2CppObject* p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void LogDebug(Microsoft.Extensions.Logging.ILogger, Microsoft.Extensions.Logging.EventId, System.String, System.Object[]) declare in Microsoft.Extensions.Logging.LoggerExtensions
bool w_vtS_i4s_sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4s_sVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4s_* pp0 = DataTransfer::GetPointer<S_i4s_>(apis, env, _sv0);
    S_i4s_ p0 = pp0 ? *pp0 : S_i4s_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,struct S_i4s_ p0, Il2CppString* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void RemoveCondition(UnityEditor.Animations.AnimatorCondition) declare in UnityEditor.Animations.AnimatorTransitionBase
bool w_vtS_i4sr4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4sr4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4sr4_* pp0 = DataTransfer::GetPointer<S_i4sr4_>(apis, env, _sv0);
    S_i4sr4_ p0 = pp0 ? *pp0 : S_i4sr4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4sr4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_cameraMode(CameraMode) declare in UnityEditor.SceneView
bool w_vtS_i4ss_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4ss_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4ss_* pp0 = DataTransfer::GetPointer<S_i4ss_>(apis, env, _sv0);
    S_i4ss_ p0 = pp0 ? *pp0 : S_i4ss_ {};

    typedef void (*FuncToCall)(void*,struct S_i4ss_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_faceInfo(UnityEngine.TextCore.FaceInfo) declare in UnityEngine.TextCore.Text.FontAsset
bool w_vtS_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_color(UnityEngine.Color32) declare in UnityEngine.U2D.SpriteBone
bool w_vtS_i4u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(apis, env, _sv0);
    S_i4u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct S_i4u1u1u1u1_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Color32, TMPro.TMP_Offset) declare in TMPro.HighlightState
bool w_vtS_i4u1u1u1u1_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4u1u1u1u1_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(apis, env, _sv0);
    S_i4u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4u1u1u1u1_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_i4u1u1u1u1_ p0, struct S_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CancelAfter(System.TimeSpan) declare in System.Threading.CancellationTokenSource
bool w_vtS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};

    typedef void (*FuncToCall)(void*,struct S_i8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void AssertTerminatesIn(System.TimeSpan, System.String) declare in JetBrains.Lifetimes.Lifetime
bool w_vtS_i8_Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i8_Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,struct S_i8_ p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void TryEnter(System.TimeSpan, Boolean ByRef) declare in System.Threading.SpinLock
bool w_vtS_i8_Pb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i8_Pb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;

    typedef void (*FuncToCall)(void*,struct S_i8_ p0, bool* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    
    return true;
}

// Void .ctor(System.TimeSpan, System.TimeSpan) declare in System.Configuration.TimeSpanValidator
bool w_vtS_i8_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i8_S_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef void (*FuncToCall)(void*,struct S_i8_ p0, struct S_i8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.TimeSpan, System.TimeSpan, Boolean) declare in System.Configuration.TimeSpanValidator
bool w_vtS_i8_S_i8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i8_S_i8_b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i8_ p0, struct S_i8_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.TimeSpan, System.TimeSpan, Boolean, Int64) declare in System.Configuration.TimeSpanValidator
bool w_vtS_i8_S_i8_bi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i8_S_i8_bi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_i8_ p0, struct S_i8_ p1, bool p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_st_atim(Mono.Unix.Native.Timespec) declare in Mono.Unix.Native.Stat
bool w_vtS_i8i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8i8_* pp0 = DataTransfer::GetPointer<S_i8i8_>(apis, env, _sv0);
    S_i8i8_ p0 = pp0 ? *pp0 : S_i8i8_ {};

    typedef void (*FuncToCall)(void*,struct S_i8i8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(JetBrains.Rd.ExtCreationInfo, Boolean) declare in JetBrains.Rd.ExtCreationInfoEx
bool w_vtS_oN_bS_i8__i8o_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oN_bS_i8__i8o_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_oN_bS_i8__i8o_* pp0 = DataTransfer::GetPointer<S_oN_bS_i8__i8o_>(apis, env, _sv0);
    S_oN_bS_i8__i8o_ p0 = pp0 ? *pp0 : S_oN_bS_i8__i8o_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_oN_bS_i8__i8o_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_Start(Mono.Cecil.Cil.InstructionOffset) declare in Mono.Cecil.Cil.ScopeDebugInformation
bool w_vtS_oN_bi4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oN_bi4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oN_bi4__* pp0 = DataTransfer::GetPointer<S_oN_bi4__>(apis, env, _sv0);
    S_oN_bi4__ p0 = pp0 ? *pp0 : S_oN_bi4__ {};

    typedef void (*FuncToCall)(void*,struct S_oN_bi4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_Item(System.ComponentModel.Design.Serialization.MemberRelationship, System.ComponentModel.Design.Serialization.MemberRelationship) declare in System.ComponentModel.Design.Serialization.MemberRelationshipService
bool w_vtS_oO_S_oO_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oO_S_oO_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oO_* pp0 = DataTransfer::GetPointer<S_oO_>(apis, env, _sv0);
    S_oO_ p0 = pp0 ? *pp0 : S_oO_ {};
    // JSValToCSVal struct
    S_oO_* pp1 = DataTransfer::GetPointer<S_oO_>(apis, env, _sv1);
    S_oO_ p1 = pp1 ? *pp1 : S_oO_ {};

    typedef void (*FuncToCall)(void*,struct S_oO_ p0, struct S_oO_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetBinding) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_oS_i4i4i4pi4i4i4_ooi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oS_i4i4i4pi4i4i4_ooi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oS_i4i4i4pi4i4i4_ooi4i4i4_* pp0 = DataTransfer::GetPointer<S_oS_i4i4i4pi4i4i4_ooi4i4i4_>(apis, env, _sv0);
    S_oS_i4i4i4pi4i4i4_ooi4i4i4_ p0 = pp0 ? *pp0 : S_oS_i4i4i4pi4i4i4_ooi4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_oS_i4i4i4pi4i4i4_ooi4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetBinding, Int32, UnityEngine.CubemapFace, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_oS_i4i4i4pi4i4i4_ooi4i4i4_i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oS_i4i4i4pi4i4i4_ooi4i4i4_i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_oS_i4i4i4pi4i4i4_ooi4i4i4_* pp0 = DataTransfer::GetPointer<S_oS_i4i4i4pi4i4i4_ooi4i4i4_>(apis, env, _sv0);
    S_oS_i4i4i4pi4i4i4_ooi4i4i4_ p0 = pp0 ? *pp0 : S_oS_i4i4i4pi4i4i4_ooi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_oS_i4i4i4pi4i4i4_ooi4i4i4_ p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderTargetSetup) declare in UnityEngine.Rendering.RenderTargetBinding
bool w_vtS_oS_i4p_i4i4i4ooi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oS_i4p_i4i4i4ooi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oS_i4p_i4i4i4ooi4i4_* pp0 = DataTransfer::GetPointer<S_oS_i4p_i4i4i4ooi4i4_>(apis, env, _sv0);
    S_oS_i4p_i4i4i4ooi4i4_ p0 = pp0 ? *pp0 : S_oS_i4p_i4i4i4ooi4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_oS_i4p_i4i4i4ooi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_value(UnityEngine.UIElements.Cursor) declare in UnityEngine.UIElements.StyleCursor
bool w_vtS_oS_r4r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oS_r4r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oS_r4r4_i4_* pp0 = DataTransfer::GetPointer<S_oS_r4r4_i4_>(apis, env, _sv0);
    S_oS_r4r4_i4_ p0 = pp0 ? *pp0 : S_oS_r4r4_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_oS_r4r4_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Wait(System.Threading.CancellationToken) declare in System.Threading.CountdownEvent
bool w_vtS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef void (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(System.Threading.CancellationToken, System.Threading.Tasks.TaskCreationOptions, System.Threading.Tasks.TaskContinuationOptions, System.Threading.Tasks.TaskScheduler) declare in System.Threading.Tasks.TaskFactory
bool w_vtS_o_i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_o_i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_o_ p0, int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Advise(JetBrains.Lifetimes.Lifetime, JetBrains.Rd.Base.IRdWireable) declare in JetBrains.Rd.WireBase
bool w_vtS_o_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_o_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_o_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void PreBind(JetBrains.Lifetimes.Lifetime, JetBrains.Rd.Base.IRdDynamic, System.String) declare in JetBrains.Rd.Base.RdBindableBase
bool w_vtS_o_os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_o_os");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_o_ p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.Net.Sockets.SocketInformation) declare in System.Net.Sockets.Socket
bool w_vtS_oi4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oi4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oi4o_* pp0 = DataTransfer::GetPointer<S_oi4o_>(apis, env, _sv0);
    S_oi4o_ p0 = pp0 ? *pp0 : S_oi4o_ {};

    typedef void (*FuncToCall)(void*,struct S_oi4o_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void GenerateKey(System.Security.Cryptography.ECCurve) declare in System.Security.Cryptography.ECDiffieHellman
bool w_vtS_ooS_oo_oooi4N_bS_s__ooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_ooS_oo_oooi4N_bS_s__ooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_ooS_oo_oooi4N_bS_s__ooo_* pp0 = DataTransfer::GetPointer<S_ooS_oo_oooi4N_bS_s__ooo_>(apis, env, _sv0);
    S_ooS_oo_oooi4N_bS_s__ooo_ p0 = pp0 ? *pp0 : S_ooS_oo_oooi4N_bS_s__ooo_ {};

    typedef void (*FuncToCall)(void*,struct S_ooS_oo_oooi4N_bS_s__ooo_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEditor.Rendering.LightUnitSliderUIDescriptor) declare in UnityEditor.Rendering.LightUnitSlider
bool w_vtS_ooS_r4r4_sssbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_ooS_r4r4_sssbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_ooS_r4r4_sssbb_* pp0 = DataTransfer::GetPointer<S_ooS_r4r4_sssbb_>(apis, env, _sv0);
    S_ooS_r4r4_sssbb_ p0 = pp0 ? *pp0 : S_ooS_r4r4_sssbb_ {};

    typedef void (*FuncToCall)(void*,struct S_ooS_r4r4_sssbb_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_value(UnityEngine.UIElements.FontDefinition) declare in UnityEngine.UIElements.StyleFontDefinition
bool w_vtS_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oo_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oo_* pp0 = DataTransfer::GetPointer<S_oo_>(apis, env, _sv0);
    S_oo_ p0 = pp0 ? *pp0 : S_oo_ {};

    typedef void (*FuncToCall)(void*,struct S_oo_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void NavigateTo(UnityEditor.Timeline.SequenceContext) declare in UnityEditor.Timeline.TimelineNavigator
bool w_vtS_oob_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oob_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oob_* pp0 = DataTransfer::GetPointer<S_oob_>(apis, env, _sv0);
    S_oob_ p0 = pp0 ? *pp0 : S_oob_ {};

    typedef void (*FuncToCall)(void*,struct S_oob_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEditor.Search.SearchColumnEventArgs, UnityEditor.Search.SearchColumnEventArgs, Boolean) declare in UnityEditor.Search.SearchColumnCompareArgs
bool w_vtS_oooObS_r4r4r4r4_bb_S_oooObS_r4r4r4r4_bb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oooObS_r4r4r4r4_bb_S_oooObS_r4r4r4r4_bb_b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_oooObS_r4r4r4r4_bb_* pp0 = DataTransfer::GetPointer<S_oooObS_r4r4r4r4_bb_>(apis, env, _sv0);
    S_oooObS_r4r4r4r4_bb_ p0 = pp0 ? *pp0 : S_oooObS_r4r4r4r4_bb_ {};
    // JSValToCSVal struct
    S_oooObS_r4r4r4r4_bb_* pp1 = DataTransfer::GetPointer<S_oooObS_r4r4r4r4_bb_>(apis, env, _sv1);
    S_oooObS_r4r4r4r4_bb_ p1 = pp1 ? *pp1 : S_oooObS_r4r4r4r4_bb_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_oooObS_r4r4r4r4_bb_ p0, struct S_oooObS_r4r4r4r4_bb_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ImportParameters(Mono.Security.Cryptography.DHParameters) declare in Mono.Security.Cryptography.DiffieHellmanManaged
bool w_vtS_ooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_ooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_ooo_* pp0 = DataTransfer::GetPointer<S_ooo_>(apis, env, _sv0);
    S_ooo_ p0 = pp0 ? *pp0 : S_ooo_ {};

    typedef void (*FuncToCall)(void*,struct S_ooo_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void ResolveDirectoryConflict(PlasticGui.WorkspaceWindow.Merge.DirectoryConflictResolutionData) declare in PlasticGui.WorkspaceWindow.Merge.MergeController
bool w_vtS_oooi4s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oooi4s_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oooi4s_* pp0 = DataTransfer::GetPointer<S_oooi4s_>(apis, env, _sv0);
    S_oooi4s_ p0 = pp0 ? *pp0 : S_oooi4s_ {};

    typedef void (*FuncToCall)(void*,struct S_oooi4s_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_icon(UnityEngine.UIElements.Background) declare in UnityEngine.UIElements.Column
bool w_vtS_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oooo_* pp0 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv0);
    S_oooo_ p0 = pp0 ? *pp0 : S_oooo_ {};

    typedef void (*FuncToCall)(void*,struct S_oooo_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetTrails(Trails) declare in UnityEngine.ParticleSystem
bool w_vtS_oooooi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oooooi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oooooi4i4_* pp0 = DataTransfer::GetPointer<S_oooooi4i4_>(apis, env, _sv0);
    S_oooooi4i4_ p0 = pp0 ? *pp0 : S_oooooi4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_oooooi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void ImportParameters(System.Security.Cryptography.DSAParameters) declare in System.Security.Cryptography.DSACryptoServiceProvider
bool w_vtS_oooooooi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oooooooi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oooooooi4_* pp0 = DataTransfer::GetPointer<S_oooooooi4_>(apis, env, _sv0);
    S_oooooooi4_ p0 = pp0 ? *pp0 : S_oooooooi4_ {};

    typedef void (*FuncToCall)(void*,struct S_oooooooi4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void ImportParameters(System.Security.Cryptography.RSAParameters) declare in System.Security.Cryptography.RSACryptoServiceProvider
bool w_vtS_oooooooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oooooooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oooooooo_* pp0 = DataTransfer::GetPointer<S_oooooooo_>(apis, env, _sv0);
    S_oooooooo_ p0 = pp0 ? *pp0 : S_oooooooo_ {};

    typedef void (*FuncToCall)(void*,struct S_oooooooo_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_pointerCurrentRaycast(UnityEngine.EventSystems.RaycastResult) declare in UnityEngine.EventSystems.PointerEventData
bool w_vtS_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_* pp0 = DataTransfer::GetPointer<S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_>(apis, env, _sv0);
    S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_ p0 = pp0 ? *pp0 : S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_humanDescription(UnityEngine.HumanDescription) declare in UnityEditor.ModelImporter
bool w_vtS_oor4r4r4r4r4r4r4r4sbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oor4r4r4r4r4r4r4r4sbbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oor4r4r4r4r4r4r4r4sbbb_* pp0 = DataTransfer::GetPointer<S_oor4r4r4r4r4r4r4r4sbbb_>(apis, env, _sv0);
    S_oor4r4r4r4r4r4r4r4sbbb_ p0 = pp0 ? *pp0 : S_oor4r4r4r4r4r4r4r4sbbb_ {};

    typedef void (*FuncToCall)(void*,struct S_oor4r4r4r4r4r4r4r4sbbb_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void WriteStartArray(System.Text.Json.JsonEncodedText) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};

    typedef void (*FuncToCall)(void*,struct S_os_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void WriteBase64String(System.Text.Json.JsonEncodedText, System.ReadOnlySpan`1[System.Byte]) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_S_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_os_ p0, struct S_S_p_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteString(System.Text.Json.JsonEncodedText, System.DateTimeOffset) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_S_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_S_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};

    typedef void (*FuncToCall)(void*,struct S_os_ p0, struct S_S_u8_i2_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteString(System.Text.Json.JsonEncodedText, System.Guid) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_S_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct S_os_ p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.Text.Json.JsonEncodedText, System.Decimal) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_S_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};

    typedef void (*FuncToCall)(void*,struct S_os_ p0, struct S_i4i4i4i4u8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteString(System.Text.Json.JsonEncodedText, System.Text.Json.JsonEncodedText) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_S_os_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_S_os_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal struct
    S_os_* pp1 = DataTransfer::GetPointer<S_os_>(apis, env, _sv1);
    S_os_ p1 = pp1 ? *pp1 : S_os_ {};

    typedef void (*FuncToCall)(void*,struct S_os_ p0, struct S_os_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteString(System.Text.Json.JsonEncodedText, System.DateTime) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_S_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};

    typedef void (*FuncToCall)(void*,struct S_os_ p0, struct S_u8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteBoolean(System.Text.Json.JsonEncodedText, Boolean) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_os_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.Text.Json.JsonEncodedText, Int32) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_os_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.Text.Json.JsonEncodedText, Int64) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_os_ p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddRemap(SourceAssetIdentifier, UnityEngine.Object) declare in UnityEditor.AssetImporter
bool w_vtS_os_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_os_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.Text.Json.JsonEncodedText, Single) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_os_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.Text.Json.JsonEncodedText, Double) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_os_ p0, double p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteString(System.Text.Json.JsonEncodedText, System.String) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_os_ p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.Text.Json.JsonEncodedText, UInt32) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_u4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_os_ p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteNumber(System.Text.Json.JsonEncodedText, UInt64) declare in System.Text.Json.Utf8JsonWriter
bool w_vtS_os_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_os_u8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_os_* pp0 = DataTransfer::GetPointer<S_os_>(apis, env, _sv0);
    S_os_ p0 = pp0 ? *pp0 : S_os_ {};
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_os_ p0, uint64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_cullingResults(UnityEngine.Rendering.CullingResults) declare in UnityEngine.Rendering.ShadowDrawingSettings
bool w_vtS_pPvS_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pPvS_pi4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pPvS_pi4i4__* pp0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, _sv0);
    S_pPvS_pi4i4__ p0 = pp0 ? *pp0 : S_pPvS_pi4i4__ {};

    typedef void (*FuncToCall)(void*,struct S_pPvS_pi4i4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void DrawRenderers(UnityEngine.Rendering.CullingResults, UnityEngine.Rendering.DrawingSettings ByRef, UnityEngine.Rendering.FilteringSettings ByRef) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_vtS_pPvS_pi4i4__PS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_PS_S_i4i4_i4u4i4S_i2i2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pPvS_pi4i4__PS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_PS_S_i4i4_i4u4i4S_i2i2__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_pPvS_pi4i4__* pp0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, _sv0);
    S_pPvS_pi4i4__ p0 = pp0 ? *pp0 : S_pPvS_pi4i4__ {};
    // JSValToCSVal Pstruct
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_* p1 = DataTransfer::GetPointer<S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_S_i4i4_i4u4i4S_i2i2__* p2 = DataTransfer::GetPointer<S_S_i4i4_i4u4i4S_i2i2__>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_i4i4_i4u4i4S_i2i2__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_i4i4_i4u4i4S_i2i2__));
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void*,struct S_pPvS_pi4i4__ p0, struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_* p1, struct S_S_i4i4_i4u4i4S_i2i2__* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    return true;
}

// Void DrawRenderers(UnityEngine.Rendering.CullingResults, UnityEngine.Rendering.DrawingSettings ByRef, UnityEngine.Rendering.FilteringSettings ByRef, UnityEngine.Rendering.RenderStateBlock ByRef) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_vtS_pPvS_pi4i4__PS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_PS_S_i4i4_i4u4i4S_i2i2__PS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pPvS_pi4i4__PS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_PS_S_i4i4_i4u4i4S_i2i2__PS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_pPvS_pi4i4__* pp0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, _sv0);
    S_pPvS_pi4i4__ p0 = pp0 ? *pp0 : S_pPvS_pi4i4__ {};
    // JSValToCSVal Pstruct
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_* p1 = DataTransfer::GetPointer<S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_S_i4i4_i4u4i4S_i2i2__* p2 = DataTransfer::GetPointer<S_S_i4i4_i4u4i4S_i2i2__>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_i4i4_i4u4i4S_i2i2__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_i4i4_i4u4i4S_i2i2__));
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_* p3 = DataTransfer::GetPointer<S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_));
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void*,struct S_pPvS_pi4i4__ p0, struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_* p1, struct S_S_i4i4_i4u4i4S_i2i2__* p2, struct S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
            
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    return true;
}

// Void DrawRenderers(UnityEngine.Rendering.CullingResults, UnityEngine.Rendering.DrawingSettings ByRef, UnityEngine.Rendering.FilteringSettings ByRef, Unity.Collections.NativeArray`1[UnityEngine.Rendering.ShaderTagId], Unity.Collections.NativeArray`1[UnityEngine.Rendering.RenderStateBlock]) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_vtS_pPvS_pi4i4__PS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_PS_S_i4i4_i4u4i4S_i2i2__S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pPvS_pi4i4__PS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_PS_S_i4i4_i4u4i4S_i2i2__S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pPvS_pi4i4__* pp0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, _sv0);
    S_pPvS_pi4i4__ p0 = pp0 ? *pp0 : S_pPvS_pi4i4__ {};
    // JSValToCSVal Pstruct
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_* p1 = DataTransfer::GetPointer<S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_S_i4i4_i4u4i4S_i2i2__* p2 = DataTransfer::GetPointer<S_S_i4i4_i4u4i4S_i2i2__>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_i4i4_i4u4i4S_i2i2__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_i4i4_i4u4i4S_i2i2__));
        p2 = &up2;
    }
        
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv3);
    S_Pvi4i4i4S_pi4i4_i4_ p3 = pp3 ? *pp3 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp4 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv4);
    S_Pvi4i4i4S_pi4i4_i4_ p4 = pp4 ? *pp4 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_pPvS_pi4i4__ p0, struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_* p1, struct S_S_i4i4_i4u4i4S_i2i2__* p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, struct S_Pvi4i4i4S_pi4i4_i4_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    return true;
}

// Void DrawRenderers(UnityEngine.Rendering.CullingResults, UnityEngine.Rendering.DrawingSettings ByRef, UnityEngine.Rendering.FilteringSettings ByRef, UnityEngine.Rendering.ShaderTagId, Boolean, Unity.Collections.NativeArray`1[UnityEngine.Rendering.ShaderTagId], Unity.Collections.NativeArray`1[UnityEngine.Rendering.RenderStateBlock]) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_vtS_pPvS_pi4i4__PS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_PS_S_i4i4_i4u4i4S_i2i2__S_i4_bS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pPvS_pi4i4__PS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_PS_S_i4i4_i4u4i4S_i2i2__S_i4_bS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pPvS_pi4i4__* pp0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, _sv0);
    S_pPvS_pi4i4__ p0 = pp0 ? *pp0 : S_pPvS_pi4i4__ {};
    // JSValToCSVal Pstruct
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_* p1 = DataTransfer::GetPointer<S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_S_i4i4_i4u4i4S_i2i2__* p2 = DataTransfer::GetPointer<S_S_i4i4_i4u4i4S_i2i2__>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_i4i4_i4u4i4S_i2i2__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_i4i4_i4u4i4S_i2i2__));
        p2 = &up2;
    }
        
    // JSValToCSVal struct
    S_i4_* pp3 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv3);
    S_i4_ p3 = pp3 ? *pp3 : S_i4_ {};
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp5 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv5);
    S_Pvi4i4i4S_pi4i4_i4_ p5 = pp5 ? *pp5 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp6 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv6);
    S_Pvi4i4i4S_pi4i4_i4_ p6 = pp6 ? *pp6 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_pPvS_pi4i4__ p0, struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_* p1, struct S_S_i4i4_i4u4i4S_i2i2__* p2, struct S_i4_ p3, bool p4, struct S_Pvi4i4i4S_pi4i4_i4_ p5, struct S_Pvi4i4i4S_pi4i4_i4_ p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    return true;
}

// Void .ctor(UnityEngine.Rendering.CullingResults, UnityEngine.Rendering.DrawingSettings, UnityEngine.Rendering.FilteringSettings) declare in UnityEngine.Rendering.RendererListParams
bool w_vtS_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pPvS_pi4i4__* pp0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, _sv0);
    S_pPvS_pi4i4__ p0 = pp0 ? *pp0 : S_pPvS_pi4i4__ {};
    // JSValToCSVal struct
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_>(apis, env, _sv1);
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ {};
    // JSValToCSVal struct
    S_S_i4i4_i4u4i4S_i2i2__* pp2 = DataTransfer::GetPointer<S_S_i4i4_i4u4i4S_i2i2__>(apis, env, _sv2);
    S_S_i4i4_i4u4i4S_i2i2__ p2 = pp2 ? *pp2 : S_S_i4i4_i4u4i4S_i2i2__ {};

    typedef void (*FuncToCall)(void*,struct S_pPvS_pi4i4__ p0, struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ p1, struct S_S_i4i4_i4u4i4S_i2i2__ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.CullingResults, Int32) declare in UnityEngine.Rendering.ShadowDrawingSettings
bool w_vtS_pPvS_pi4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pPvS_pi4i4__i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_pPvS_pi4i4__* pp0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, _sv0);
    S_pPvS_pi4i4__ p0 = pp0 ? *pp0 : S_pPvS_pi4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_pPvS_pi4i4__ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.CullingResults, Int32, UnityEngine.Rendering.BatchCullingProjectionType) declare in UnityEngine.Rendering.ShadowDrawingSettings
bool w_vtS_pPvS_pi4i4__i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pPvS_pi4i4__i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_pPvS_pi4i4__* pp0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, _sv0);
    S_pPvS_pi4i4__ p0 = pp0 ? *pp0 : S_pPvS_pi4i4__ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_pPvS_pi4i4__ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Execute(UnityEngine.Rendering.ScriptableRenderContext, UnityEngine.Rendering.Universal.RenderingData ByRef) declare in UnityEngine.Experimental.Rendering.Universal.RenderObjectsPass
bool w_vtS_pS_pi4i4__PS_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pS_pi4i4__PS_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_pS_pi4i4__* pp0 = DataTransfer::GetPointer<S_pS_pi4i4__>(apis, env, _sv0);
    S_pS_pi4i4__ p0 = pp0 ? *pp0 : S_pS_pi4i4__ {};
    // JSValToCSVal Pstruct
    S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_* p1 = DataTransfer::GetPointer<S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,struct S_pS_pi4i4__ p0, struct S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void BeginSample(Unity.Profiling.ProfilerMarker) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_p_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};

    typedef void (*FuncToCall)(void*,struct S_p_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Profiling.ProfilerMarker, Int32, Unity.Profiling.ProfilerRecorderOptions) declare in Unity.Profiling.ProfilerRecorder
bool w_vtS_p_Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_p_Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,struct S_p_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.RuntimeArgumentHandle, Void*) declare in System.ArgIterator
bool w_vtS_p_Pv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_p_Pv");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_p_ p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Experimental.AI.NavMeshWorld, Unity.Collections.Allocator, Int32) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_vtS_p_i4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_p_i4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,struct S_p_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void WaitOnAsyncGraphicsFence(UnityEngine.Rendering.GraphicsFence) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_pi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pi4i4_* pp0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, _sv0);
    S_pi4i4_ p0 = pp0 ? *pp0 : S_pi4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_pi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void WaitOnAsyncGraphicsFence(UnityEngine.Rendering.GraphicsFence, UnityEngine.Rendering.SynchronisationStage) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_pi4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pi4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_pi4i4_* pp0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, _sv0);
    S_pi4i4_ p0 = pp0 ? *pp0 : S_pi4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_pi4i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Invoke(Puerts.JSCallInfo) declare in Puerts.OverloadReflectionWrap
bool w_vtS_pppi4ooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pppi4ooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pppi4ooo_* pp0 = DataTransfer::GetPointer<S_pppi4ooo_>(apis, env, _sv0);
    S_pppi4ooo_ p0 = pp0 ? *pp0 : S_pppi4ooo_ {};

    typedef void (*FuncToCall)(void*,struct S_pppi4ooo_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void FillByRefParameters(Puerts.JSCallInfo, System.Object[]) declare in Puerts.Parameters
bool w_vtS_pppi4ooo_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pppi4ooo_Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_pppi4ooo_* pp0 = DataTransfer::GetPointer<S_pppi4ooo_>(apis, env, _sv0);
    S_pppi4ooo_ p0 = pp0 ? *pp0 : S_pppi4ooo_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef void (*FuncToCall)(void*,struct S_pppi4ooo_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetHandle(UnityEngine.Playables.PlayableHandle) declare in UnityEngine.Animations.AnimatorControllerPlayable
bool w_vtS_pu4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};

    typedef void (*FuncToCall)(void*,struct S_pu4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Compile(UnityEngine.Playables.PlayableGraph, UnityEngine.Playables.Playable, System.Collections.Generic.IEnumerable`1[UnityEngine.Timeline.TrackAsset], UnityEngine.GameObject, Boolean, Boolean) declare in UnityEngine.Timeline.TimelinePlayable
bool w_vtS_pu4_S_S_pu4__oobb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pu4_S_S_pu4__oobb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal struct
    S_S_pu4__* pp1 = DataTransfer::GetPointer<S_S_pu4__>(apis, env, _sv1);
    S_S_pu4__ p1 = pp1 ? *pp1 : S_S_pu4__ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,struct S_pu4_ p0, struct S_S_pu4__ p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawRendererList(UnityEngine.Rendering.RendererList) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_pu4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pu4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4u4u4_* pp0 = DataTransfer::GetPointer<S_pu4u4u4_>(apis, env, _sv0);
    S_pu4u4u4_ p0 = pp0 ? *pp0 : S_pu4u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_pu4u4u4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void EvaluateAndApply(DG.Tweening.Plugins.CircleOptions, DG.Tweening.Tween, Boolean, DG.Tweening.Core.DOGetter`1[UnityEngine.Vector2], DG.Tweening.Core.DOSetter`1[UnityEngine.Vector2], Single, UnityEngine.Vector2, UnityEngine.Vector2, Single, Boolean, Int32, DG.Tweening.Core.Enums.UpdateNotice) declare in DG.Tweening.Plugins.CirclePlugin
bool w_vtS_r4bbS_r4r4_r4r4b_oboor4S_r4r4_S_r4r4_r4bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4bbS_r4r4_r4r4b_oboor4S_r4r4_S_r4r4_r4bi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal struct
    S_r4bbS_r4r4_r4r4b_* pp0 = DataTransfer::GetPointer<S_r4bbS_r4r4_r4r4b_>(apis, env, _sv0);
    S_r4bbS_r4r4_r4r4b_ p0 = pp0 ? *pp0 : S_r4bbS_r4r4_r4r4b_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv6);
    S_r4r4_ p6 = pp6 ? *pp6 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv7);
    S_r4r4_ p7 = pp7 ? *pp7 : S_r4r4_ {};
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,struct S_r4bbS_r4r4_r4r4b_ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, float p5, struct S_r4r4_ p6, struct S_r4r4_ p7, float p8, bool p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void set_x(UnityEngine.UIElements.Length) declare in UnityEngine.UIElements.BackgroundSize
bool w_vtS_r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4i4_* pp0 = DataTransfer::GetPointer<S_r4i4_>(apis, env, _sv0);
    S_r4i4_ p0 = pp0 ? *pp0 : S_r4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.UIElements.Length, UnityEngine.UIElements.Length) declare in UnityEngine.UIElements.BackgroundSize
bool w_vtS_r4i4_S_r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4i4_S_r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4i4_* pp0 = DataTransfer::GetPointer<S_r4i4_>(apis, env, _sv0);
    S_r4i4_ p0 = pp0 ? *pp0 : S_r4i4_ {};
    // JSValToCSVal struct
    S_r4i4_* pp1 = DataTransfer::GetPointer<S_r4i4_>(apis, env, _sv1);
    S_r4i4_ p1 = pp1 ? *pp1 : S_r4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4i4_ p0, struct S_r4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.UIElements.Length, UnityEngine.UIElements.Length, Single) declare in UnityEngine.UIElements.TransformOrigin
bool w_vtS_r4i4_S_r4i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4i4_S_r4i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4i4_* pp0 = DataTransfer::GetPointer<S_r4i4_>(apis, env, _sv0);
    S_r4i4_ p0 = pp0 ? *pp0 : S_r4i4_ {};
    // JSValToCSVal struct
    S_r4i4_* pp1 = DataTransfer::GetPointer<S_r4i4_>(apis, env, _sv1);
    S_r4i4_ p1 = pp1 ? *pp1 : S_r4i4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4i4_ p0, struct S_r4i4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_curvature(UnityEngine.Vector2) declare in UnityEngine.Camera
bool w_vtS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector2, Boolean) declare in UnityEngine.Rendering.Vector2Parameter
bool w_vtS_r4r4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector2, Boolean, Boolean) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.TextureDesc
bool w_vtS_r4r4_DbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_DbDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector2, System.Action) declare in UnityEditor.Experimental.GraphView.Resizer
bool w_vtS_r4r4_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector2, Single, Single) declare in UnityEditor.Experimental.GraphView.SearchWindowContext
bool w_vtS_r4r4_Dr4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_Dr4Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddForceAtPosition(UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.Rigidbody2D
bool w_vtS_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void BezierCurveTo(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.UIElements.Painter2D
bool w_vtS_r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_r4r4_S_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.float2, Unity.Mathematics.float2, Unity.Mathematics.float2, Unity.Mathematics.float2) declare in Unity.Mathematics.float2x4
bool w_vtS_r4r4_S_r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_r4r4_S_r4r4_S_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void AddForceAtPosition(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.ForceMode2D) declare in UnityEngine.Rigidbody2D
bool w_vtS_r4r4_S_r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ArcTo(UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in UnityEngine.UIElements.Painter2D
bool w_vtS_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddForce(UnityEngine.Vector2, UnityEngine.ForceMode2D) declare in UnityEngine.Rigidbody2D
bool w_vtS_r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Numerics.Vector2, Single) declare in System.Numerics.Vector3
bool w_vtS_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Arc(UnityEngine.Vector2, Single, UnityEngine.UIElements.Angle, UnityEngine.UIElements.Angle, UnityEngine.UIElements.ArcDirection) declare in UnityEngine.UIElements.Painter2D
bool w_vtS_r4r4_r4S_r4i4_S_r4i4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_r4S_r4i4_S_r4i4_Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4i4_* pp2 = DataTransfer::GetPointer<S_r4i4_>(apis, env, _sv2);
    S_r4i4_ p2 = pp2 ? *pp2 : S_r4i4_ {};
    // JSValToCSVal struct
    S_r4i4_* pp3 = DataTransfer::GetPointer<S_r4i4_>(apis, env, _sv3);
    S_r4i4_ p3 = pp3 ? *pp3 : S_r4i4_ {};
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, float p1, struct S_r4i4_ p2, struct S_r4i4_ p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Update(UnityEngine.Vector2, Single, Single) declare in UnityEditor.Rendering.LookDev.ComparisonGizmoState
bool w_vtS_r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector2, Single, Single, Boolean) declare in UnityEngine.Rendering.FloatRangeParameter
bool w_vtS_r4r4_r4r4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_r4r4Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p0, float p1, float p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_motor(UnityEngine.JointMotor) declare in UnityEngine.HingeJoint
bool w_vtS_r4r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4i4_* pp0 = DataTransfer::GetPointer<S_r4r4i4_>(apis, env, _sv0);
    S_r4r4i4_ p0 = pp0 ? *pp0 : S_r4r4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void StartVideoModeAsync(UnityEngine.Windows.WebCam.CameraParameters, AudioState, OnVideoModeStartedCallback) declare in UnityEngine.Windows.WebCam.VideoCapture
bool w_vtS_r4r4i4i4i4_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4i4i4i4_i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4i4i4i4_* pp0 = DataTransfer::GetPointer<S_r4r4i4i4i4_>(apis, env, _sv0);
    S_r4r4i4i4i4_ p0 = pp0 ? *pp0 : S_r4r4i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4i4i4i4_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void StartPhotoModeAsync(UnityEngine.Windows.WebCam.CameraParameters, OnPhotoModeStartedCallback) declare in UnityEngine.Windows.WebCam.PhotoCapture
bool w_vtS_r4r4i4i4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4i4i4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4i4i4i4_* pp0 = DataTransfer::GetPointer<S_r4r4i4i4i4_>(apis, env, _sv0);
    S_r4r4i4i4i4_ p0 = pp0 ? *pp0 : S_r4r4i4i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4i4i4i4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_destination(UnityEngine.Vector3) declare in UnityEngine.AI.NavMeshAgent
bool w_vtS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, Boolean) declare in UnityEngine.Rendering.Vector3Parameter
bool w_vtS_r4r4r4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CalculateInterpolatedLightAndOcclusionProbe(UnityEngine.Vector3, Int32 ByRef, UnityEngine.Rendering.SphericalHarmonicsL2 ByRef, UnityEngine.Vector4 ByRef) declare in UnityEngine.LightProbesQuery
bool w_vtS_r4r4r4_Pi4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_Pi4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_r4r4r4r4_));
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, int32_t* p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p2, struct S_r4r4r4r4_* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
            
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    return true;
}

// Void AddVert(UnityEngine.Vector3, UnityEngine.Color32, UnityEngine.Vector4) declare in UnityEngine.UI.VertexHelper
bool w_vtS_r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(apis, env, _sv1);
    S_i4u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4u1u1u1u1_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_i4u1u1u1u1_ p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddVert(UnityEngine.Vector3, UnityEngine.Color32, UnityEngine.Vector4, UnityEngine.Vector4, UnityEngine.Vector3, UnityEngine.Vector4) declare in UnityEngine.UI.VertexHelper
bool w_vtS_r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(apis, env, _sv1);
    S_i4u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4u1u1u1u1_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_i4u1u1u1u1_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4_ p4, struct S_r4r4r4r4_ p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void AddVert(UnityEngine.Vector3, UnityEngine.Color32, UnityEngine.Vector4, UnityEngine.Vector4, UnityEngine.Vector4, UnityEngine.Vector4, UnityEngine.Vector3, UnityEngine.Vector4) declare in UnityEngine.UI.VertexHelper
bool w_vtS_r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_i4u1u1u1u1_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(apis, env, _sv1);
    S_i4u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4u1u1u1u1_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv6);
    S_r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv7);
    S_r4r4r4r4_ p7 = pp7 ? *pp7 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_i4u1u1u1u1_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4r4_ p4, struct S_r4r4r4r4_ p5, struct S_r4r4r4_ p6, struct S_r4r4r4r4_ p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void SetMinMax(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Bounds
bool w_vtS_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32, Int32) declare in UnityEngine.RaycastCommand
bool w_vtS_r4r4r4_S_r4r4r4_Dr4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_Dr4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.QueryParameters, Single) declare in UnityEngine.RaycastCommand
bool w_vtS_r4r4r4_S_r4r4r4_S_i4bi4b_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_S_i4bi4b_Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (js_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_i4bi4b_* pp2 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv2);
    S_i4bi4b_ p2 = pp2 ? *pp2 : S_i4bi4b_ {};
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_i4bi4b_ p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Set3Points(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Plane
bool w_vtS_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.float3, Unity.Mathematics.float3, Unity.Mathematics.float3, Unity.Mathematics.float3) declare in Unity.Mathematics.float3x4
bool w_vtS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.QueryParameters) declare in UnityEngine.OverlapBoxCommand
bool w_vtS_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4bi4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4bi4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_i4bi4b_* pp3 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv3);
    S_i4bi4b_ p3 = pp3 ? *pp3 : S_i4bi4b_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_i4bi4b_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3, Single, Int32) declare in UnityEngine.BoxcastCommand
bool w_vtS_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_Dr4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_Dr4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3, UnityEngine.QueryParameters, Single) declare in UnityEngine.BoxcastCommand
bool w_vtS_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_S_i4bi4b_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_S_i4bi4b_Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (js_args_len > 5 && !converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_i4bi4b_* pp4 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv4);
    S_i4bi4b_ p4 = pp4 ? *pp4 : S_i4bi4b_ {};
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_i4bi4b_ p4, float p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void AddForceAtPosition(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.ForceMode) declare in UnityEngine.ArticulationBody
bool w_vtS_r4r4r4_S_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void RotateAround(UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.QueryParameters) declare in UnityEngine.OverlapCapsuleCommand
bool w_vtS_r4r4r4_S_r4r4r4_r4S_i4bi4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_r4S_i4bi4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_i4bi4b_* pp3 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv3);
    S_i4bi4b_ p3 = pp3 ? *pp3 : S_i4bi4b_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_i4bi4b_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32) declare in UnityEngine.CapsulecastCommand
bool w_vtS_r4r4r4_S_r4r4r4_r4S_r4r4r4_Dr4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_r4S_r4r4r4_Dr4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, float p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.QueryParameters, Single) declare in UnityEngine.CapsulecastCommand
bool w_vtS_r4r4r4_S_r4r4r4_r4S_r4r4r4_S_i4bi4b_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_r4S_r4r4r4_S_i4bi4b_Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (js_args_len > 5 && !converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_i4bi4b_* pp4 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv4);
    S_i4bi4b_ p4 = pp4 ? *pp4 : S_i4bi4b_ {};
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, struct S_i4bi4b_ p4, float p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Emit(UnityEngine.Vector3, UnityEngine.Vector3, Single, Single, UnityEngine.Color32) declare in UnityEngine.ParticleSystem
bool w_vtS_r4r4r4_S_r4r4r4_r4r4S_i4u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_r4r4S_i4u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_i4u1u1u1u1_* pp4 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(apis, env, _sv4);
    S_i4u1u1u1u1_ p4 = pp4 ? *pp4 : S_i4u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, float p3, struct S_i4u1u1u1u1_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetPositionAndRotation(UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetTRS(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3) declare in UnityEngine.Matrix4x4
bool w_vtS_r4r4r4_S_r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void MatchTarget(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.AvatarTarget, UnityEngine.MatchTargetWeightMask, Single) declare in UnityEngine.Animator
bool w_vtS_r4r4r4_S_r4r4r4r4_i4S_S_r4r4r4_r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4r4_i4S_S_r4r4r4_r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp3 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv3);
    S_S_r4r4r4_r4_ p3 = pp3 ? *pp3 : S_S_r4r4r4_r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, int32_t p2, struct S_S_r4r4r4_r4_ p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void MatchTarget(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.AvatarTarget, UnityEngine.MatchTargetWeightMask, Single, Single) declare in UnityEngine.Animator
bool w_vtS_r4r4r4_S_r4r4r4r4_i4S_S_r4r4r4_r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4r4_i4S_S_r4r4r4_r4_r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp3 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv3);
    S_S_r4r4r4_r4_ p3 = pp3 ? *pp3 : S_S_r4r4r4_r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, int32_t p2, struct S_S_r4r4r4_r4_ p3, float p4, float p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void MatchTarget(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.AvatarTarget, UnityEngine.MatchTargetWeightMask, Single, Single, Boolean) declare in UnityEngine.Animator
bool w_vtS_r4r4r4_S_r4r4r4r4_i4S_S_r4r4r4_r4_r4r4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4r4_i4S_S_r4r4r4_r4_r4r4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp3 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv3);
    S_S_r4r4r4_r4_ p3 = pp3 ? *pp3 : S_S_r4r4r4_r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, int32_t p2, struct S_S_r4r4r4_r4_ p3, float p4, float p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void AddDirectionalLight(UnityEngine.Vector3, UnityEngine.Color, Single) declare in UnityEngine.Rendering.SphericalHarmonicsL2
bool w_vtS_r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void LookAt(UnityEngine.Vector3, UnityEngine.Quaternion, Single, Boolean) declare in UnityEditor.SceneView
bool w_vtS_r4r4r4_S_r4r4r4r4_r4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4r4_r4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, float p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void LookAt(UnityEngine.Vector3, UnityEngine.Quaternion, Single, Boolean, Boolean) declare in UnityEditor.SceneView
bool w_vtS_r4r4r4_S_r4r4r4r4_r4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4r4_r4bb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, float p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Translate(UnityEngine.Vector3, UnityEngine.Space) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, Int32, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3) declare in UnityEngine.ClosestPointCommand
bool w_vtS_r4r4r4_i4S_r4r4r4_S_r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_i4S_r4r4r4_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, int32_t p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void ApplyInputDeviceDelta(UnityEngine.Vector3, UnityEngine.UIElements.DeltaSpeed, Int32) declare in UnityEngine.UIElements.IntegerField
bool w_vtS_r4r4r4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ApplyInputDeviceDelta(UnityEngine.Vector3, UnityEngine.UIElements.DeltaSpeed, Int64) declare in UnityEngine.UIElements.LongField
bool w_vtS_r4r4r4_i4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_i4i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, int32_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ApplyInputDeviceDelta(UnityEngine.Vector3, UnityEngine.UIElements.DeltaSpeed, Single) declare in UnityEngine.UIElements.FloatField
bool w_vtS_r4r4r4_i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_i4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ApplyInputDeviceDelta(UnityEngine.Vector3, UnityEngine.UIElements.DeltaSpeed, Double) declare in UnityEngine.UIElements.DoubleField
bool w_vtS_r4r4r4_i4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_i4r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, int32_t p1, double p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ApplyInputDeviceDelta(UnityEngine.Vector3, UnityEngine.UIElements.DeltaSpeed, System.String) declare in UnityEditor.ShaderGraph.Drawing.IdentifierField
bool w_vtS_r4r4r4_i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_i4s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, int32_t p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ApplyInputDeviceDelta(UnityEngine.Vector3, UnityEngine.UIElements.DeltaSpeed, UInt32) declare in UnityEngine.UIElements.UnsignedIntegerField
bool w_vtS_r4r4r4_i4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_i4u4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, int32_t p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ApplyInputDeviceDelta(UnityEngine.Vector3, UnityEngine.UIElements.DeltaSpeed, UInt64) declare in UnityEngine.UIElements.UnsignedLongField
bool w_vtS_r4r4r4_i4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_i4u8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, int32_t p1, uint64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Translate(UnityEngine.Vector3, UnityEngine.Transform) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, UnityEngine.Collider, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3) declare in UnityEngine.ClosestPointCommand
bool w_vtS_r4r4r4_oS_r4r4r4_S_r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_oS_r4r4r4_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void GetInterpolatedLightProbe(UnityEngine.Vector3, UnityEngine.Renderer, Single[]) declare in UnityEngine.LightProbes
bool w_vtS_r4r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetAxisAngle(UnityEngine.Vector3, Single) declare in UnityEngine.Quaternion
bool w_vtS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, Single, UnityEngine.QueryParameters) declare in UnityEngine.OverlapSphereCommand
bool w_vtS_r4r4r4_r4S_i4bi4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_r4S_i4bi4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4bi4b_* pp2 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv2);
    S_i4bi4b_ p2 = pp2 ? *pp2 : S_i4bi4b_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, float p1, struct S_i4bi4b_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32) declare in UnityEngine.SpherecastCommand
bool w_vtS_r4r4r4_r4S_r4r4r4_Dr4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_r4S_r4r4r4_Dr4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (js_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, float p1, struct S_r4r4r4_ p2, float p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.QueryParameters, Single) declare in UnityEngine.SpherecastCommand
bool w_vtS_r4r4r4_r4S_r4r4r4_S_i4bi4b_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_r4S_r4r4r4_S_i4bi4b_Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_i4bi4b_* pp3 = DataTransfer::GetPointer<S_i4bi4b_>(apis, env, _sv3);
    S_i4bi4b_ p3 = pp3 ? *pp3 : S_i4bi4b_ {};
    // JSValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, float p1, struct S_r4r4r4_ p2, struct S_i4bi4b_ p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Rotate(UnityEngine.Vector3, Single, UnityEngine.Space) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, float p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, Single, Single) declare in TreeEditor.TreeAOSphere
bool w_vtS_r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPlaybackState(PlaybackState) declare in UnityEngine.ParticleSystem
bool w_vtS_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__* pp0 = DataTransfer::GetPointer<S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__>(apis, env, _sv0);
    S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__ p0 = pp0 ? *pp0 : S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_xDrive(UnityEngine.JointDrive) declare in UnityEngine.ConfigurableJoint
bool w_vtS_r4r4r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4i4_* pp0 = DataTransfer::GetPointer<S_r4r4r4i4_>(apis, env, _sv0);
    S_r4r4r4i4_ p0 = pp0 ? *pp0 : S_r4r4r4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_rotation(UnityEngine.Quaternion) declare in UnityEngine.AI.NavMeshData
bool w_vtS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Color, Boolean) declare in UnityEngine.Rendering.ColorParameter
bool w_vtS_r4r4r4r4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Color, UnityEditor.Rendering.HierarchicalSphere) declare in UnityEditor.Rendering.HierarchicalSphere
bool w_vtS_r4r4r4r4_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void DropDown(UnityEngine.Rect, UnityEngine.UIElements.VisualElement, Boolean) declare in UnityEngine.UIElements.GenericDropdownMenu
bool w_vtS_r4r4r4r4_DoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_DoDb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Color, UnityEngine.Color[], UnityEditor.Rendering.HierarchicalBox) declare in UnityEditor.Rendering.HierarchicalBox
bool w_vtS_r4r4r4r4_DoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_DoDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ConfigureClear(UnityEngine.Color, Single, UInt32) declare in UnityEngine.Rendering.AttachmentDescriptor
bool w_vtS_r4r4r4r4_Dr4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_Dr4Du4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, float p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ShowAsDropDown(UnityEngine.Rect, UnityEngine.Vector2) declare in UnityEditor.EditorWindow
bool w_vtS_r4r4r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_S_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, struct S_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetColors(UnityEngine.Color, UnityEngine.Color) declare in UnityEngine.LineRenderer
bool w_vtS_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.float4, Unity.Mathematics.float4, Unity.Mathematics.float4) declare in Unity.Mathematics.float4x3
bool w_vtS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector4, UnityEngine.Vector4, UnityEngine.Vector4, UnityEngine.Vector4) declare in UnityEngine.Matrix4x4
bool w_vtS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Interp(UnityEngine.Color, UnityEngine.Color, Single) declare in UnityEngine.Rendering.ColorParameter
bool w_vtS_r4r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_S_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rect, UnityEngine.Rect, Double, Double) declare in UnityEditor.Timeline.MarkerOverlayRegion
bool w_vtS_r4r4r4r4_S_r4r4r4r4_r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_S_r4r4r4r4_r8r8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, double p2, double p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rect, UnityEngine.Rect, Double, Double, Single) declare in UnityEditor.Timeline.MarkerOverlayRegion
bool w_vtS_r4r4r4r4_S_r4r4r4r4_r8r8r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_S_r4r4r4r4_r8r8r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, double p2, double p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Cull(UnityEngine.Rect, Boolean) declare in UnityEngine.UI.MaskableGraphic
bool w_vtS_r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Color, Boolean, Boolean, Boolean, Boolean) declare in UnityEngine.Rendering.ColorParameter
bool w_vtS_r4r4r4r4_bbbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_bbbDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, bool p1, bool p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Draw(UnityEngine.Rect, Boolean, Boolean, Boolean, Boolean) declare in UnityEngine.GUIStyle
bool w_vtS_r4r4r4r4_bbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_bbbb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, bool p1, bool p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void LightmapEmissionProperty(UnityEngine.Rect, Int32) declare in UnityEditor.MaterialEditor
bool w_vtS_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ReadPixels(UnityEngine.Rect, Int32, Int32) declare in UnityEngine.Texture2D
bool w_vtS_r4r4r4r4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ReadPixels(UnityEngine.Rect, Int32, Int32, Boolean) declare in UnityEngine.Texture2D
bool w_vtS_r4r4r4r4_i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_i4i4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, int32_t p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void OnPreviewGUI(UnityEngine.Rect, UnityEngine.GUIStyle) declare in UnityEditor.ObjectPreview
bool w_vtS_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Draw(UnityEngine.Rect, UnityEditor.SerializedProperty, Single ByRef) declare in UnityEditor.Rendering.LightUnitSlider
bool w_vtS_r4r4r4r4_oPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_oPr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, float* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<float>::toScript(apis, env, *p2));
    
    return true;
}

// Void Draw(UnityEngine.Rect, UnityEngine.Texture, Boolean, Boolean, Boolean, Boolean) declare in UnityEngine.GUIStyle
bool w_vtS_r4r4r4r4_obbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_obbbb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, bool p2, bool p3, bool p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Draw(UnityEngine.Rect, UnityEngine.GUIContent, Int32) declare in UnityEngine.GUIStyle
bool w_vtS_r4r4r4r4_oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Draw(UnityEngine.Rect, UnityEngine.GUIContent, Int32, Boolean) declare in UnityEngine.GUIStyle
bool w_vtS_r4r4r4r4_oi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_oi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Draw(UnityEngine.Rect, UnityEngine.GUIContent, Int32, Boolean, Boolean) declare in UnityEngine.GUIStyle
bool w_vtS_r4r4r4r4_oi4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_oi4bb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawCursor(UnityEngine.Rect, UnityEngine.GUIContent, Int32, Int32) declare in UnityEngine.GUIStyle
bool w_vtS_r4r4r4r4_oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_oi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawWithTextSelection(UnityEngine.Rect, UnityEngine.GUIContent, Int32, Int32, Int32) declare in UnityEngine.GUIStyle
bool w_vtS_r4r4r4r4_oi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_oi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void OnGUI(UnityEngine.Rect, UnityEditor.SerializedProperty, UnityEngine.GUIContent) declare in UnityEditorInternal.MinMaxCurvePropertyDrawer
bool w_vtS_r4r4r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ShaderProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, UnityEngine.GUIContent, Int32) declare in UnityEditor.MaterialEditor
bool w_vtS_r4r4r4r4_ooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_ooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void OnGUI(UnityEngine.Rect, UnityEditor.MaterialProperty, UnityEngine.GUIContent, UnityEditor.MaterialEditor) declare in UnityEditor.MaterialPropertyDrawer
bool w_vtS_r4r4r4r4_ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_ooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void ShaderProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, System.String) declare in UnityEditor.MaterialEditor
bool w_vtS_r4r4r4r4_os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_os");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ShaderProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, System.String, Int32) declare in UnityEditor.MaterialEditor
bool w_vtS_r4r4r4r4_osi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_osi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppString* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void OnGUI(UnityEngine.Rect, UnityEditor.MaterialProperty, System.String, UnityEditor.MaterialEditor) declare in UnityEditor.MaterialPropertyDrawer
bool w_vtS_r4r4r4r4_oso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_oso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetColorWithoutRadiusHandle(UnityEngine.Color, Single) declare in UnityEditor.IMGUI.Controls.ArcHandle
bool w_vtS_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CrossFadeColor(UnityEngine.Color, Single, Boolean, Boolean) declare in UnityEngine.UI.Graphic
bool w_vtS_r4r4r4r4_r4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_r4bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, float p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void CrossFadeColor(UnityEngine.Color, Single, Boolean, Boolean, Boolean) declare in UnityEngine.UI.Graphic
bool w_vtS_r4r4r4r4_r4bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_r4bbb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, float p1, bool p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void CalculateFrustumCorners(UnityEngine.Rect, Single, MonoOrStereoscopicEye, UnityEngine.Vector3[]) declare in UnityEngine.Camera
bool w_vtS_r4r4r4r4_r4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_r4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, float p1, int32_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rect, Double, Double) declare in UnityEditor.Timeline.ClipBackgroundRegion
bool w_vtS_r4r4r4r4_r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_r8r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, double p1, double p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Draw(UnityEngine.Rect, System.String, Boolean, Boolean, Boolean, Boolean) declare in UnityEngine.GUIStyle
bool w_vtS_r4r4r4r4_sbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_sbbbb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppString* p1, bool p2, bool p3, bool p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Slot(UnityEngine.Rect, System.String, UnityEditor.Graphs.Slot, Boolean, Boolean, Boolean, UnityEngine.GUIStyle) declare in UnityEditor.Graphs.GraphGUI
bool w_vtS_r4r4r4r4_sobbbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_sobbbo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppObject* p2, bool p3, bool p4, bool p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void set_metrics(UnityEngine.TextCore.GlyphMetrics) declare in UnityEngine.TextCore.Glyph
bool w_vtS_r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(System.Numerics.Matrix3x2) declare in System.Numerics.Matrix4x4
bool w_vtS_r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_limits(UnityEngine.JointLimits) declare in UnityEngine.HingeJoint
bool w_vtS_r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_xDrive(UnityEngine.ArticulationDrive) declare in UnityEngine.ArticulationBody
bool w_vtS_r4r4r4r4r4r4r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4i4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4i4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4i4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_transform(UnityEngine.Matrix4x4) declare in UnityEngine.AI.NavMeshBuildSource
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void PreviewMesh(UnityEngine.Matrix4x4, UnityEngine.Material[] ByRef) declare in TreeEditor.TreeData
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, Il2CppObject** p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    return true;
}

// Void SetStereoViewMatrices(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4) declare in UnityEngine.Camera
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void DrawProcedural(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawProcedural(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, Int32, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawProcedural(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, Int32, Int32, UnityEngine.MaterialPropertyBlock) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawProceduralIndirect(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, UnityEngine.ComputeBuffer) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawProceduralIndirect(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, UnityEngine.ComputeBuffer, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawProceduralIndirect(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, UnityEngine.ComputeBuffer, Int32, UnityEngine.MaterialPropertyBlock) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, int32_t p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void UpdateMesh(UnityEngine.Matrix4x4, System.Collections.Generic.List`1[TreeEditor.TreeMaterial], System.Collections.Generic.List`1[TreeEditor.TreeVertex], System.Collections.Generic.List`1[TreeEditor.TreeTriangle], System.Collections.Generic.List`1[TreeEditor.TreeAOSphere], Int32, Single, Single) declare in TreeEditor.TreeData
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ooooi4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ooooi4r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, int32_t p5, float p6, float p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.SphericalHarmonicsL2) declare in UnityEngine.Rendering.SHCoefficients
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.SphericalHarmonicsL2, UnityEngine.Vector4) declare in UnityEngine.Rendering.SHCoefficients
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_xy(Unity.Mathematics.double2) declare in Unity.Mathematics.double2
bool w_vtS_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};

    typedef void (*FuncToCall)(void*,struct S_r8r8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.double2x2
bool w_vtS_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8_S_r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef void (*FuncToCall)(void*,struct S_r8r8_ p0, struct S_r8r8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double2, Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.double2x3
bool w_vtS_r8r8_S_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8_S_r8r8_S_r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv2);
    S_r8r8_ p2 = pp2 ? *pp2 : S_r8r8_ {};

    typedef void (*FuncToCall)(void*,struct S_r8r8_ p0, struct S_r8r8_ p1, struct S_r8r8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double2, Unity.Mathematics.double2, Unity.Mathematics.double2, Unity.Mathematics.double2) declare in Unity.Mathematics.double2x4
bool w_vtS_r8r8_S_r8r8_S_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8_S_r8r8_S_r8r8_S_r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv2);
    S_r8r8_ p2 = pp2 ? *pp2 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp3 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv3);
    S_r8r8_ p3 = pp3 ? *pp3 : S_r8r8_ {};

    typedef void (*FuncToCall)(void*,struct S_r8r8_ p0, struct S_r8r8_ p1, struct S_r8r8_ p2, struct S_r8r8_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double2, Double) declare in Unity.Mathematics.double3
bool w_vtS_r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8_r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r8r8_ p0, double p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double2, Double, Double) declare in Unity.Mathematics.double4
bool w_vtS_r8r8_r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8_r8r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r8r8_ p0, double p1, double p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_xyz(Unity.Mathematics.double3) declare in Unity.Mathematics.double3
bool w_vtS_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};

    typedef void (*FuncToCall)(void*,struct S_r8r8r8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.double3x2
bool w_vtS_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8r8_S_r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};

    typedef void (*FuncToCall)(void*,struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double3, Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.double3x3
bool w_vtS_r8r8r8_S_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8r8_S_r8r8r8_S_r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv2);
    S_r8r8r8_ p2 = pp2 ? *pp2 : S_r8r8r8_ {};

    typedef void (*FuncToCall)(void*,struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, struct S_r8r8r8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double3, Unity.Mathematics.double3, Unity.Mathematics.double3, Unity.Mathematics.double3) declare in Unity.Mathematics.double3x4
bool w_vtS_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8r8_S_r8r8r8_S_r8r8r8_S_r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv1);
    S_r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv2);
    S_r8r8r8_ p2 = pp2 ? *pp2 : S_r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8_* pp3 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv3);
    S_r8r8r8_ p3 = pp3 ? *pp3 : S_r8r8r8_ {};

    typedef void (*FuncToCall)(void*,struct S_r8r8r8_ p0, struct S_r8r8r8_ p1, struct S_r8r8r8_ p2, struct S_r8r8r8_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double3, Double) declare in Unity.Mathematics.double4
bool w_vtS_r8r8r8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8r8_r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r8r8r8_ p0, double p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_xyzw(Unity.Mathematics.double4) declare in Unity.Mathematics.double4
bool w_vtS_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};

    typedef void (*FuncToCall)(void*,struct S_r8r8r8r8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.double4x2
bool w_vtS_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};

    typedef void (*FuncToCall)(void*,struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double4, Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.double4x3
bool w_vtS_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv2);
    S_r8r8r8r8_ p2 = pp2 ? *pp2 : S_r8r8r8r8_ {};

    typedef void (*FuncToCall)(void*,struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, struct S_r8r8r8r8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.double4, Unity.Mathematics.double4, Unity.Mathematics.double4, Unity.Mathematics.double4) declare in Unity.Mathematics.double4x4
bool w_vtS_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv1);
    S_r8r8r8r8_ p1 = pp1 ? *pp1 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv2);
    S_r8r8r8r8_ p2 = pp2 ? *pp2 : S_r8r8r8r8_ {};
    // JSValToCSVal struct
    S_r8r8r8r8_* pp3 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv3);
    S_r8r8r8r8_ p3 = pp3 ? *pp3 : S_r8r8r8r8_ {};

    typedef void (*FuncToCall)(void*,struct S_r8r8r8r8_ p0, struct S_r8r8r8r8_ p1, struct S_r8r8r8r8_ p2, struct S_r8r8r8r8_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Add(System.Collections.Generic.KeyValuePair`2[System.String,System.Object]) declare in System.Diagnostics.ActivityTagsCollection
bool w_vtS_sO_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_sO_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sO_* pp0 = DataTransfer::GetPointer<S_sO_>(apis, env, _sv0);
    S_sO_ p0 = pp0 ? *pp0 : S_sO_ {};

    typedef void (*FuncToCall)(void*,struct S_sO_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_Role(Microsoft.Extensions.AI.ChatRole) declare in Microsoft.Extensions.AI.ChatMessage
bool w_vtS_s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_s_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};

    typedef void (*FuncToCall)(void*,struct S_s_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(System.Diagnostics.ActivityTraceId, System.Diagnostics.ActivitySpanId, System.Diagnostics.ActivityTraceFlags, System.String, Boolean) declare in System.Diagnostics.ActivityContext
bool w_vtS_s_S_s_i4DsDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_s_S_s_i4DsDb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};
    // JSValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(apis, env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal string  with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,struct S_s_ p0, struct S_s_ p1, int32_t p2, Il2CppString* p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Betalgo.Ranul.OpenAI.Contracts.Enums.ChatCompletionRole, System.Text.StringBuilder) declare in DefaultNamespace.UI.MyMessage
bool w_vtS_s_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_s_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_s_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Betalgo.Ranul.OpenAI.Contracts.Enums.AssistantMessageRole, Betalgo.Ranul.OpenAI.ObjectModels.MessageContentOneOfType, System.Collections.Generic.List`1[Betalgo.Ranul.OpenAI.ObjectModels.RequestModels.Attachment], System.Collections.Generic.Dictionary`2[System.String,System.String]) declare in Betalgo.Ranul.OpenAI.ObjectModels.RequestModels.MessageCreateRequest
bool w_vtS_s_oDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_s_oDoDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                

    typedef void (*FuncToCall)(void*,struct S_s_ p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Betalgo.Ranul.OpenAI.Contracts.Enums.ChatCompletionRole, System.Collections.Generic.IList`1[Betalgo.Ranul.OpenAI.ObjectModels.RequestModels.MessageContent], System.String, System.Collections.Generic.IList`1[Betalgo.Ranul.OpenAI.ObjectModels.RequestModels.ToolCall], System.String) declare in Betalgo.Ranul.OpenAI.ObjectModels.RequestModels.ChatMessage
bool w_vtS_s_oDsDoDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_s_oDsDoDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal string  with default
    Il2CppString* p4 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,struct S_s_ p0, Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Betalgo.Ranul.OpenAI.Contracts.Enums.ChatCompletionRole, System.String) declare in DefaultNamespace.UI.MyMessage
bool w_vtS_s_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_s_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_s_ p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Betalgo.Ranul.OpenAI.Contracts.Enums.ChatCompletionRole, System.String, System.String, System.Collections.Generic.IList`1[Betalgo.Ranul.OpenAI.ObjectModels.RequestModels.ToolCall], System.String) declare in Betalgo.Ranul.OpenAI.ObjectModels.RequestModels.ChatMessage
bool w_vtS_s_sDsDoDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_s_sDsDoDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal string  with default
    Il2CppString* p4 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,struct S_s_ p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Append(Microsoft.Extensions.Primitives.StringSegment) declare in Microsoft.Extensions.Primitives.InplaceStringBuilder
bool w_vtS_si4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_si4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_si4i4_* pp0 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv0);
    S_si4i4_ p0 = pp0 ? *pp0 : S_si4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_si4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Microsoft.Extensions.Primitives.StringSegment, Char[]) declare in Microsoft.Extensions.Primitives.StringTokenizer
bool w_vtS_si4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_si4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_si4i4_* pp0 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv0);
    S_si4i4_ p0 = pp0 ? *pp0 : S_si4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_si4i4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_fontAssetCreationEditorSettings(UnityEngine.TextCore.Text.FontAssetCreationEditorSettings) declare in UnityEngine.TextCore.Text.FontAsset
bool w_vtS_si4i4i4i4i4i4i4i4i4sssi4r4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_si4i4i4i4i4i4i4i4i4sssi4r4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_* pp0 = DataTransfer::GetPointer<S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_>(apis, env, _sv0);
    S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_ p0 = pp0 ? *pp0 : S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_ {};

    typedef void (*FuncToCall)(void*,struct S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetProperty(System.Security.Cryptography.CngProperty) declare in System.Security.Cryptography.CngKey
bool w_vtS_si4oN_bi4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_si4oN_bi4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_si4oN_bi4__* pp0 = DataTransfer::GetPointer<S_si4oN_bi4__>(apis, env, _sv0);
    S_si4oN_bi4__ p0 = pp0 ? *pp0 : S_si4oN_bi4__ {};

    typedef void (*FuncToCall)(void*,struct S_si4oN_bi4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEditor.Search.SearchDocument, Int32) declare in UnityEditor.Search.SearchDocument
bool w_vtS_si4ssi4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_si4ssi4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_si4ssi4_* pp0 = DataTransfer::GetPointer<S_si4ssi4_>(apis, env, _sv0);
    S_si4ssi4_ p0 = pp0 ? *pp0 : S_si4ssi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_si4ssi4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEditor.Search.SearchDocument, System.String) declare in UnityEditor.Search.SearchDocument
bool w_vtS_si4ssi4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_si4ssi4_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_si4ssi4_* pp0 = DataTransfer::GetPointer<S_si4ssi4_>(apis, env, _sv0);
    S_si4ssi4_ p0 = pp0 ? *pp0 : S_si4ssi4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_si4ssi4_ p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Add(System.Collections.Generic.KeyValuePair`2[System.String,System.Text.Json.Nodes.JsonNode]) declare in System.Text.Json.Nodes.JsonObject
bool w_vtS_so_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_so_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_so_* pp0 = DataTransfer::GetPointer<S_so_>(apis, env, _sv0);
    S_so_ p0 = pp0 ? *pp0 : S_so_ {};

    typedef void (*FuncToCall)(void*,struct S_so_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlChars
bool w_vtS_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_soi4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef void (*FuncToCall)(void*,struct S_soi4i4b_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Bind(UnityEditor.EditorCurveBinding) declare in UnityEditor.Animations.GameObjectRecorder
bool w_vtS_sosi4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_sosi4i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_sosi4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_sosi4i4i4i4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_sosi4i4i4i4i4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(log4net.Core.LoggingEventData) declare in log4net.Core.LoggingEvent
bool w_vtS_sossS_u8_osssso_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_sossS_u8_osssso_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sossS_u8_osssso_* pp0 = DataTransfer::GetPointer<S_sossS_u8_osssso_>(apis, env, _sv0);
    S_sossS_u8_osssso_ p0 = pp0 ? *pp0 : S_sossS_u8_osssso_ {};

    typedef void (*FuncToCall)(void*,struct S_sossS_u8_osssso_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_creationSettings(TMPro.FontAssetCreationSettings) declare in TMPro.TMP_FontAsset
bool w_vtS_ssi4i4i4i4i4i4i4sssi4r4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_ssi4i4i4i4i4i4i4sssi4r4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_ssi4i4i4i4i4i4i4sssi4r4i4b_* pp0 = DataTransfer::GetPointer<S_ssi4i4i4i4i4i4i4sssi4r4i4b_>(apis, env, _sv0);
    S_ssi4i4i4i4i4i4i4sssi4r4i4b_ p0 = pp0 ? *pp0 : S_ssi4i4i4i4i4i4i4sssi4r4i4b_ {};

    typedef void (*FuncToCall)(void*,struct S_ssi4i4i4i4i4i4i4sssi4r4i4b_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Enable(UnityEngine.Rendering.ShaderKeyword) declare in UnityEngine.Rendering.ShaderKeywordSet
bool w_vtS_su4bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_su4bbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_su4bbb_* pp0 = DataTransfer::GetPointer<S_su4bbb_>(apis, env, _sv0);
    S_su4bbb_ p0 = pp0 ? *pp0 : S_su4bbb_ {};

    typedef void (*FuncToCall)(void*,struct S_su4bbb_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_debug(UnityEngine.AI.NavMeshBuildDebugSettings) declare in UnityEngine.AI.NavMeshBuildSettings
bool w_vtS_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef void (*FuncToCall)(void*,struct S_u1_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_depthState(UnityEngine.Rendering.DepthState) declare in UnityEngine.Rendering.RenderStateBlock
bool w_vtS_u1i1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1i1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1i1_* pp0 = DataTransfer::GetPointer<S_u1i1_>(apis, env, _sv0);
    S_u1i1_ p0 = pp0 ? *pp0 : S_u1i1_ {};

    typedef void (*FuncToCall)(void*,struct S_u1i1_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Emit(System.Reflection.Emit.OpCode) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Emit(System.Reflection.Emit.OpCode, System.Reflection.Emit.Label) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_S_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, struct S_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Emit(System.Reflection.Emit.OpCode, SByte) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_i1");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, int8_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Emit(System.Reflection.Emit.OpCode, Int16) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_i2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, int16_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Emit(System.Reflection.Emit.OpCode, Int32) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void EmitCalli(System.Reflection.Emit.OpCode, System.Runtime.InteropServices.CallingConvention, System.Type, System.Type[]) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_i4oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void EmitCalli(System.Reflection.Emit.OpCode, System.Reflection.CallingConventions, System.Type, System.Type[], System.Type[]) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_i4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_i4ooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Emit(System.Reflection.Emit.OpCode, Int64) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Emit(System.Reflection.Emit.OpCode, System.Reflection.ConstructorInfo) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void EmitCall(System.Reflection.Emit.OpCode, System.Reflection.MethodInfo, System.Type[]) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Emit(System.Reflection.Emit.OpCode, Single) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Emit(System.Reflection.Emit.OpCode, Double) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, double p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Emit(System.Reflection.Emit.OpCode, System.String) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Emit(System.Reflection.Emit.OpCode, Byte) declare in System.Reflection.Emit.ILGenerator
bool w_vtS_u1u1u1u1u1u1u1u1_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1_u1");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p0, uint8_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Burst.Intrinsics.v64, Unity.Burst.Intrinsics.v64) declare in Unity.Burst.Intrinsics.v128
bool w_vtS_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_ {};
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_* pp1 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_>(apis, env, _sv1);
    S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_ p1 = pp1 ? *pp1 : S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_ {};

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_ p0, struct S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_stencilState(UnityEngine.Rendering.StencilState) declare in UnityEngine.Rendering.RenderStateBlock
bool w_vtS_u1u1u1u1u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Burst.Intrinsics.v128, Unity.Burst.Intrinsics.v128) declare in Unity.Burst.Intrinsics.v256
bool w_vtS_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__ {};
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__* pp1 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__>(apis, env, _sv1);
    S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__ p1 = pp1 ? *pp1 : S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__ {};

    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__ p0, struct S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8_S_u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1u2u2u2u2i2i2i2i2u4u4i4i4u8i8r4r4r8__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.half) declare in Unity.Mathematics.double2
bool w_vtS_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Profiling.ProfilerCategory, Char*, Int32) declare in Unity.Profiling.ProfilerMarker
bool w_vtS_u2_Pvi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_Pvi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Profiling.ProfilerCategory, Char*, Int32, Int32, Unity.Profiling.ProfilerRecorderOptions) declare in Unity.Profiling.ProfilerRecorder
bool w_vtS_u2_Pvi4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_Pvi4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, void* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Unity.Profiling.ProfilerCategory, Char*, Int32, Unity.Profiling.LowLevel.MarkerFlags) declare in Unity.Profiling.ProfilerMarker
bool w_vtS_u2_Pvi4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_Pvi4u2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint16_t p3 = converter::Converter<uint16_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, void* p1, int32_t p2, uint16_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.half, Unity.Mathematics.half3) declare in Unity.Mathematics.half4
bool w_vtS_u2_S_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_S_S_u2_S_u2_S_u2__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2_S_u2__ {};

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, struct S_S_u2_S_u2_S_u2__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.half, Unity.Mathematics.half2) declare in Unity.Mathematics.half3
bool w_vtS_u2_S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_S_S_u2_S_u2__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2__ {};

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, struct S_S_u2_S_u2__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.half, Unity.Mathematics.half2, Unity.Mathematics.half) declare in Unity.Mathematics.half4
bool w_vtS_u2_S_S_u2_S_u2__S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_S_S_u2_S_u2__S_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp1 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv1);
    S_S_u2_S_u2__ p1 = pp1 ? *pp1 : S_S_u2_S_u2__ {};
    // JSValToCSVal struct
    S_u2_* pp2 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv2);
    S_u2_ p2 = pp2 ? *pp2 : S_u2_ {};

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, struct S_S_u2_S_u2__ p1, struct S_u2_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.half, Unity.Mathematics.half) declare in Unity.Mathematics.half2
bool w_vtS_u2_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_S_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, struct S_u2_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.half, Unity.Mathematics.half, Unity.Mathematics.half2) declare in Unity.Mathematics.half4
bool w_vtS_u2_S_u2_S_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_S_u2_S_S_u2_S_u2__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};
    // JSValToCSVal struct
    S_S_u2_S_u2__* pp2 = DataTransfer::GetPointer<S_S_u2_S_u2__>(apis, env, _sv2);
    S_S_u2_S_u2__ p2 = pp2 ? *pp2 : S_S_u2_S_u2__ {};

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, struct S_u2_ p1, struct S_S_u2_S_u2__ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.half, Unity.Mathematics.half, Unity.Mathematics.half) declare in Unity.Mathematics.half3
bool w_vtS_u2_S_u2_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_S_u2_S_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp2 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv2);
    S_u2_ p2 = pp2 ? *pp2 : S_u2_ {};

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, struct S_u2_ p1, struct S_u2_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.half, Unity.Mathematics.half, Unity.Mathematics.half, Unity.Mathematics.half) declare in Unity.Mathematics.half4
bool w_vtS_u2_S_u2_S_u2_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_S_u2_S_u2_S_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp2 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv2);
    S_u2_ p2 = pp2 ? *pp2 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp3 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv3);
    S_u2_ p3 = pp3 ? *pp3 : S_u2_ {};

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, struct S_u2_ p1, struct S_u2_ p2, struct S_u2_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Unity.Profiling.ProfilerCategory, System.String) declare in Unity.Profiling.ProfilerMarker
bool w_vtS_u2_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Profiling.ProfilerCategory, System.String, Int32, Unity.Profiling.ProfilerRecorderOptions) declare in Unity.Profiling.ProfilerRecorder
bool w_vtS_u2_sDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_sDi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Unity.Profiling.ProfilerCategory, System.String, Unity.Profiling.LowLevel.MarkerFlags) declare in Unity.Profiling.ProfilerMarker
bool w_vtS_u2_su2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u2_su2");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_u2_ p0, Il2CppString* p1, uint16_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_firstAdjustmentRecord(UnityEngine.TextCore.LowLevel.GlyphAdjustmentRecord) declare in UnityEngine.TextCore.LowLevel.GlyphPairAdjustmentRecord
bool w_vtS_u4S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_u4S_r4r4r4r4__>(apis, env, _sv0);
    S_u4S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_u4S_r4r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_u4S_r4r4r4r4__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.TextCore.LowLevel.GlyphAdjustmentRecord, UnityEngine.TextCore.LowLevel.GlyphAdjustmentRecord) declare in UnityEngine.TextCore.LowLevel.GlyphPairAdjustmentRecord
bool w_vtS_u4S_r4r4r4r4__S_u4S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4S_r4r4r4r4__S_u4S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_u4S_r4r4r4r4__>(apis, env, _sv0);
    S_u4S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_u4S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_u4S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_u4S_r4r4r4r4__>(apis, env, _sv1);
    S_u4S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_u4S_r4r4r4r4__ {};

    typedef void (*FuncToCall)(void*,struct S_u4S_r4r4r4r4__ p0, struct S_u4S_r4r4r4r4__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void RemoveBatch(UnityEngine.Rendering.BatchID) declare in UnityEngine.Rendering.ThreadedBatchContext
bool w_vtS_u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4_* pp0 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv0);
    S_u4_ p0 = pp0 ? *pp0 : S_u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetBatchBuffer(UnityEngine.Rendering.BatchID, UnityEngine.GraphicsBufferHandle) declare in UnityEngine.Rendering.ThreadedBatchContext
bool w_vtS_u4_S_u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4_S_u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4_* pp0 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv0);
    S_u4_ p0 = pp0 ? *pp0 : S_u4_ {};
    // JSValToCSVal struct
    S_u4_* pp1 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv1);
    S_u4_ p1 = pp1 ? *pp1 : S_u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4_ p0, struct S_u4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEditor.Media.VP8EncoderAttributes) declare in UnityEditor.Media.VideoTrackEncoderAttributes
bool w_vtS_u4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4i4_* pp0 = DataTransfer::GetPointer<S_u4i4_>(apis, env, _sv0);
    S_u4i4_ p0 = pp0 ? *pp0 : S_u4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void CopyAnimationStreamMotion(UnityEngine.Animations.AnimationStream) declare in UnityEngine.Animations.AnimationStream
bool w_vtS_u4pppppp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4pppppp_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};

    typedef void (*FuncToCall)(void*,struct S_u4pppppp_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void GetGlobalTR(UnityEngine.Animations.AnimationStream, UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef) declare in UnityEngine.Animations.TransformStreamHandle
bool w_vtS_u4pppppp_PS_r4r4r4_PS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4pppppp_PS_r4r4r4_PS_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4r4_));
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void*,struct S_u4pppppp_ p0, struct S_r4r4r4_* p1, struct S_r4r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    return true;
}

// Void GetLocalTRS(UnityEngine.Animations.AnimationStream, UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef, UnityEngine.Vector3 ByRef) declare in UnityEngine.Animations.TransformStreamHandle
bool w_vtS_u4pppppp_PS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4pppppp_PS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4r4_));
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_r4r4r4_));
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void*,struct S_u4pppppp_ p0, struct S_r4r4r4_* p1, struct S_r4r4r4r4_* p2, struct S_r4r4r4_* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
            
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    return true;
}

// Void SetPosition(UnityEngine.Animations.AnimationStream, UnityEngine.Vector3) declare in UnityEngine.Animations.TransformStreamHandle
bool w_vtS_u4pppppp_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4pppppp_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4pppppp_ p0, struct S_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetLocalTRS(UnityEngine.Animations.AnimationStream, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3, Boolean) declare in UnityEngine.Animations.TransformStreamHandle
bool w_vtS_u4pppppp_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4pppppp_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_u4pppppp_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4_ p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetGlobalTR(UnityEngine.Animations.AnimationStream, UnityEngine.Vector3, UnityEngine.Quaternion, Boolean) declare in UnityEngine.Animations.TransformStreamHandle
bool w_vtS_u4pppppp_S_r4r4r4_S_r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4pppppp_S_r4r4r4_S_r4r4r4r4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_u4pppppp_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetRotation(UnityEngine.Animations.AnimationStream, UnityEngine.Quaternion) declare in UnityEngine.Animations.TransformStreamHandle
bool w_vtS_u4pppppp_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4pppppp_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4pppppp_ p0, struct S_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetBool(UnityEngine.Animations.AnimationStream, Boolean) declare in UnityEngine.Animations.PropertyStreamHandle
bool w_vtS_u4pppppp_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4pppppp_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u4pppppp_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetInt(UnityEngine.Animations.AnimationStream, Int32) declare in UnityEngine.Animations.PropertyStreamHandle
bool w_vtS_u4pppppp_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4pppppp_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u4pppppp_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetFloat(UnityEngine.Animations.AnimationStream, Single) declare in UnityEngine.Animations.PropertyStreamHandle
bool w_vtS_u4pppppp_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4pppppp_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u4pppppp_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_refreshRateRatio(UnityEngine.RefreshRate) declare in UnityEngine.Resolution
bool w_vtS_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint2, Unity.Mathematics.uint2) declare in Unity.Mathematics.uint2x2
bool w_vtS_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_S_u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, struct S_u4u4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint2, Unity.Mathematics.uint2, Unity.Mathematics.uint2) declare in Unity.Mathematics.uint2x3
bool w_vtS_u4u4_S_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_S_u4u4_S_u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv2);
    S_u4u4_ p2 = pp2 ? *pp2 : S_u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, struct S_u4u4_ p1, struct S_u4u4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint2, Unity.Mathematics.uint2, Unity.Mathematics.uint2, Unity.Mathematics.uint2) declare in Unity.Mathematics.uint2x4
bool w_vtS_u4u4_S_u4u4_S_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_S_u4u4_S_u4u4_S_u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv2);
    S_u4u4_ p2 = pp2 ? *pp2 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp3 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv3);
    S_u4u4_ p3 = pp3 ? *pp3 : S_u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, struct S_u4u4_ p1, struct S_u4u4_ p2, struct S_u4u4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Codice.CM.Common.RepId, Int64, System.Guid, Int64, Int64, Int64, Int64, LockStatus, System.String, System.String, System.String, System.Guid, Int64) declare in Codice.CM.Common.LockInfo
bool w_vtS_u4u4_i8S_i4i2i2u1u1u1u1u1u1u1u1_i8i8i8i8u1sssS_i4i2i2u1u1u1u1u1u1u1u1_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_i8S_i4i2i2u1u1u1u1u1u1u1u1_i8i8i8i8u1sssS_i4i2i2u1u1u1u1u1u1u1u1_i8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp8 = wrapData->TypeInfos[2];
    auto TIp9 = wrapData->TypeInfos[3];
    auto TIp10 = wrapData->TypeInfos[4];
    auto TIp11 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);

    if (checkJSArgument) {
        if (js_args_len != 13) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv10)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv11, TIp11, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv12)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv2);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p2 = pp2 ? *pp2 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int64_t p5 = converter::Converter<int64_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    uint8_t p7 = converter::Converter<uint8_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal s
    Il2CppString* p8 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv8);
    // JSValToCSVal s
    Il2CppString* p9 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv9);
    // JSValToCSVal s
    Il2CppString* p10 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv10);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp11 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv11);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p11 = pp11 ? *pp11 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int64_t p12 = converter::Converter<int64_t>::toCpp(apis, env, _sv12);

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, int64_t p1, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p2, int64_t p3, int64_t p4, int64_t p5, int64_t p6, uint8_t p7, Il2CppString* p8, Il2CppString* p9, Il2CppString* p10, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p11, int64_t p12, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12,  method);

    
    return true;
}

// Void .ctor(Codice.CM.Common.RepId, Int64, System.String, Codice.CM.Common.EnumItemType, System.String) declare in Codice.CM.Common.ItemInfo
bool w_vtS_u4u4_i8si4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_i8si4s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, int64_t p1, Il2CppString* p2, int32_t p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Codice.CM.Common.RepId, Codice.CM.Interfaces.IBranchHandler) declare in Codice.Client.BaseCommands.BranchNameResolver
bool w_vtS_u4u4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Codice.CM.Common.RepId, Codice.CM.Common.Tree.ChangedNode, Boolean) declare in Codice.CM.Common.Serialization.SerializedTreeChangedNode
bool w_vtS_u4u4_ob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_ob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, Il2CppObject* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Codice.CM.Common.RepId, Codice.CM.Interfaces.IItemHandler, Codice.CM.Common.IDataDecryptor) declare in Codice.Client.BaseCommands.Download.StandardDataPacketDownloader
bool w_vtS_u4u4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Codice.CM.Common.RepId, System.String, Codice.CM.Common.SEID) declare in Codice.CM.Common.Workspaces.WorkspaceShareInfo
bool w_vtS_u4u4_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Codice.CM.Common.RepId, System.String, System.String, System.Guid, Codice.CM.Common.RepositoryType) declare in Codice.CM.Common.RepositoryInfo
bool w_vtS_u4u4_ssS_i4i2i2u1u1u1u1u1u1u1u1_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_ssS_i4i2i2u1u1u1u1u1u1u1u1_u1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp3 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv3);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p3 = pp3 ? *pp3 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, Il2CppString* p1, Il2CppString* p2, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p3, uint8_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Codice.CM.Common.RepId, System.String, System.String, System.Guid, Codice.CM.Common.RepositoryType, Codice.CM.Common.SEID) declare in Codice.CM.Common.RepositoryInfo
bool w_vtS_u4u4_ssS_i4i2i2u1u1u1u1u1u1u1u1_u1o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_ssS_i4i2i2u1u1u1u1u1u1u1u1_u1o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp3 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv3);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p3 = pp3 ? *pp3 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, Il2CppString* p1, Il2CppString* p2, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p3, uint8_t p4, Il2CppObject* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint2, UInt32) declare in Unity.Mathematics.uint3
bool w_vtS_u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_u4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint2, UInt32, UInt32) declare in Unity.Mathematics.uint4
bool w_vtS_u4u4_u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_u4u4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_u4u4_ p0, uint32_t p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEditor.Media.H264EncoderAttributes) declare in UnityEditor.Media.VideoTrackEncoderAttributes
bool w_vtS_u4u4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4i4_* pp0 = DataTransfer::GetPointer<S_u4u4i4_>(apis, env, _sv0);
    S_u4u4i4_ p0 = pp0 ? *pp0 : S_u4u4i4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_xyz(Unity.Mathematics.uint3) declare in Unity.Mathematics.uint3
bool w_vtS_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4u4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint3, Unity.Mathematics.uint3) declare in Unity.Mathematics.uint3x2
bool w_vtS_u4u4u4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4_S_u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint3, Unity.Mathematics.uint3, Unity.Mathematics.uint3) declare in Unity.Mathematics.uint3x3
bool w_vtS_u4u4u4_S_u4u4u4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4_S_u4u4u4_S_u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv2);
    S_u4u4u4_ p2 = pp2 ? *pp2 : S_u4u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, struct S_u4u4u4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint3, Unity.Mathematics.uint3, Unity.Mathematics.uint3, Unity.Mathematics.uint3) declare in Unity.Mathematics.uint3x4
bool w_vtS_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv2);
    S_u4u4u4_ p2 = pp2 ? *pp2 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp3 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv3);
    S_u4u4u4_ p3 = pp3 ? *pp3 : S_u4u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, struct S_u4u4u4_ p2, struct S_u4u4u4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint3, UInt32) declare in Unity.Mathematics.uint4
bool w_vtS_u4u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4_u4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u4u4u4_ p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_guid(UnityEditor.GUID) declare in UnityEditor.EditorBuildSettingsScene
bool w_vtS_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint4, Unity.Mathematics.uint4) declare in Unity.Mathematics.uint4x2
bool w_vtS_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint4, Unity.Mathematics.uint4, Unity.Mathematics.uint4) declare in Unity.Mathematics.uint4x3
bool w_vtS_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv2);
    S_u4u4u4u4_ p2 = pp2 ? *pp2 : S_u4u4u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, struct S_u4u4u4u4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Unity.Mathematics.uint4, Unity.Mathematics.uint4, Unity.Mathematics.uint4, Unity.Mathematics.uint4) declare in Unity.Mathematics.uint4x4
bool w_vtS_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv2);
    S_u4u4u4u4_ p2 = pp2 ? *pp2 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp3 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv3);
    S_u4u4u4u4_ p3 = pp3 ? *pp3 : S_u4u4u4u4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, struct S_u4u4u4u4_ p2, struct S_u4u4u4u4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEditor.GUID, Boolean) declare in UnityEditor.EditorBuildSettingsScene
bool w_vtS_u4u4u4u4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4u4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEditor.GUID, Int32, UnityEngine.SceneManagement.Scene) declare in UnityEditor.CreateAssetObjectEventArgs
bool w_vtS_u4u4u4u4_i4S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4u4_i4S_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4_* pp2 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv2);
    S_i4_ p2 = pp2 ? *pp2 : S_i4_ {};

    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4_ p0, int32_t p1, struct S_i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEditor.GUID, System.Type) declare in UnityEditor.Experimental.ArtifactKey
bool w_vtS_u4u4u4u4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4u4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Invalidate(UnityEditor.Search.PropertyDatabaseRecordKey) declare in UnityEditor.Search.SearchMonitorView
bool w_vtS_u8S_u8u8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8S_u8u8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8S_u8u8__* pp0 = DataTransfer::GetPointer<S_u8S_u8u8__>(apis, env, _sv0);
    S_u8S_u8u8__ p0 = pp0 ? *pp0 : S_u8S_u8u8__ {};

    typedef void (*FuncToCall)(void*,struct S_u8S_u8u8__ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void StoreProperty(UnityEditor.Search.PropertyDatabaseRecordKey, System.Object) declare in UnityEditor.Search.SearchMonitorView
bool w_vtS_u8S_u8u8__O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8S_u8u8__O");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8S_u8u8__* pp0 = DataTransfer::GetPointer<S_u8S_u8u8__>(apis, env, _sv0);
    S_u8S_u8u8__ p0 = pp0 ? *pp0 : S_u8S_u8u8__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u8S_u8u8__ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void StoreProperty(UnityEditor.Search.PropertyDatabaseRecordKey, System.Object, System.String) declare in UnityEditor.Search.SearchMonitorView
bool w_vtS_u8S_u8u8__Os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8S_u8u8__Os");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u8S_u8u8__* pp0 = DataTransfer::GetPointer<S_u8S_u8u8__>(apis, env, _sv0);
    S_u8S_u8u8__ p0 = pp0 ? *pp0 : S_u8S_u8u8__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_u8S_u8u8__ p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void StoreAlias(UnityEditor.Search.PropertyDatabaseRecordKey, System.String) declare in UnityEditor.Search.SearchMonitorView
bool w_vtS_u8S_u8u8__s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8S_u8u8__s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u8S_u8u8__* pp0 = DataTransfer::GetPointer<S_u8S_u8u8__>(apis, env, _sv0);
    S_u8S_u8u8__ p0 = pp0 ? *pp0 : S_u8S_u8u8__ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u8S_u8u8__ p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_Value(System.DateTime) declare in System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDate
bool w_vtS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef void (*FuncToCall)(void*,struct S_u8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderHandle, Int32, Unity.Profiling.ProfilerRecorderOptions) declare in Unity.Profiling.ProfilerRecorder
bool w_vtS_u8_Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8_Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,struct S_u8_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.DateTime, System.TimeSpan) declare in System.DateTimeOffset
bool w_vtS_u8_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8_S_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef void (*FuncToCall)(void*,struct S_u8_ p0, struct S_i8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.DateTime, System.DateTime, System.TimeSpan) declare in System.Globalization.DaylightTime
bool w_vtS_u8_S_u8_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8_S_u8_S_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
    // JSValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};

    typedef void (*FuncToCall)(void*,struct S_u8_ p0, struct S_u8_ p1, struct S_i8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.DateTime, Int32) declare in System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDate
bool w_vtS_u8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u8_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.DateTime, Int64, System.String) declare in Codice.Client.Commands.FileLocalInfo
bool w_vtS_u8_i8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8_i8s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_u8_ p0, int64_t p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void FormatDate(System.DateTime, System.IO.TextWriter) declare in log4net.DateFormatter.AbsoluteTimeDateFormatter
bool w_vtS_u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u8_ p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddDependency(Unity.Jobs.JobHandle) declare in UnityEngine.Experimental.AI.NavMeshWorld
bool w_vtS_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8i4i4p_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8i4i4p_* pp0 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, _sv0);
    S_u8i4i4p_ p0 = pp0 ? *pp0 : S_u8i4i4p_ {};

    typedef void (*FuncToCall)(void*,struct S_u8i4i4p_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Prepare(Unity.Jobs.JobHandle, UnityEngine.U2D.SpriteShapeParameters, UnityEngine.Sprite[]) declare in UnityEngine.U2D.SpriteShapeRenderer
bool w_vtS_u8i4i4p_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8i4i4p_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u8i4i4p_* pp0 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, _sv0);
    S_u8i4i4p_ p0 = pp0 ? *pp0 : S_u8i4i4p_ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_>(apis, env, _sv1);
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_u8i4i4p_ p0, struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_hash(UnityEngine.Hash128) declare in UnityEngine.CachedAssetBundle
bool w_vtS_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv0);
    S_u8u8_ p0 = pp0 ? *pp0 : S_u8u8_ {};

    typedef void (*FuncToCall)(void*,struct S_u8u8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Hash128, UnityEngine.Hash128, UnityEngine.Hash128) declare in UnityEditor.Experimental.Rendering.SceneStateHash
bool w_vtS_u8u8_S_u8u8_S_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8u8_S_u8u8_S_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv0);
    S_u8u8_ p0 = pp0 ? *pp0 : S_u8u8_ {};
    // JSValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};
    // JSValToCSVal struct
    S_u8u8_* pp2 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv2);
    S_u8u8_ p2 = pp2 ? *pp2 : S_u8u8_ {};

    typedef void (*FuncToCall)(void*,struct S_u8u8_ p0, struct S_u8u8_ p1, struct S_u8u8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void GenerateMeshAsync(UnityEngine.XR.MeshId, UnityEngine.Mesh, UnityEngine.MeshCollider, UnityEngine.XR.MeshVertexAttributes, System.Action`1[UnityEngine.XR.MeshGenerationResult]) declare in UnityEngine.XR.XRMeshSubsystem
bool w_vtS_u8u8_ooi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8u8_ooi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv0);
    S_u8u8_ p0 = pp0 ? *pp0 : S_u8u8_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_u8u8_ p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void GenerateMeshAsync(UnityEngine.XR.MeshId, UnityEngine.Mesh, UnityEngine.MeshCollider, UnityEngine.XR.MeshVertexAttributes, System.Action`1[UnityEngine.XR.MeshGenerationResult], UnityEngine.XR.MeshGenerationOptions) declare in UnityEngine.XR.XRMeshSubsystem
bool w_vtS_u8u8_ooi4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u8u8_ooi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv0);
    S_u8u8_ p0 = pp0 ? *pp0 : S_u8u8_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,struct S_u8u8_ p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Add(System.Object[]) declare in System.Xml.Linq.XContainer
bool w_vtVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtVO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
    }
    
    // JSValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, js_args_len, 0);
                

    typedef void (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Keyframe[]) declare in UnityEngine.AnimationCurve
bool w_vtVS_r4r4r4r4i4i4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtVS_r4r4r4r4i4i4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, true)) return false;
    }
    
    // JSValToCSVal valuetype params
    Il2CppArray* p0 = Params<S_r4r4r4r4i4i4r4r4_>::PackValueType(apis, env, info, TIp0, js_args_len, 0);
                

    typedef void (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void AllowCharacters(Char[]) declare in System.Text.Encodings.Web.TextEncoderSettings
bool w_vtVc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtVc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive params
    Il2CppArray* p0 = Params<Il2CppChar>::PackPrimitive(apis, env, info, TIp0, js_args_len, 0);
                

    typedef void (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.GraphicsDeviceType[]) declare in UnityEditor.ShaderKeywordFilter.ApplyRulesIfGraphicsAPIAttribute
bool w_vtVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtVi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive params
    Il2CppArray* p0 = Params<int32_t>::PackPrimitive(apis, env, info, TIp0, js_args_len, 0);
                

    typedef void (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetInterfaceConstraints(System.Type[]) declare in System.Reflection.Emit.GenericTypeParameterBuilder
bool w_vtVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtVo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, false)) return false;
    }
    
    // JSValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, js_args_len, 0);
                

    typedef void (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(System.String[]) declare in UnityEngine.SearchService.ObjectSelectorHandlerWithLabelsAttribute
bool w_vtVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtVs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal string params
    Il2CppArray* p0 = Params<void*>::PackString(apis, env, info, TIp0, js_args_len, 0);
                

    typedef void (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_AllowMultiple(Boolean) declare in System.AttributeUsageAttribute
bool w_vtb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef void (*FuncToCall)(void*,bool p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetValue(Boolean, Boolean) declare in DefaultNamespace.Widget.UITabButton
bool w_vtbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbDb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,bool p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetDetphState(Boolean, UnityEngine.Rendering.CompareFunction) declare in UnityEngine.Experimental.Rendering.Universal.RenderObjectsPass
bool w_vtbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbDi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Boolean, System.String, System.String, System.String) declare in UnityEngine.Scripting.APIUpdating.MovedFromAttribute
bool w_vtbDsDsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbDsDsDs");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal string  with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,bool p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void GetCheckedChanges(Boolean, System.Collections.Generic.List`1[Codice.Client.BaseCommands.ChangeInfo] ByRef, System.Collections.Generic.List`1[Codice.Client.BaseCommands.ChangeInfo] ByRef) declare in PlasticGui.WorkspaceWindow.PendingChanges.PendingChangeInfo
bool w_vtbPoPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbPoPo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef void (*FuncToCall)(void*,bool p0, Il2CppObject** p1, Il2CppObject** p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    return true;
}

// Void .ctor(Boolean, Unity.Mathematics.bool2) declare in Unity.Mathematics.bool3
bool w_vtbS_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbS_bb_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};

    typedef void (*FuncToCall)(void*,bool p0, struct S_bb_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Boolean, Unity.Mathematics.bool2, Boolean) declare in Unity.Mathematics.bool4
bool w_vtbS_bb_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbS_bb_b");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,bool p0, struct S_bb_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Boolean, Unity.Mathematics.bool3) declare in Unity.Mathematics.bool4
bool w_vtbS_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbS_bbb_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};

    typedef void (*FuncToCall)(void*,bool p0, struct S_bbb_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Boolean, UnityEngine.Rendering.GraphicsDeviceType[]) declare in UnityEditor.ShaderKeywordFilter.GraphicsAPIConstraintAttribute
bool w_vtbVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbVi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive params
    Il2CppArray* p1 = Params<int32_t>::PackPrimitive(apis, env, info, TIp1, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,bool p0, Il2CppArray* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Boolean, System.String[]) declare in UnityEngine.SearchService.ObjectSelectorHandlerWithLabelsAttribute
bool w_vtbVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbVs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,bool p0, Il2CppArray* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetDiscretionaryAclProtection(Boolean, Boolean) declare in System.Security.AccessControl.CommonSecurityDescriptor
bool w_vtbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Unity.Mathematics.bool2) declare in Unity.Mathematics.bool4
bool w_vtbbS_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbS_bb_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_bb_* pp2 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv2);
    S_bb_ p2 = pp2 ? *pp2 : S_bb_ {};

    typedef void (*FuncToCall)(void*,bool p0, bool p1, struct S_bb_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ClearRenderTarget(Boolean, Boolean, UnityEngine.Color) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtbbS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbS_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,bool p0, bool p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ClearRenderTarget(Boolean, Boolean, UnityEngine.Color, Single) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtbbS_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbS_r4r4r4r4_r4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, struct S_r4r4r4r4_ p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, System.DateTime, System.String, Int64, Int32, Boolean) declare in Codice.Client.Common.FsNode
bool w_vtbbS_u8_si8i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbS_u8_si8i4b");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, struct S_u8_ p2, Il2CppString* p3, int64_t p4, int32_t p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Boolean) declare in System.Text.UTF32Encoding
bool w_vtbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.bool2x2
bool w_vtbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SaveOptions(Boolean, Boolean, Boolean, Boolean, Boolean) declare in PlasticGui.WorkspaceWindow.Merge.MergeDialogOptions
bool w_vtbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbbbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, bool p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SaveParameters(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in PlasticGui.WorkspaceWindow.Merge.MergeDialogParameters
bool w_vtbbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbbbbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.bool2x4
bool w_vtbbbbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbbbbbbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.bool3x3
bool w_vtbbbbbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbbbbbbbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.bool3x4
bool w_vtbbbbbbbbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbbbbbbbbbbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    bool p10 = converter::Converter<bool>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    bool p11 = converter::Converter<bool>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in Unity.Mathematics.bool4x4
bool w_vtbbbbbbbbbbbbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbbbbbbbbbbbbbbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);

    if (checkJSArgument) {
        if (js_args_len != 16) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv11)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv12)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv13)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv14)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv15)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    bool p10 = converter::Converter<bool>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    bool p11 = converter::Converter<bool>::toCpp(apis, env, _sv11);
    // JSValToCSVal P any
    bool p12 = converter::Converter<bool>::toCpp(apis, env, _sv12);
    // JSValToCSVal P any
    bool p13 = converter::Converter<bool>::toCpp(apis, env, _sv13);
    // JSValToCSVal P any
    bool p14 = converter::Converter<bool>::toCpp(apis, env, _sv14);
    // JSValToCSVal P any
    bool p15 = converter::Converter<bool>::toCpp(apis, env, _sv15);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Boolean, Int32) declare in System.ComponentModel.DataObjectFieldAttribute
bool w_vtbbbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbbi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, bool p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Boolean, System.String) declare in UnityEngine.CustomGridBrushAttribute
bool w_vtbbbs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbbs");
    
    auto TIp3 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, bool p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Int32) declare in System.Security.AccessControl.DiscretionaryAcl
bool w_vtbbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Int32, System.Nullable`1[Mono.Security.Interface.MonoSslPolicyErrors]) declare in Mono.Security.Interface.ValidationResult
bool w_vtbbi4N_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbi4N_bi4_");
    
    auto TIp3 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    N_bi4_* pp3 = DataTransfer::GetPointer<N_bi4_>(apis, env, _sv3);
    N_bi4_ p3 = pp3 ? *pp3 : N_bi4_ {};

    typedef void (*FuncToCall)(void*,bool p0, bool p1, int32_t p2, struct N_bi4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Int32, Boolean) declare in System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension
bool w_vtbbi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbi4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, System.Security.AccessControl.ControlFlags, System.Security.Principal.SecurityIdentifier, System.Security.Principal.SecurityIdentifier, System.Security.AccessControl.SystemAcl, System.Security.AccessControl.DiscretionaryAcl) declare in System.Security.AccessControl.CommonSecurityDescriptor
bool w_vtbbi4oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbi4oooo");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, System.Security.AccessControl.RawSecurityDescriptor) declare in System.Security.AccessControl.CommonSecurityDescriptor
bool w_vtbbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbo");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Byte[], Int32) declare in System.Security.AccessControl.CommonSecurityDescriptor
bool w_vtbboi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbboi4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void UpdateStatusAndSize(Boolean, Boolean, Codice.Client.Common.FsReader, System.Action`2[GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Explorer.StatusLoader,GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Explorer.CalculatedSizes]) declare in GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Explorer.CalculatedFieldsUpdater
bool w_vtbboo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbboo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void CalculateMerge(Boolean, Boolean, PlasticGui.WorkspaceWindow.Merge.CalculatedMergeResult, PlasticGui.WorkspaceWindow.IIncomingChangesUpdater, PlasticGui.WorkspaceWindow.IShelvedChangesUpdater) declare in PlasticGui.WorkspaceWindow.Merge.MergeController
bool w_vtbbooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbooo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Single, Single, Single, Single) declare in UnityEngine.ColorUsageAttribute
bool w_vtbbr4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbr4r4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, float p2, float p3, float p4, float p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, System.String) declare in System.Security.AccessControl.CommonSecurityDescriptor
bool w_vtbbs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbs");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean, Byte, Int32) declare in System.Security.AccessControl.DiscretionaryAcl
bool w_vtbbu1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbu1i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, uint8_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Stop(Boolean, UnityEngine.ParticleSystemStopBehavior) declare in UnityEngine.ParticleSystem
bool w_vtbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Boolean, DisplayType, Boolean) declare in UnityEngine.Rendering.BoolParameter
bool w_vtbi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbi4Db");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTcpKeepAlive(Boolean, Int32, Int32) declare in System.Net.ServicePoint
bool w_vtbi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbi4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Boolean, System.Threading.EventResetMode, System.String) declare in System.Threading.EventWaitHandle
bool w_vtbi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbi4s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Boolean, System.Threading.EventResetMode, System.String, Boolean ByRef) declare in System.Threading.EventWaitHandle
bool w_vtbi4sPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbi4sPb");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    bool up3 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv3);
    bool* p3 = &up3;

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, Il2CppString* p2, bool* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<bool>::toScript(apis, env, *p3));
    
    return true;
}

// Void .ctor(Boolean, System.Threading.EventResetMode, System.String, Boolean ByRef, System.Security.AccessControl.EventWaitHandleSecurity) declare in System.Threading.EventWaitHandle
bool w_vtbi4sPbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbi4sPbo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    bool up3 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv3);
    bool* p3 = &up3;
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, Il2CppString* p2, bool* p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<bool>::toScript(apis, env, *p3));
    
    return true;
}

// Void .ctor(Boolean, UnityEngine.Events.UnityAction) declare in UnityEditor.AnimatedValues.AnimBool
bool w_vtbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbo");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,bool p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Refresh(Boolean, PlasticGui.Help.GuiHelpEvents, PlasticGui.Help.GuiHelp, IHelpPanel) declare in GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Explorer.ExplorerTreeModel
bool w_vtbooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbooo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,bool p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetEnabledFading(Boolean, Single) declare in UnityEngine.Cloth
bool w_vtbr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbr4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,bool p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Boolean, System.String) declare in System.Threading.Mutex
bool w_vtbs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,bool p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Boolean, System.String, Boolean ByRef) declare in System.Threading.Mutex
bool w_vtbsPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbsPb");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    bool up2 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv2);
    bool* p2 = &up2;

    typedef void (*FuncToCall)(void*,bool p0, Il2CppString* p1, bool* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<bool>::toScript(apis, env, *p2));
    
    return true;
}

// Void .ctor(Boolean, System.String, Boolean ByRef, System.Security.AccessControl.MutexSecurity) declare in System.Threading.Mutex
bool w_vtbsPbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbsPbo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    bool up2 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv2);
    bool* p2 = &up2;
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,bool p0, Il2CppString* p1, bool* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<bool>::toScript(apis, env, *p2));
    
    return true;
}

// Void Expect(Boolean, System.String, System.Object[]) declare in NUnit.Framework.AssertionHelper
bool w_vtbsVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbsVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,bool p0, Il2CppString* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Boolean, System.String, Boolean) declare in JetBrains.Rider.Model.Unity.ProfilingData
bool w_vtbsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbsb");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,bool p0, Il2CppString* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Boolean, System.String, System.Action`1[System.String], Boolean) declare in UnityEditor.MPE.ChannelClientScope
bool w_vtbsoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbsoDb");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,bool p0, Il2CppString* p1, Il2CppObject* p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Boolean, System.String, System.String) declare in JetBrains.Rider.Model.Unity.RunMethodResult
bool w_vtbss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbss");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,bool p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Boolean, System.String, System.String, System.String) declare in JetBrains.Rider.Model.Unity.BackendUnity.AnimationFindUsagesResult
bool w_vtbsss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbsss");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,bool p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Boolean, Byte, Byte, UnityEngine.Rendering.CompareFunction, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.CompareFunction, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.StencilOp) declare in UnityEngine.Rendering.StencilState
bool w_vtbu1u1i4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtbu1u1i4i4i4i4i4i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);

    if (checkJSArgument) {
        if (js_args_len != 11) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);

    typedef void (*FuncToCall)(void*,bool p0, uint8_t p1, uint8_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, int32_t p10, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void AppendChar(Char) declare in System.Security.SecureString
bool w_vtc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtc");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef void (*FuncToCall)(void*,Il2CppChar p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Char, Byte) declare in System.Buffers.StandardFormat
bool w_vtcDu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtcDu1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    uint8_t p1 = OptionalParameter<uint8_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,Il2CppChar p0, uint8_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteSurrogateCharEntity(Char, Char) declare in System.Xml.XmlTextWriter
bool w_vtcc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtcc");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,Il2CppChar p0, Il2CppChar p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Char, Int32) declare in System.String
bool w_vtci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtci4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,Il2CppChar p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Char, System.ConsoleKey, Boolean, Boolean, Boolean) declare in System.ConsoleKeyInfo
bool w_vtci4bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vtci4bbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,Il2CppChar p0, int32_t p1, bool p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Write(SByte) declare in System.IO.BinaryWriter
bool w_vti1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef void (*FuncToCall)(void*,int8_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte) declare in Unity.Burst.Intrinsics.v64
bool w_vti1i1i1i1i1i1i1i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti1i1i1i1i1i1i1i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int8_t p3 = converter::Converter<int8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int8_t p4 = converter::Converter<int8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int8_t p5 = converter::Converter<int8_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int8_t p6 = converter::Converter<int8_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int8_t p7 = converter::Converter<int8_t>::toCpp(apis, env, _sv7);

    typedef void (*FuncToCall)(void*,int8_t p0, int8_t p1, int8_t p2, int8_t p3, int8_t p4, int8_t p5, int8_t p6, int8_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void .ctor(SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte) declare in Unity.Burst.Intrinsics.v128
bool w_vti1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);

    if (checkJSArgument) {
        if (js_args_len != 16) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv11)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv12)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv13)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv14)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv15)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int8_t p3 = converter::Converter<int8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int8_t p4 = converter::Converter<int8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int8_t p5 = converter::Converter<int8_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int8_t p6 = converter::Converter<int8_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int8_t p7 = converter::Converter<int8_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int8_t p8 = converter::Converter<int8_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int8_t p9 = converter::Converter<int8_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int8_t p10 = converter::Converter<int8_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int8_t p11 = converter::Converter<int8_t>::toCpp(apis, env, _sv11);
    // JSValToCSVal P any
    int8_t p12 = converter::Converter<int8_t>::toCpp(apis, env, _sv12);
    // JSValToCSVal P any
    int8_t p13 = converter::Converter<int8_t>::toCpp(apis, env, _sv13);
    // JSValToCSVal P any
    int8_t p14 = converter::Converter<int8_t>::toCpp(apis, env, _sv14);
    // JSValToCSVal P any
    int8_t p15 = converter::Converter<int8_t>::toCpp(apis, env, _sv15);

    typedef void (*FuncToCall)(void*,int8_t p0, int8_t p1, int8_t p2, int8_t p3, int8_t p4, int8_t p5, int8_t p6, int8_t p7, int8_t p8, int8_t p9, int8_t p10, int8_t p11, int8_t p12, int8_t p13, int8_t p14, int8_t p15, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15,  method);

    
    return true;
}

// Void .ctor(SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte, SByte) declare in Unity.Burst.Intrinsics.v256
bool w_vti1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);
    pesapi_value _sv16 = apis->get_arg(info, 16);
    pesapi_value _sv17 = apis->get_arg(info, 17);
    pesapi_value _sv18 = apis->get_arg(info, 18);
    pesapi_value _sv19 = apis->get_arg(info, 19);
    pesapi_value _sv20 = apis->get_arg(info, 20);
    pesapi_value _sv21 = apis->get_arg(info, 21);
    pesapi_value _sv22 = apis->get_arg(info, 22);
    pesapi_value _sv23 = apis->get_arg(info, 23);
    pesapi_value _sv24 = apis->get_arg(info, 24);
    pesapi_value _sv25 = apis->get_arg(info, 25);
    pesapi_value _sv26 = apis->get_arg(info, 26);
    pesapi_value _sv27 = apis->get_arg(info, 27);
    pesapi_value _sv28 = apis->get_arg(info, 28);
    pesapi_value _sv29 = apis->get_arg(info, 29);
    pesapi_value _sv30 = apis->get_arg(info, 30);
    pesapi_value _sv31 = apis->get_arg(info, 31);

    if (checkJSArgument) {
        if (js_args_len != 32) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv11)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv12)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv13)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv14)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv15)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv16)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv17)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv18)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv19)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv20)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv21)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv22)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv23)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv24)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv25)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv26)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv27)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv28)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv29)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv30)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv31)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int8_t p3 = converter::Converter<int8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int8_t p4 = converter::Converter<int8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int8_t p5 = converter::Converter<int8_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int8_t p6 = converter::Converter<int8_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int8_t p7 = converter::Converter<int8_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int8_t p8 = converter::Converter<int8_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int8_t p9 = converter::Converter<int8_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int8_t p10 = converter::Converter<int8_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int8_t p11 = converter::Converter<int8_t>::toCpp(apis, env, _sv11);
    // JSValToCSVal P any
    int8_t p12 = converter::Converter<int8_t>::toCpp(apis, env, _sv12);
    // JSValToCSVal P any
    int8_t p13 = converter::Converter<int8_t>::toCpp(apis, env, _sv13);
    // JSValToCSVal P any
    int8_t p14 = converter::Converter<int8_t>::toCpp(apis, env, _sv14);
    // JSValToCSVal P any
    int8_t p15 = converter::Converter<int8_t>::toCpp(apis, env, _sv15);
    // JSValToCSVal P any
    int8_t p16 = converter::Converter<int8_t>::toCpp(apis, env, _sv16);
    // JSValToCSVal P any
    int8_t p17 = converter::Converter<int8_t>::toCpp(apis, env, _sv17);
    // JSValToCSVal P any
    int8_t p18 = converter::Converter<int8_t>::toCpp(apis, env, _sv18);
    // JSValToCSVal P any
    int8_t p19 = converter::Converter<int8_t>::toCpp(apis, env, _sv19);
    // JSValToCSVal P any
    int8_t p20 = converter::Converter<int8_t>::toCpp(apis, env, _sv20);
    // JSValToCSVal P any
    int8_t p21 = converter::Converter<int8_t>::toCpp(apis, env, _sv21);
    // JSValToCSVal P any
    int8_t p22 = converter::Converter<int8_t>::toCpp(apis, env, _sv22);
    // JSValToCSVal P any
    int8_t p23 = converter::Converter<int8_t>::toCpp(apis, env, _sv23);
    // JSValToCSVal P any
    int8_t p24 = converter::Converter<int8_t>::toCpp(apis, env, _sv24);
    // JSValToCSVal P any
    int8_t p25 = converter::Converter<int8_t>::toCpp(apis, env, _sv25);
    // JSValToCSVal P any
    int8_t p26 = converter::Converter<int8_t>::toCpp(apis, env, _sv26);
    // JSValToCSVal P any
    int8_t p27 = converter::Converter<int8_t>::toCpp(apis, env, _sv27);
    // JSValToCSVal P any
    int8_t p28 = converter::Converter<int8_t>::toCpp(apis, env, _sv28);
    // JSValToCSVal P any
    int8_t p29 = converter::Converter<int8_t>::toCpp(apis, env, _sv29);
    // JSValToCSVal P any
    int8_t p30 = converter::Converter<int8_t>::toCpp(apis, env, _sv30);
    // JSValToCSVal P any
    int8_t p31 = converter::Converter<int8_t>::toCpp(apis, env, _sv31);

    typedef void (*FuncToCall)(void*,int8_t p0, int8_t p1, int8_t p2, int8_t p3, int8_t p4, int8_t p5, int8_t p6, int8_t p7, int8_t p8, int8_t p9, int8_t p10, int8_t p11, int8_t p12, int8_t p13, int8_t p14, int8_t p15, int8_t p16, int8_t p17, int8_t p18, int8_t p19, int8_t p20, int8_t p21, int8_t p22, int8_t p23, int8_t p24, int8_t p25, int8_t p26, int8_t p27, int8_t p28, int8_t p29, int8_t p30, int8_t p31, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30, p31,  method);

    
    return true;
}

// Void .ctor(SByte, SByte, Int32) declare in NUnit.Framework.RandomAttribute
bool w_vti1i1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti1i1i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int8_t p0, int8_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Write(Int16) declare in System.IO.BinaryWriter
bool w_vti2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef void (*FuncToCall)(void*,int16_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Int16, Boolean) declare in Codice.Client.BaseCommands.Download.FileDownloader
bool w_vti2b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti2b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int16_t p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int16, Int16) declare in UnityEngine.Rendering.SortingLayerRange
bool w_vti2i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti2i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int16_t p0, int16_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int16, Int16, Int16, Int16) declare in Unity.Burst.Intrinsics.v64
bool w_vti2i2i2i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti2i2i2i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int16_t p3 = converter::Converter<int16_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int16_t p0, int16_t p1, int16_t p2, int16_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int16, Int16, Int16, Int16, Int16, Int16, Int16, Int16) declare in Unity.Burst.Intrinsics.v128
bool w_vti2i2i2i2i2i2i2i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti2i2i2i2i2i2i2i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int16_t p3 = converter::Converter<int16_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int16_t p4 = converter::Converter<int16_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int16_t p5 = converter::Converter<int16_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int16_t p6 = converter::Converter<int16_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int16_t p7 = converter::Converter<int16_t>::toCpp(apis, env, _sv7);

    typedef void (*FuncToCall)(void*,int16_t p0, int16_t p1, int16_t p2, int16_t p3, int16_t p4, int16_t p5, int16_t p6, int16_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void .ctor(Int16, Int16, Int16, Int16, Int16, Int16, Int16, Int16, Int16, Int16, Int16, Int16, Int16, Int16, Int16, Int16) declare in Unity.Burst.Intrinsics.v256
bool w_vti2i2i2i2i2i2i2i2i2i2i2i2i2i2i2i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti2i2i2i2i2i2i2i2i2i2i2i2i2i2i2i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);

    if (checkJSArgument) {
        if (js_args_len != 16) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv11)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv12)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv13)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv14)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv15)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int16_t p3 = converter::Converter<int16_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int16_t p4 = converter::Converter<int16_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int16_t p5 = converter::Converter<int16_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int16_t p6 = converter::Converter<int16_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int16_t p7 = converter::Converter<int16_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int16_t p8 = converter::Converter<int16_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int16_t p9 = converter::Converter<int16_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int16_t p10 = converter::Converter<int16_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int16_t p11 = converter::Converter<int16_t>::toCpp(apis, env, _sv11);
    // JSValToCSVal P any
    int16_t p12 = converter::Converter<int16_t>::toCpp(apis, env, _sv12);
    // JSValToCSVal P any
    int16_t p13 = converter::Converter<int16_t>::toCpp(apis, env, _sv13);
    // JSValToCSVal P any
    int16_t p14 = converter::Converter<int16_t>::toCpp(apis, env, _sv14);
    // JSValToCSVal P any
    int16_t p15 = converter::Converter<int16_t>::toCpp(apis, env, _sv15);

    typedef void (*FuncToCall)(void*,int16_t p0, int16_t p1, int16_t p2, int16_t p3, int16_t p4, int16_t p5, int16_t p6, int16_t p7, int16_t p8, int16_t p9, int16_t p10, int16_t p11, int16_t p12, int16_t p13, int16_t p14, int16_t p15, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15,  method);

    
    return true;
}

// Void .ctor(Int16, Int16, Int32) declare in NUnit.Framework.RandomAttribute
bool w_vti2i2i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti2i2i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int16_t p0, int16_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ProcessMergesForConflicts(Codice.Client.Commands.MergeContributorType, Codice.Client.Commands.IToolLauncher, System.Collections.Generic.List`1[PlasticGui.Gluon.WorkspaceWindow.Views.IncomingChanges.IncomingChangeInfo], System.Action, PlasticGui.EndOperationDelegateForUpdateProgress, System.Action) declare in PlasticGui.Gluon.WorkspaceWindow.Views.IncomingChanges.IncomingChangesViewLogic
bool w_vti2ooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti2ooooo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef void (*FuncToCall)(void*,int16_t p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Codice.CM.Common.EnumCompressionType, System.String) declare in Codice.CM.Common.EncryptionSettings
bool w_vti2s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti2s");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int16_t p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy) declare in System.AppDomain
bool w_vti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef void (*FuncToCall)(void*,int32_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void CollapseItem(Int32, Boolean) declare in UnityEngine.UIElements.BaseTreeView
bool w_vti4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Db");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Set(Int32, Int32) declare in UnityEditor.Media.MediaRational
bool w_vti4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Di4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.BuiltinRenderTextureType, Int32, UnityEngine.CubemapFace, Int32) declare in UnityEngine.Rendering.RenderTargetIdentifier
bool w_vti4Di4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Di4Di4Di4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void RecalculateUVDistributionMetric(Int32, Single) declare in UnityEngine.Mesh
bool w_vti4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Dr4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int32, System.String) declare in Microsoft.Extensions.Logging.EventId
bool w_vti4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Ds");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ConfigureColorStoreAction(UnityEngine.Rendering.RenderBufferStoreAction, UInt32) declare in UnityEngine.Rendering.Universal.ScriptableRenderPass
bool w_vti4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Du4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    uint32_t p1 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetByIndex(Int32, System.Object) declare in System.Collections.SortedList
bool w_vti4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4O");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Insert(Int32, System.Object, System.Object) declare in System.Collections.Specialized.OrderedDictionary
bool w_vti4OO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4OO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.Collections.Specialized.NotifyCollectionChangedAction, System.Object, System.Object, Int32) declare in System.Collections.Specialized.NotifyCollectionChangedEventArgs
bool w_vti4OOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4OOi4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(System.Collections.Specialized.NotifyCollectionChangedAction, System.Object, Int32) declare in System.Collections.Specialized.NotifyCollectionChangedEventArgs
bool w_vti4Oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Oi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.Collections.Specialized.NotifyCollectionChangedAction, System.Object, Int32, Int32) declare in System.Collections.Specialized.NotifyCollectionChangedEventArgs
bool w_vti4Oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Log(UnityEngine.LogType, System.Object, UnityEngine.Object) declare in UnityEngine.Logger
bool w_vti4Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Oo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void GetChannels(Int32, Unity.Collections.NativeArray`1[System.UInt16] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Vector3] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Vector2] ByRef) declare in UnityEngine.U2D.SpriteShapeRenderer
bool w_vti4PS_Pvi4i4i4S_pi4i4_i4_PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_Pvi4i4i4S_pi4i4_i4_PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_Pvi4i4i4S_pi4i4_i4_* p1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_Pvi4i4i4S_pi4i4_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_Pvi4i4i4S_pi4i4_i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p2 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p3 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_Pvi4i4i4S_pi4i4_i4_* p1, struct S_Pvi4i4i4i4S_pi4i4__* p2, struct S_Pvi4i4i4i4S_pi4i4__* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
            
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    return true;
}

// Void GetChannels(Int32, Unity.Collections.NativeArray`1[System.UInt16] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Vector3] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Vector2] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Color32] ByRef) declare in UnityEngine.U2D.SpriteShapeRenderer
bool w_vti4PS_Pvi4i4i4S_pi4i4_i4_PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_Pvi4i4i4S_pi4i4_i4_PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_Pvi4i4i4S_pi4i4_i4_* p1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_Pvi4i4i4S_pi4i4_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_Pvi4i4i4S_pi4i4_i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p2 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p3 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p4 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p4 = &up4;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_Pvi4i4i4S_pi4i4_i4_* p1, struct S_Pvi4i4i4i4S_pi4i4__* p2, struct S_Pvi4i4i4i4S_pi4i4__* p3, struct S_Pvi4i4i4i4S_pi4i4__* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
            
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
            
    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    return true;
}

// Void GetChannels(Int32, Unity.Collections.NativeArray`1[System.UInt16] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Vector3] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Vector2] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Color32] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Vector4] ByRef) declare in UnityEngine.U2D.SpriteShapeRenderer
bool w_vti4PS_Pvi4i4i4S_pi4i4_i4_PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_Pvi4i4i4S_pi4i4_i4_PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_Pvi4i4i4S_pi4i4_i4_* p1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_Pvi4i4i4S_pi4i4_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_Pvi4i4i4S_pi4i4_i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p2 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p3 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p4 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p4 = &up4;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p5 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv5)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p5 = &up5;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_Pvi4i4i4S_pi4i4_i4_* p1, struct S_Pvi4i4i4i4S_pi4i4__* p2, struct S_Pvi4i4i4i4S_pi4i4__* p3, struct S_Pvi4i4i4i4S_pi4i4__* p4, struct S_Pvi4i4i4i4S_pi4i4__* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
            
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
            
    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
            
    if (p5 == &up5)
    {
        apis->update_boxed_value(env, _sv5, DataTransfer::CopyValueType(apis, env, *p5, TIp5));
    }
    
    return true;
}

// Void GetChannels(Int32, Unity.Collections.NativeArray`1[System.UInt16] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Vector3] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Vector2] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Color32] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Vector4] ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Vector3] ByRef) declare in UnityEngine.U2D.SpriteShapeRenderer
bool w_vti4PS_Pvi4i4i4S_pi4i4_i4_PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_Pvi4i4i4S_pi4i4_i4_PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__PS_Pvi4i4i4i4S_pi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_Pvi4i4i4S_pi4i4_i4_* p1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_Pvi4i4i4S_pi4i4_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_Pvi4i4i4S_pi4i4_i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p2 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p3 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p4 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p4 = &up4;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p5 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv5)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p5 = &up5;
    }
        
    // JSValToCSVal Pstruct
    S_Pvi4i4i4i4S_pi4i4__* p6 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, apis->unboxing(env, _sv6)); // valuetype ref
    S_Pvi4i4i4i4S_pi4i4__ up6;
    if (!p6) {
        memset(&up6, 0, sizeof(S_Pvi4i4i4i4S_pi4i4__));
        p6 = &up6;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_Pvi4i4i4S_pi4i4_i4_* p1, struct S_Pvi4i4i4i4S_pi4i4__* p2, struct S_Pvi4i4i4i4S_pi4i4__* p3, struct S_Pvi4i4i4i4S_pi4i4__* p4, struct S_Pvi4i4i4i4S_pi4i4__* p5, struct S_Pvi4i4i4i4S_pi4i4__* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
            
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
            
    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
            
    if (p5 == &up5)
    {
        apis->update_boxed_value(env, _sv5, DataTransfer::CopyValueType(apis, env, *p5, TIp5));
    }
            
    if (p6 == &up6)
    {
        apis->update_boxed_value(env, _sv6, DataTransfer::CopyValueType(apis, env, *p6, TIp6));
    }
    
    return true;
}

// Void GetUpdatePrefabInstancesEvent(Int32, UnityEditor.UpdatePrefabInstancesEventArgs ByRef) declare in UnityEditor.ObjectChangeEventStream
bool w_vti4PS_S_i4_S_Pvi4S_pi4i4___(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_S_i4_S_Pvi4S_pi4i4___");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_S_i4_S_Pvi4S_pi4i4___* p1 = DataTransfer::GetPointer<S_S_i4_S_Pvi4S_pi4i4___>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_i4_S_Pvi4S_pi4i4___ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_i4_S_Pvi4S_pi4i4___));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_S_i4_S_Pvi4S_pi4i4___* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void GetChangeSceneEvent(Int32, UnityEditor.ChangeSceneEventArgs ByRef) declare in UnityEditor.ObjectChangeEventStream
bool w_vti4PS_S_i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_S_i4__");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_S_i4__* p1 = DataTransfer::GetPointer<S_S_i4__>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_i4__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_i4__));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_S_i4__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void TriggerSubEmitter(Int32, Particle ByRef) declare in UnityEngine.ParticleSystem
bool w_vti4PS_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_i4u1u1u1u1_u4u4r4r4i4r4r4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void GetCreateAssetObjectEvent(Int32, UnityEditor.CreateAssetObjectEventArgs ByRef) declare in UnityEditor.ObjectChangeEventStream
bool w_vti4PS_S_u4u4u4u4_i4S_i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_S_u4u4u4u4_i4S_i4__");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_S_u4u4u4u4_i4S_i4__* p1 = DataTransfer::GetPointer<S_S_u4u4u4u4_i4S_i4__>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_u4u4u4u4_i4S_i4__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_u4u4u4u4_i4S_i4__));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_S_u4u4u4u4_i4S_i4__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void GetCreateGameObjectHierarchyEvent(Int32, UnityEditor.CreateGameObjectHierarchyEventArgs ByRef) declare in UnityEditor.ObjectChangeEventStream
bool w_vti4PS_i4S_i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_i4S_i4__");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i4S_i4__* p1 = DataTransfer::GetPointer<S_i4S_i4__>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4S_i4__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4S_i4__));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4S_i4__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void GetDestroyGameObjectHierarchyEvent(Int32, UnityEditor.DestroyGameObjectHierarchyEventArgs ByRef) declare in UnityEditor.ObjectChangeEventStream
bool w_vti4PS_i4i4S_i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_i4i4S_i4__");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i4i4S_i4__* p1 = DataTransfer::GetPointer<S_i4i4S_i4__>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4S_i4__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i4S_i4__));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i4S_i4__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void GetChangeGameObjectParentEvent(Int32, UnityEditor.ChangeGameObjectParentEventArgs ByRef) declare in UnityEditor.ObjectChangeEventStream
bool w_vti4PS_i4i4i4S_i4_S_i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_i4i4i4S_i4_S_i4__");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i4i4i4S_i4_S_i4__* p1 = DataTransfer::GetPointer<S_i4i4i4S_i4_S_i4__>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4S_i4_S_i4__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i4i4S_i4_S_i4__));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i4i4S_i4_S_i4__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void GetMirrorBlitModeByIndex(Int32, UnityEngine.XR.XRMirrorViewBlitModeDesc ByRef) declare in UnityEngine.XR.XRDisplaySubsystemDescriptor
bool w_vti4PS_i4s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_i4s_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i4s_* p1 = DataTransfer::GetPointer<S_i4s_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4s_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4s_));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4s_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void GetRenderPass(Int32, XRRenderPass ByRef) declare in UnityEngine.XR.XRDisplaySubsystem
bool w_vti4PS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p_* p1 = DataTransfer::GetPointer<S_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p_));
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    return true;
}

// Void TryEnter(Int32, Boolean ByRef) declare in System.Threading.SpinLock
bool w_vti4Pb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Pb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;

    typedef void (*FuncToCall)(void*,int32_t p0, bool* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    
    return true;
}

// Void ReadTextureImportInstructions(UnityEditor.BuildTarget, UnityEngine.TextureFormat ByRef, UnityEngine.ColorSpace ByRef, Int32 ByRef) declare in UnityEditor.TextureImporter
bool w_vti4Pi4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Pi4Pi4Pi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t* p1, int32_t* p2, int32_t* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    return true;
}

// Void IndexWordComponents(Int32, System.String ByRef) declare in UnityEditor.Search.ObjectIndexer
bool w_vti4Ps(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Ps");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString** p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    
    return true;
}

// Void IndexWord(Int32, System.String ByRef, Boolean, Int32) declare in UnityEditor.Search.ObjectIndexer
bool w_vti4PsDbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4PsDbDi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString** p1, bool p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    
    return true;
}

// Void IndexWord(Int32, System.String ByRef, Int32, Boolean, Int32) declare in UnityEditor.Search.ObjectIndexer
bool w_vti4Psi4bDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Psi4bDi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString** p1, int32_t p2, bool p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    
    return true;
}

// Void GetKernelThreadGroupSizes(Int32, UInt32 ByRef, UInt32 ByRef, UInt32 ByRef) declare in UnityEngine.ComputeShader
bool w_vti4Pu4Pu4Pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Pu4Pu4Pu4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    uint32_t up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;
    // JSValToCSVal P primitive
    uint32_t up2 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv2);
    uint32_t* p2 = &up2;
    // JSValToCSVal P primitive
    uint32_t up3 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv3);
    uint32_t* p3 = &up3;

    typedef void (*FuncToCall)(void*,int32_t p0, uint32_t* p1, uint32_t* p2, uint32_t* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint32_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<uint32_t>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<uint32_t>::toScript(apis, env, *p3));
    
    return true;
}

// Void SetVertexBufferParams(Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.VertexAttributeDescriptor]) declare in UnityEngine.Mesh
bool w_vti4S_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSubMesh(Int32, UnityEngine.Rendering.SubMeshDescriptor, UnityEngine.Rendering.MeshUpdateFlags) declare in UnityEngine.Mesh
bool w_vti4S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_Di4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_>(apis, env, _sv1);
    S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_ {};
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void CopyTo(Int32, System.Span`1[System.Char], Int32) declare in System.Text.StringBuilder
bool w_vti4S_S_p_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_S_p_i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_S_p_i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetShadowCullingPlane(Int32, UnityEngine.Plane) declare in UnityEngine.Rendering.CameraProperties
bool w_vti4S_S_r4r4r4_r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_S_r4r4r4_r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_S_r4r4r4_r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetTreeInstance(Int32, UnityEngine.TreeInstance) declare in UnityEngine.TerrainData
bool w_vti4S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_>(apis, env, _sv1);
    S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetDateTimeOffset(Int32, System.DateTimeOffset) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_S_u8_i2_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSqlInt16(Int32, System.Data.SqlTypes.SqlInt16) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_bi2_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bi2_* pp1 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv1);
    S_bi2_ p1 = pp1 ? *pp1 : S_bi2_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_bi2_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSqlInt32(Int32, System.Data.SqlTypes.SqlInt32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_bi4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bi4_* pp1 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv1);
    S_bi4_ p1 = pp1 ? *pp1 : S_bi4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_bi4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSqlDateTime(Int32, System.Data.SqlTypes.SqlDateTime) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_bi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_bi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bi4i4_* pp1 = DataTransfer::GetPointer<S_bi4i4_>(apis, env, _sv1);
    S_bi4i4_ p1 = pp1 ? *pp1 : S_bi4i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_bi4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSqlInt64(Int32, System.Data.SqlTypes.SqlInt64) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_bi8_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bi8_* pp1 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv1);
    S_bi8_ p1 = pp1 ? *pp1 : S_bi8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_bi8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSqlSingle(Int32, System.Data.SqlTypes.SqlSingle) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_br4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_br4_* pp1 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv1);
    S_br4_ p1 = pp1 ? *pp1 : S_br4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_br4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSqlDouble(Int32, System.Data.SqlTypes.SqlDouble) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_br8_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_br8_* pp1 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv1);
    S_br8_ p1 = pp1 ? *pp1 : S_br8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_br8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSqlByte(Int32, System.Data.SqlTypes.SqlByte) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_bu1_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_bu1_* pp1 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv1);
    S_bu1_ p1 = pp1 ? *pp1 : S_bu1_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_bu1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Transactions.TransactionScopeOption, System.Transactions.TransactionOptions) declare in System.Transactions.TransactionScope
bool w_vti4S_i4S_i8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4S_i8__");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4S_i8__* pp1 = DataTransfer::GetPointer<S_i4S_i8__>(apis, env, _sv1);
    S_i4S_i8__ p1 = pp1 ? *pp1 : S_i4S_i8__ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4S_i8__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Transactions.TransactionScopeOption, System.Transactions.TransactionOptions, System.Transactions.EnterpriseServicesInteropOption) declare in System.Transactions.TransactionScope
bool w_vti4S_i4S_i8__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4S_i8__i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4S_i8__* pp1 = DataTransfer::GetPointer<S_i4S_i8__>(apis, env, _sv1);
    S_i4S_i8__ p1 = pp1 ? *pp1 : S_i4S_i8__ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4S_i8__ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetShaderPassName(Int32, UnityEngine.Rendering.ShaderTagId) declare in UnityEngine.Rendering.DrawingSettings
bool w_vti4S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int32, UnityEngine.SceneManagement.Scene, Int32, UnityEngine.SceneManagement.Scene, Int32) declare in UnityEditor.ChangeGameObjectParentEventArgs
bool w_vti4S_i4_i4S_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4_i4S_i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_i4_* pp3 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv3);
    S_i4_ p3 = pp3 ? *pp3 : S_i4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4_ p1, int32_t p2, struct S_i4_ p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetGuid(Int32, System.Guid) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int32, Unity.Mathematics.int2) declare in Unity.Mathematics.int3
bool w_vti4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.Universal.RenderPassEvent, UnityEngine.Rendering.RenderQueueRange, UnityEngine.LayerMask) declare in UnityEngine.Rendering.Universal.Internal.DepthNormalOnlyPass
bool w_vti4S_i4i4_S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4_S_i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4_* pp2 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv2);
    S_i4_ p2 = pp2 ? *pp2 : S_i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i4_ p1, struct S_i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Unity.Mathematics.int2, Int32) declare in Unity.Mathematics.int4
bool w_vti4S_i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Unity.Mathematics.int3) declare in Unity.Mathematics.int4
bool w_vti4S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, UnityEngine.RenderTextureDescriptor) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4S_i4i4i4i4i4i4i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, UnityEngine.RenderTextureDescriptor, UnityEngine.FilterMode) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4S_i4i4i4i4i4i4i4i4i4i4i4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4i4i4i4i4i4i4i4i4i4i4i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetDecimal(Int32, System.Decimal) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i4i4i4u8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetRandomWriteTarget(Int32, UnityEngine.Rendering.RenderTargetIdentifier) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4S_i4i4i4pi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4i4pi4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i4i4pi4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderTextureFormat, UnityEngine.Rendering.RenderTargetIdentifier, Boolean, Boolean, Boolean) declare in UnityEngine.Rendering.AttachmentDescriptor
bool w_vti4S_i4i4i4pi4i4i4_DbDbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4i4pi4i4i4_DbDbDb");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i4i4pi4i4i4_ p1, bool p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetGlobalTexture(Int32, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTextureSubElement) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4S_i4i4i4pi4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4i4pi4i4i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4i4i4pi4i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Log(Microsoft.Extensions.Logging.ILogger, Microsoft.Extensions.Logging.LogLevel, Microsoft.Extensions.Logging.EventId, System.Exception, System.String, System.Object[]) declare in Microsoft.Extensions.Logging.LoggerExtensions
bool w_vti4S_i4s_osVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4s_osVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4s_* pp1 = DataTransfer::GetPointer<S_i4s_>(apis, env, _sv1);
    S_i4s_ p1 = pp1 ? *pp1 : S_i4s_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4s_ p1, Il2CppObject* p2, Il2CppString* p3, Il2CppArray* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Log(Microsoft.Extensions.Logging.ILogger, Microsoft.Extensions.Logging.LogLevel, Microsoft.Extensions.Logging.EventId, System.String, System.Object[]) declare in Microsoft.Extensions.Logging.LoggerExtensions
bool w_vti4S_i4s_sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4s_sVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4s_* pp1 = DataTransfer::GetPointer<S_i4s_>(apis, env, _sv1);
    S_i4s_ p1 = pp1 ? *pp1 : S_i4s_ {};
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i4s_ p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTimeSpan(Int32, System.TimeSpan) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i8_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Net.Cache.HttpCacheAgeControl, System.TimeSpan, System.TimeSpan) declare in System.Net.Cache.HttpRequestCachePolicy
bool w_vti4S_i8_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i8_S_i8_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
    // JSValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i8_ p1, struct S_i8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.Net.Cache.HttpCacheAgeControl, System.TimeSpan, System.TimeSpan, System.DateTime) declare in System.Net.Cache.HttpRequestCachePolicy
bool w_vti4S_i8_S_i8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i8_S_i8_S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
    // JSValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
    // JSValToCSVal struct
    S_u8_* pp3 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv3);
    S_u8_ p3 = pp3 ? *pp3 : S_u8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i8_ p1, struct S_i8_ p2, struct S_u8_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(System.Transactions.TransactionScopeOption, System.TimeSpan, System.Transactions.TransactionScopeAsyncFlowOption) declare in System.Transactions.TransactionScope
bool w_vti4S_i8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i8_i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_i8_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetSqlBinary(Int32, System.Data.SqlTypes.SqlBinary) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_o_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_o_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSource(Int32, UnityEngine.Animations.ConstraintSource) declare in UnityEngine.Animations.AimConstraint
bool w_vti4S_or4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_or4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_or4_* pp1 = DataTransfer::GetPointer<S_or4_>(apis, env, _sv1);
    S_or4_ p1 = pp1 ? *pp1 : S_or4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_or4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.UIElements.BackgroundPositionKeyword, UnityEngine.UIElements.Length) declare in UnityEngine.UIElements.BackgroundPosition
bool w_vti4S_r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4i4_* pp1 = DataTransfer::GetPointer<S_r4i4_>(apis, env, _sv1);
    S_r4i4_ p1 = pp1 ? *pp1 : S_r4i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_r4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetTextureOffset(Int32, UnityEngine.Vector2) declare in UnityEngine.Material
bool w_vti4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CreatePrimitive(Int32, UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.PolygonCollider2D
bool w_vti4S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4_S_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetIKPosition(UnityEngine.AvatarIKGoal, UnityEngine.Vector3) declare in UnityEngine.Animator
bool w_vti4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetIKRotation(UnityEngine.AvatarIKGoal, UnityEngine.Quaternion) declare in UnityEngine.Animator
bool w_vti4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetMask(TMPro.MaskingTypes, UnityEngine.Vector4, Single, Single) declare in TMPro.TextMeshPro
bool w_vti4S_r4r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4r4r4_r4r4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_r4r4r4r4_ p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void ClearRenderTarget(UnityEngine.Rendering.RTClearFlags, UnityEngine.Color, Single, UInt32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4S_r4r4r4r4_r4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4r4r4_r4u4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_r4r4r4r4_ p1, float p2, uint32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetStereoProjectionMatrix(StereoscopicEye, UnityEngine.Matrix4x4) declare in UnityEngine.Camera
bool w_vti4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_Item(Int32, System.Collections.Generic.KeyValuePair`2[System.String,System.Object]) declare in System.Diagnostics.TagList
bool w_vti4S_sO_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_sO_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_sO_* pp1 = DataTransfer::GetPointer<S_sO_>(apis, env, _sv1);
    S_sO_ p1 = pp1 ? *pp1 : S_sO_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_sO_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Security.Cryptography.PbeEncryptionAlgorithm, System.Security.Cryptography.HashAlgorithmName, Int32) declare in System.Security.Cryptography.PbeParameters
bool w_vti4S_s_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_s_i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(apis, env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_s_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetSqlString(Int32, System.Data.SqlTypes.SqlString) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_soi4i4b_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_soi4i4b_* pp1 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv1);
    S_soi4i4b_ p1 = pp1 ? *pp1 : S_soi4i4b_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_soi4i4b_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSqlBoolean(Int32, System.Data.SqlTypes.SqlBoolean) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_u1_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u1_* pp1 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv1);
    S_u1_ p1 = pp1 ? *pp1 : S_u1_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_u1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSqlDecimal(Int32, System.Data.SqlTypes.SqlDecimal) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_u1u1u1u1u4u4u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv1);
    S_u1u1u1u1u4u4u4u4_ p1 = pp1 ? *pp1 : S_u1u1u1u1u4u4u4u4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_u1u1u1u1u4u4u4u4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_Item(Int32, Unity.Mathematics.half) declare in Unity.Mathematics.half2
bool w_vti4S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_u2_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_u2_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetDateTime(Int32, System.DateTime) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_u8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Codice.Client.BaseCommands.LayoutFilters.SinceTimeType, System.DateTime, Boolean, System.DateTime, System.String) declare in Codice.Client.BaseCommands.LayoutFilters.DateFilter
bool w_vti4S_u8_bS_u8_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_u8_bS_u8_s");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_u8_* pp3 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv3);
    S_u8_ p3 = pp3 ? *pp3 : S_u8_ {};
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, struct S_u8_ p1, bool p2, struct S_u8_ p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetVertexBufferParams(Int32, UnityEngine.Rendering.VertexAttributeDescriptor[]) declare in UnityEngine.Mesh
bool w_vti4VS_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4VS_i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype params
    Il2CppArray* p1 = Params<S_i4i4i4i4_>::PackValueType(apis, env, info, TIp1, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppArray* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetInts(Int32, Int32[]) declare in UnityEngine.ComputeShader
bool w_vti4Vi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Vi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive params
    Il2CppArray* p1 = Params<int32_t>::PackPrimitive(apis, env, info, TIp1, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppArray* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetFloats(Int32, Single[]) declare in UnityEngine.ComputeShader
bool w_vti4Vr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Vr4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive params
    Il2CppArray* p1 = Params<float>::PackPrimitive(apis, env, info, TIp1, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppArray* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int32, System.String[]) declare in System.Dynamic.CallInfo
bool w_vti4Vs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Vs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, js_args_len, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppArray* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_Item(Int32, Boolean) declare in System.Reflection.ParameterModifier
bool w_vti4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ExpandItemByIndex(Int32, Boolean, Boolean) declare in UnityEngine.UIElements.BaseTreeViewController
bool w_vti4bDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4bDb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void LightmapEmissionFlagsProperty(Int32, Boolean, Boolean) declare in UnityEditor.MaterialEditor
bool w_vti4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4bb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetShapeAdjacentVertices(Int32, Boolean, Boolean, UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.PhysicsShapeGroup2D
bool w_vti4bbS_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4bbS_r4r4_S_r4r4_");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, bool p2, struct S_r4r4_ p3, struct S_r4r4_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, Boolean, Boolean, Char) declare in UnityEngine.UIElements.TextField
bool w_vti4bbc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4bbc");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    Il2CppChar p3 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, bool p2, Il2CppChar p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(System.IO.Pipes.PipeDirection, Boolean, Boolean, Microsoft.Win32.SafeHandles.SafePipeHandle) declare in System.IO.Pipes.NamedPipeClientStream
bool w_vti4bbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4bbo");
    
    auto TIp3 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, bool p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Type, Boolean, System.Collections.Generic.List`1[PlasticGui.WorkspaceWindow.Merge.MergeChangeInfo], Boolean) declare in PlasticGui.WorkspaceWindow.Merge.MergeChangesCategory
bool w_vti4bob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4bob");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, Il2CppObject* p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_Chars(Int32, Char) declare in System.Text.StringBuilder
bool w_vti4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4c");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppChar p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_Item(SByte[], Int32, SByte) declare in PuertsIl2cpp.ArrayExtension
bool w_vti4i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, int8_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetInt16(Int32, Int16) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, int16_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int32, Int16, Int16, Byte[]) declare in System.Guid
bool w_vti4i2i2o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i2i2o");
    
    auto TIp3 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int16_t p1, int16_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int32, Int16, Int16, Byte, Byte, Byte, Byte, Byte, Byte, Byte, Byte) declare in System.Guid
bool w_vti4i2i2u1u1u1u1u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i2i2u1u1u1u1u1u1u1u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);

    if (checkJSArgument) {
        if (js_args_len != 11) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv10)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    uint8_t p6 = converter::Converter<uint8_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    uint8_t p7 = converter::Converter<uint8_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    uint8_t p8 = converter::Converter<uint8_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    uint8_t p9 = converter::Converter<uint8_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    uint8_t p10 = converter::Converter<uint8_t>::toCpp(apis, env, _sv10);

    typedef void (*FuncToCall)(void*,int32_t p0, int16_t p1, int16_t p2, uint8_t p3, uint8_t p4, uint8_t p5, uint8_t p6, uint8_t p7, uint8_t p8, uint8_t p9, uint8_t p10, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void RemoveRange(Int32, Int32) declare in System.Collections.ArrayList
bool w_vti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Initialize(Int32, Int32, Boolean) declare in UnityEngine.Rendering.RTHandleSystem
bool w_vti4i4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4Db");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Boolean, Boolean) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.TextureDesc
bool w_vti4i4DbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4DbDb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.MeshTopology) declare in UnityEngine.Rendering.SubMeshDescriptor
bool w_vti4i4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4Di4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.UIElements.SliderDirection, Single) declare in UnityEngine.UIElements.SliderInt
bool w_vti4i4Di4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4Di4Dr4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void TraceData(System.Diagnostics.TraceEventType, Int32, System.Object) declare in System.Diagnostics.TraceSource
bool w_vti4i4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4O");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, System.Object, System.Object) declare in Codice.CM.Client.Differences.ItemDiff
bool w_vti4i4OO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4OO");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.SceneManagement.Scene) declare in UnityEditor.DestroyGameObjectHierarchyEventArgs
bool w_vti4i4S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4S_i4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4_* pp2 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv2);
    S_i4_ p2 = pp2 ? *pp2 : S_i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, struct S_i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Unity.Mathematics.int2) declare in Unity.Mathematics.int4
bool w_vti4i4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4S_i4i4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, struct S_i4i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetBuffer(Int32, Int32, System.ArraySegment`1[System.Byte]) declare in System.Net.WebSockets.ClientWebSocketOptions
bool w_vti4i4S_oi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4S_oi4i4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_oi4i4_* pp2 = DataTransfer::GetPointer<S_oi4i4_>(apis, env, _sv2);
    S_oi4i4_ p2 = pp2 ? *pp2 : S_oi4i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, struct S_oi4i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetShapeVertex(Int32, Int32, UnityEngine.Vector2) declare in UnityEngine.PhysicsShapeGroup2D
bool w_vti4i4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4S_r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, struct S_r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPixel(Int32, Int32, UnityEngine.Color) declare in UnityEngine.Texture2D
bool w_vti4i4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4S_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPixel(Int32, Int32, UnityEngine.Color, Int32) declare in UnityEngine.Texture2D
bool w_vti4i4S_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4S_r4r4r4r4_i4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, struct S_r4r4r4r4_ p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Activate(Int32, Int32, UnityEngine.RefreshRate) declare in UnityEngine.Display
bool w_vti4i4S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4S_u4u4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv2);
    S_u4u4_ p2 = pp2 ? *pp2 : S_u4u4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, struct S_u4u4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void TraceData(System.Diagnostics.TraceEventType, Int32, System.Object[]) declare in System.Diagnostics.TraceSource
bool w_vti4i4VO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4VO");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32[]) declare in UnityEngine.GUITargetAttribute
bool w_vti4i4Vi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4Vi4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive params
    Il2CppArray* p2 = Params<int32_t>::PackPrimitive(apis, env, info, TIp2, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, Boolean) declare in System.Net.Sockets.Socket
bool w_vti4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, System.Net.WebSockets.WebSocketMessageType, Boolean, System.Nullable`1[System.Net.WebSockets.WebSocketCloseStatus], System.String) declare in System.Net.WebSockets.WebSocketReceiveResult
bool w_vti4i4bN_bi4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4bN_bi4_s");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    N_bi4_* pp3 = DataTransfer::GetPointer<N_bi4_>(apis, env, _sv3);
    N_bi4_ p3 = pp3 ? *pp3 : N_bi4_ {};
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, bool p2, struct N_bi4_ p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, UnityEngine.TextureFormat, Boolean, Boolean) declare in UnityEngine.Cubemap
bool w_vti4i4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4bb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Boolean, Int32) declare in System.Configuration.IntegerValidator
bool w_vti4i4bi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4bi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, bool p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Activate(Int32, Int32, Int32) declare in UnityEngine.Display
bool w_vti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Boolean) declare in UnityEngine.Rendering.ClampedIntParameter
bool w_vti4i4i4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4Db");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, UnityEngine.FilterMode, Boolean, System.String, Boolean) declare in UnityEngine.Rendering.Texture2DAtlas
bool w_vti4i4i4Di4DbDsDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4Di4DbDsDb");
    
    auto TIp5 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<bool>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal string  with default
    Il2CppString* p5 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    bool p6 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, bool p4, Il2CppString* p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, UnityEngine.FilterMode, System.String, Boolean) declare in UnityEngine.Rendering.PowerOfTwoTextureAtlas
bool w_vti4i4i4Di4DsDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4Di4DsDb");
    
    auto TIp4 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal string  with default
    Il2CppString* p4 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, Il2CppString* p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Codice.CM.Client.Differences.DifferenceType, System.Object, System.Object) declare in Codice.CM.Client.Differences.ItemDiff
bool w_vti4i4i4OO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4OO");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(UnityEditor.ShaderKeywordFilter.FilterAction, Precedence, EvaluationMode, System.Object, System.String, Int32, System.String[]) declare in UnityEditor.ShaderKeywordFilter.FilterAttribute
bool w_vti4i4i4Osi4Vs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4Osi4Vs");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len < 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal string params
    Il2CppArray* p6 = Params<void*>::PackString(apis, env, info, TIp6, js_args_len, 6);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppString* p4, int32_t p5, Il2CppArray* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void BeginRenderPass(Int32, Int32, Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.AttachmentDescriptor], Int32) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_vti4i4i4S_Pvi4i4i4S_pi4i4_i4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4S_Pvi4i4i4S_pi4i4_i4_Di4");
    
    auto TIp3 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv3);
    S_Pvi4i4i4S_pi4i4_i4_ p3 = pp3 ? *pp3 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetPixel(UnityEngine.CubemapFace, Int32, Int32, UnityEngine.Color) declare in UnityEngine.Cubemap
bool w_vti4i4i4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4S_r4r4r4r4_");
    
    auto TIp3 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, struct S_r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetPixel(UnityEngine.CubemapFace, Int32, Int32, UnityEngine.Color, Int32) declare in UnityEngine.Cubemap
bool w_vti4i4i4S_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4S_r4r4r4r4_i4");
    
    auto TIp3 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, struct S_r4r4r4r4_ p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.TextureFormat, Boolean) declare in UnityEngine.Texture2D
bool w_vti4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.TextureFormat, Boolean, Boolean) declare in UnityEngine.Texture2D
bool w_vti4i4i4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4bb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.TextureFormat, Boolean, Boolean, Boolean) declare in UnityEngine.Texture2D
bool w_vti4i4i4bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4bbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, bool p3, bool p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Boolean, Byte) declare in System.Decimal
bool w_vti4i4i4bu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4bu1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, bool p3, uint8_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetParams(Int32, Int32, Int32, Int32) declare in UnityEngine.Display
bool w_vti4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void BeginRenderPass(Int32, Int32, Int32, Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.AttachmentDescriptor], Int32) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_vti4i4i4i4S_Pvi4i4i4S_pi4i4_i4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4S_Pvi4i4i4S_pi4i4_i4_Di4");
    
    auto TIp4 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp4 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv4);
    S_Pvi4i4i4S_pi4i4_i4_ p4 = pp4 ? *pp4 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, struct S_Pvi4i4i4S_pi4i4_i4_ p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void UpdateDirtyRegion(Int32, Int32, Int32, Int32, Boolean) declare in UnityEngine.TerrainData
bool w_vti4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.TextureFormat, Int32, Boolean, Boolean) declare in UnityEngine.Texture2D
bool w_vti4i4i4i4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4bb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, bool p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, UnityEngine.TextureFormat, Boolean, Boolean, Boolean) declare in UnityEngine.Texture2DArray
bool w_vti4i4i4i4bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4bbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, bool p4, bool p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.TextureFormat, Int32, Boolean, Boolean, Boolean, System.String) declare in UnityEngine.Texture2D
bool w_vti4i4i4i4bbbs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4bbbs");
    
    auto TIp7 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal s
    Il2CppString* p7 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv7);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, bool p4, bool p5, bool p6, Il2CppString* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, UnityEngine.TextureFormat, Boolean, IntPtr) declare in UnityEngine.Texture3D
bool w_vti4i4i4i4bp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4bp");
    
    auto TIp5 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!apis->is_binary(env, _sv5) && !apis->is_null(env, _sv5) && !apis->is_undefined(env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, bool p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, UnityEngine.TextureFormat, Int32, Boolean) declare in UnityEngine.Texture2DArray
bool w_vti4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, UnityEngine.TextureFormat, Int32, Boolean, Boolean) declare in UnityEngine.Texture2DArray
bool w_vti4i4i4i4i4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4bb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, bool p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, System.TimeSpan) declare in System.DateTimeOffset
bool w_vti4i4i4i4i4i4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4S_i8_");
    
    auto TIp6 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_i8_* pp6 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv6);
    S_i8_ p6 = pp6 ? *pp6 : S_i8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, struct S_i8_ p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Boolean) declare in Mono.CompilerServices.SymbolWriter.LineNumberEntry
bool w_vti4i4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.TimeSpan) declare in System.DateTimeOffset
bool w_vti4i4i4i4i4i4i4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4S_i8_");
    
    auto TIp7 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal struct
    S_i8_* pp7 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv7);
    S_i8_ p7 = pp7 ? *pp7 : S_i8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, struct S_i8_ p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, Boolean, UnityEngine.RenderTextureMemoryless) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4bi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4bi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, bool p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, Boolean, UnityEngine.RenderTextureMemoryless, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4bi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4bi4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (checkJSArgument) {
        if (js_args_len != 10) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, bool p7, int32_t p8, bool p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void GetTemporaryRTArray(Int32, Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, Boolean, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4bb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (checkJSArgument) {
        if (js_args_len != 10) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, bool p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, Boolean, UnityEngine.RenderTextureMemoryless) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4bi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4bi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (checkJSArgument) {
        if (js_args_len != 10) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, Boolean, UnityEngine.RenderTextureMemoryless, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4bi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4bi4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);

    if (checkJSArgument) {
        if (js_args_len != 11) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv10)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    bool p10 = converter::Converter<bool>::toCpp(apis, env, _sv10);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, int32_t p9, bool p10, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void GetTemporaryRTArray(Int32, Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void GetTemporaryRTArray(Int32, Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4i4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (checkJSArgument) {
        if (js_args_len != 10) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, bool p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32) declare in Unity.Mathematics.int3x4
bool w_vti4i4i4i4i4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4i4i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32) declare in Unity.Mathematics.int4x4
bool w_vti4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);

    if (checkJSArgument) {
        if (js_args_len != 16) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv12)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv13)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv14)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv15)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);
    // JSValToCSVal P any
    int32_t p12 = converter::Converter<int32_t>::toCpp(apis, env, _sv12);
    // JSValToCSVal P any
    int32_t p13 = converter::Converter<int32_t>::toCpp(apis, env, _sv13);
    // JSValToCSVal P any
    int32_t p14 = converter::Converter<int32_t>::toCpp(apis, env, _sv14);
    // JSValToCSVal P any
    int32_t p15 = converter::Converter<int32_t>::toCpp(apis, env, _sv15);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, int32_t p10, int32_t p11, int32_t p12, int32_t p13, int32_t p14, int32_t p15, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.Globalization.Calendar) declare in System.DateTime
bool w_vti4i4i4i4i4i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4o");
    
    auto TIp7 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, Il2CppObject* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.Globalization.Calendar, System.TimeSpan) declare in System.DateTimeOffset
bool w_vti4i4i4i4i4i4i4oS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4oS_i8_");
    
    auto TIp7 = wrapData->TypeInfos[0];
    auto TIp8 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal struct
    S_i8_* pp8 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv8);
    S_i8_ p8 = pp8 ? *pp8 : S_i8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, Il2CppObject* p7, struct S_i8_ p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.Globalization.Calendar, System.DateTimeKind) declare in System.DateTime
bool w_vti4i4i4i4i4i4i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4oi4");
    
    auto TIp7 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, Il2CppObject* p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, System.Globalization.Calendar) declare in System.DateTime
bool w_vti4i4i4i4i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4o");
    
    auto TIp6 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Double) declare in System.Data.SqlTypes.SqlDateTime
bool w_vti4i4i4i4i4i4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    double p6 = converter::Converter<double>::toCpp(apis, env, _sv6);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, double p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, UnityEngine.TextureFormat, Int32, IntPtr) declare in UnityEngine.Texture3D
bool w_vti4i4i4i4i4p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4p");
    
    auto TIp5 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!apis->is_binary(env, _sv5) && !apis->is_null(env, _sv5) && !apis->is_undefined(env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, UnityEngine.TextureFormat, Int32, IntPtr, Boolean) declare in UnityEngine.Texture3D
bool w_vti4i4i4i4i4pb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4pb");
    
    auto TIp5 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!apis->is_binary(env, _sv5) && !apis->is_null(env, _sv5) && !apis->is_undefined(env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, void* p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void SetPixels(Int32, Int32, Int32, Int32, UnityEngine.Color[]) declare in UnityEngine.Texture2D
bool w_vti4i4i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4o");
    
    auto TIp4 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetPixels(Int32, Int32, Int32, Int32, UnityEngine.Color[], Int32) declare in UnityEngine.Texture2D
bool w_vti4i4i4i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4oi4");
    
    auto TIp4 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, Il2CppObject* p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.Experimental.Rendering.DefaultFormat, Int32, System.String, UnityEngine.Experimental.Rendering.TextureCreationFlags) declare in UnityEngine.Texture2D
bool w_vti4i4i4i4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4si4");
    
    auto TIp4 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, Il2CppString* p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void UpdateTile(Int32, Int32, Int32, UnityEngine.Color32[]) declare in UnityEngine.SparseTexture
bool w_vti4i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4o");
    
    auto TIp3 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Sort(Int32, Int32, System.Collections.IComparer) declare in System.Collections.ArrayList
bool w_vti4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4o");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, System.Data.SqlTypes.SqlCompareOptions, Byte[], Boolean) declare in System.Data.SqlTypes.SqlString
bool w_vti4i4ob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4ob");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppObject* p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTexture(Int32, Int32, UnityEngine.Texture, Int32) declare in UnityEngine.ComputeShader
bool w_vti4i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4oi4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTexture(Int32, Int32, UnityEngine.RenderTexture, Int32, UnityEngine.Rendering.RenderTextureSubElement) declare in UnityEngine.ComputeShader
bool w_vti4i4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4oi4i4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, System.Data.SqlTypes.SqlCompareOptions, Byte[], Int32, Int32, Boolean) declare in System.Data.SqlTypes.SqlString
bool w_vti4i4oi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4oi4i4b");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Codice.CM.Client.Differences.Graphic.ArgbColor, Codice.CM.Client.Differences.Graphic.ArgbColor) declare in Codice.CM.Client.Differences.Graphic.ColorTextRegion
bool w_vti4i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4oo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void GetBlendShapeFrameVertices(Int32, Int32, UnityEngine.Vector3[], UnityEngine.Vector3[], UnityEngine.Vector3[]) declare in UnityEngine.Mesh
bool w_vti4i4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4ooo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, IntPtr, System.IAsyncResult) declare in System.Threading.Overlapped
bool w_vti4i4po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4po");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void PlayInFixedTime(Int32, Int32, Single) declare in UnityEngine.Animator
bool w_vti4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddPathList(System.Security.Permissions.RegistryPermissionAccess, System.Security.AccessControl.AccessControlActions, System.String) declare in System.Security.Permissions.RegistryPermission
bool w_vti4i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, System.String, Boolean ByRef) declare in System.Threading.Semaphore
bool w_vti4i4sPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4sPb");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    bool up3 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv3);
    bool* p3 = &up3;

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppString* p2, bool* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<bool>::toScript(apis, env, *p3));
    
    return true;
}

// Void .ctor(Int32, Int32, System.String, Boolean ByRef, System.Security.AccessControl.SemaphoreSecurity) declare in System.Threading.Semaphore
bool w_vti4i4sPbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4sPbo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    bool up3 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv3);
    bool* p3 = &up3;
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppString* p2, bool* p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<bool>::toScript(apis, env, *p3));
    
    return true;
}

// Void TraceEvent(System.Diagnostics.TraceEventType, Int32, System.String, System.Object[]) declare in System.Diagnostics.TraceSource
bool w_vti4i4sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4sVO");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void AddPermission(System.Net.NetworkAccess, System.Net.TransportType, System.String, Int32) declare in System.Net.SocketPermission
bool w_vti4i4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4si4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppString* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, System.String, Int32, JetBrains.Rider.Model.Unity.SnapshotStatus, Single) declare in JetBrains.Rider.Model.Unity.UnityProfilerSnapshotStatus
bool w_vti4i4si4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4si4i4r4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppString* p2, int32_t p3, int32_t p4, float p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(System.Net.WebSockets.WebSocketError, Int32, System.String, System.Exception) declare in System.Net.WebSockets.WebSocketException
bool w_vti4i4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4so");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, System.String, UnityEditor.Search.SearchContext, UnityEditor.Search.SearchProvider, Boolean, UnityEditor.Search.SearchQueryErrorType) declare in UnityEditor.Search.SearchQueryError
bool w_vti4i4sooDbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4sooDbDi4");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, bool p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void Seek(System.IO.SeekOrigin, Int64) declare in System.Diagnostics.Eventing.Reader.EventLogReader
bool w_vti4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AdviseFileAccessPattern(Mono.Unix.FileAccessPattern, Int64, Int64) declare in Mono.Unix.UnixStream
bool w_vti4i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, int64_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetBytes(Int32, Int64, Byte[], Int32, Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4i8oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i8oi4i4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, int64_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void AddPathList(System.Security.Permissions.FileIOPermissionAccess, System.String[]) declare in System.Security.Permissions.FileIOPermission
bool w_vti4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.Universal.RenderPassEvent, UnityEngine.Material, Boolean, Boolean, Boolean) declare in UnityEngine.Rendering.Universal.Internal.CopyDepthPass
bool w_vti4oDbDbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oDbDbDb");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, bool p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.Universal.RenderPassEvent, UnityEngine.Material, UnityEngine.Material) declare in UnityEngine.Rendering.Universal.Internal.CopyColorPass
bool w_vti4oDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oDo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(DataType, UnityEngine.GUIContent, System.String, Int32, OnGUIDelegate, ComparePropertiesDelegate, CopyPropertiesDelegate, Int32[]) declare in UnityEditor.LightingExplorerTableColumn
bool w_vti4oDsDi4DoDoDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oDsDi4DoDoDoDo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (js_args_len > 6 && !DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (js_args_len > 7 && !DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 5, TIp5);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p6 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 6, TIp6);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p7 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 7, TIp7);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppString* p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void .ctor(Int32, Unity.Plastic.Antlr3.Runtime.IIntStream, System.Object) declare in Unity.Plastic.Antlr3.Runtime.MissingTokenException
bool w_vti4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Unity.Plastic.Antlr3.Runtime.IIntStream, System.Object, System.Collections.Generic.IList`1[System.String]) declare in Unity.Plastic.Antlr3.Runtime.MissingTokenException
bool w_vti4oOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oOo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetRandomWriteTarget(Int32, UnityEngine.ComputeBuffer, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4ob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ob");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Codice.Client.Commands.WorkspaceStatusOptions, Codice.Client.Commands.MovedMatchingOptions, Boolean, Boolean, Boolean, Boolean, Boolean, Boolean) declare in PlasticGui.WorkspaceWindow.PendingChanges.PendingChangesOptions
bool w_vti4obbbbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4obbbbbb");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void AddCommandBufferAsync(UnityEngine.Rendering.CameraEvent, UnityEngine.Rendering.CommandBuffer, UnityEngine.Rendering.ComputeQueueType) declare in UnityEngine.Camera
bool w_vti4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(DG.Tweening.PathType, UnityEngine.Vector3[], Int32, System.Nullable`1[UnityEngine.Color]) declare in DG.Tweening.Plugins.Core.PathCore.Path
bool w_vti4oi4DN_bS_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oi4DN_bS_r4r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal valuetype  with default
    N_bS_r4r4r4r4__ p3 = OptionalParameter<N_bS_r4r4r4r4__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, int32_t p2, struct N_bS_r4r4r4r4__ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void CopyTo(Int32, Char[], Int32, Int32) declare in System.String
bool w_vti4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void MarkSequencePoint(Int32, Mono.CompilerServices.SymbolWriter.SourceFileEntry, Int32, Int32, Boolean) declare in Mono.CompilerServices.SymbolWriter.MonoSymbolWriter
bool w_vti4oi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oi4i4b");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, int32_t p2, int32_t p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void AddAccess(System.Security.AccessControl.AccessControlType, System.Security.Principal.SecurityIdentifier, Int32, System.Security.AccessControl.InheritanceFlags, System.Security.AccessControl.PropagationFlags) declare in System.Security.AccessControl.DiscretionaryAcl
bool w_vti4oi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oi4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void AddAccess(System.Security.AccessControl.AccessControlType, System.Security.Principal.SecurityIdentifier, Int32, System.Security.AccessControl.InheritanceFlags, System.Security.AccessControl.PropagationFlags, System.Security.AccessControl.ObjectAceFlags, System.Guid, System.Guid) declare in System.Security.AccessControl.DiscretionaryAcl
bool w_vti4oi4i4i4i4S_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oi4i4i4i4S_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp6 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp6 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv6);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p6 = pp6 ? *pp6 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp7 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv7);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p7 = pp7 ? *pp7 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p6, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void MarkSequencePoint(Int32, Mono.CompilerServices.SymbolWriter.SourceFileEntry, Int32, Int32, Int32, Int32, Boolean) declare in Mono.CompilerServices.SymbolWriter.SourceMethodBuilder
bool w_vti4oi4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oi4i4i4i4b");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void AddAccess(System.Security.AccessControl.AccessControlType, System.Security.Principal.SecurityIdentifier, System.Security.AccessControl.ObjectAccessRule) declare in System.Security.AccessControl.DiscretionaryAcl
bool w_vti4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Run(UpdateType, System.Action, System.Action, RefreshOptions) declare in PlasticGui.WorkspaceWindow.Update.UpdateWorkspaceOperation
bool w_vti4ooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ooi4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(System.Security.AccessControl.ControlFlags, System.Security.Principal.SecurityIdentifier, System.Security.Principal.SecurityIdentifier, System.Security.AccessControl.RawAcl, System.Security.AccessControl.RawAcl) declare in System.Security.AccessControl.RawSecurityDescriptor
bool w_vti4oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oooo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, TMPro.TMP_FontAsset, TMPro.TMP_SpriteAsset, UnityEngine.Material, Single) declare in TMPro.MaterialReference
bool w_vti4ooor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ooor4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void CheckinChangesToADifferentBranch(PlasticGui.WorkspaceWindow.PendingChanges.MoveChangesMode, Codice.CM.Common.BranchInfo, System.Collections.Generic.List`1[Codice.Client.BaseCommands.ChangeInfo], System.Collections.Generic.List`1[Codice.Client.BaseCommands.ChangeInfo], System.String, PlasticGui.WorkspaceWindow.PendingChanges.TaskToBeLinkedData, System.Action, PlasticGui.SuccessOperationDelegateForCreatedChangeset) declare in PlasticGui.WorkspaceWindow.PendingChanges.PendingChangesOperations
bool w_vti4ooosooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ooosooo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppString* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void LogFormat(UnityEngine.LogType, UnityEngine.Object, System.String, System.Object[]) declare in UnityEngine.Logger
bool w_vti4osVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4osVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void DispatchIndirect(Int32, UnityEngine.ComputeBuffer, UInt32) declare in UnityEngine.ComputeShader
bool w_vti4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ou4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AnyTranslator(Int32, IntPtr, Puerts.ISetValueToJs, IntPtr, System.Object) declare in Puerts.GeneralSetterManager
bool w_vti4popO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4popO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, Il2CppObject* p2, void* p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetLayerCost(Int32, Single) declare in UnityEngine.AI.NavMeshAgent
bool w_vti4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CrossFadeInFixedTime(Int32, Single, Int32) declare in UnityEngine.Animator
bool w_vti4r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void CrossFadeInFixedTime(Int32, Single, Int32, Single) declare in UnityEngine.Animator
bool w_vti4r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r4i4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, int32_t p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void CrossFadeInFixedTime(Int32, Single, Int32, Single, Single) declare in UnityEngine.Animator
bool w_vti4r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r4i4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, int32_t p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, Single, System.Collections.IEqualityComparer) declare in System.Collections.Hashtable
bool w_vti4r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r4o");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Single, System.Collections.IHashCodeProvider, System.Collections.IComparer) declare in System.Collections.Hashtable
bool w_vti4r4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r4oo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetInsetAndSizeFromParentEdge(Edge, Single, Single) declare in UnityEngine.RectTransform
bool w_vti4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetFloat(Int32, Single, Single, Single) declare in UnityEngine.Animator
bool w_vti4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void AddCondition(UnityEditor.Animations.AnimatorConditionMode, Single, System.String) declare in UnityEditor.Animations.AnimatorTransitionBase
bool w_vti4r4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r4s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetDouble(Int32, Double) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_vti4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, double p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int32, Double, Single, Int32, System.String, System.Collections.Generic.List`1[JetBrains.Rider.Model.Unity.BackendUnity.MarkerToNamePair], System.Collections.Generic.List`1[JetBrains.Rider.Model.Unity.BackendUnity.SampleInfo], JetBrains.Rider.Model.Unity.UnityProfilerSnapshotStatus) declare in JetBrains.Rider.Model.Unity.BackendUnity.UnityProfilerSnapshot
bool w_vti4r8r4i4sooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r8r4i4sooo");
    
    auto TIp4 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef void (*FuncToCall)(void*,int32_t p0, double p1, float p2, int32_t p3, Il2CppString* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void AddPathList(System.Security.Permissions.EnvironmentPermissionAccess, System.String) declare in System.Security.Permissions.EnvironmentPermission
bool w_vti4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4s");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int32, System.String, System.String, Int32) declare in UnityEditor.Search.SearchDocument
bool w_vti4sDsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4sDsDi4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Log(UnityEngine.LogType, System.String, System.Object) declare in UnityEngine.Logger
bool w_vti4sO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4sO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Log(UnityEngine.LogType, System.String, System.Object, UnityEngine.Object) declare in UnityEngine.Logger
bool w_vti4sOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4sOo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void TraceTransfer(Int32, System.String, System.Guid) declare in System.Diagnostics.TraceSource
bool w_vti4sS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4sS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv2);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p2 = pp2 ? *pp2 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void NotifyPossibleFrustration(PlasticGui.ViewType, System.String, System.DateTime) declare in PlasticGui.Help.GuiHelp
bool w_vti4sS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4sS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, struct S_u8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void LogFormat(UnityEngine.LogType, System.String, System.Object[]) declare in UnityEngine.Logger
bool w_vti4sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4sVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEditor.HierarchyType, System.String, Boolean) declare in UnityEditor.HierarchyProperty
bool w_vti4sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4sb");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, System.String, Int32) declare in UnityEditor.AssetImporters.ScriptedImporterAttribute
bool w_vti4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4si4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTexture(Int32, System.String, UnityEngine.Texture) declare in UnityEngine.ComputeShader
bool w_vti4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4so");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void InsertAction(Int32, System.String, System.Action`1[UnityEngine.UIElements.DropdownMenuAction], Status) declare in UnityEngine.UIElements.DropdownMenu
bool w_vti4soDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4soDi4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTexture(Int32, System.String, UnityEngine.Texture, Int32) declare in UnityEngine.ComputeShader
bool w_vti4soi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4soi4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTexture(Int32, System.String, UnityEngine.RenderTexture, Int32, UnityEngine.Rendering.RenderTextureSubElement) declare in UnityEngine.ComputeShader
bool w_vti4soi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4soi4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void InsertAction(Int32, System.String, System.Action`1[UnityEngine.UIElements.DropdownMenuAction], System.Func`2[UnityEngine.UIElements.DropdownMenuAction,UnityEngine.UIElements.DropdownMenuAction+Status], System.Object) declare in UnityEngine.UIElements.DropdownMenu
bool w_vti4sooDO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4sooDO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void IndexNumber(Int32, System.String, Double) declare in UnityEditor.Search.ObjectIndexer
bool w_vti4sr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4sr8");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, double p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTextureFromGlobal(Int32, System.String, System.String) declare in UnityEngine.ComputeShader
bool w_vti4ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ss");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, System.String, System.String, System.DateTimeOffset) declare in System.Net.Http.Headers.WarningHeaderValue
bool w_vti4ssS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ssS_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_S_u8_i2_* pp3 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv3);
    S_S_u8_i2_ p3 = pp3 ? *pp3 : S_S_u8_i2_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppString* p2, struct S_S_u8_i2_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void IndexProperty(Int32, System.String, System.String, Boolean, Boolean) declare in UnityEditor.Search.ObjectIndexer
bool w_vti4ssbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ssbDb");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppString* p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Codice.Client.Commands.ReportSeverity, System.String, System.String, Boolean, Boolean, Boolean) declare in Codice.Client.Commands.ReportLine
bool w_vti4ssbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ssbbb");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppString* p2, bool p3, bool p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(System.Diagnostics.Contracts.ContractFailureKind, System.String, System.String, System.Exception) declare in System.Diagnostics.Contracts.ContractFailedEventArgs
bool w_vti4sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4sso");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int32, System.String, System.String, System.Security.AccessControl.CryptoKeySecurity, System.Security.SecureString) declare in System.Security.Cryptography.CspParameters
bool w_vti4ssoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ssoo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, System.String, System.String, System.Security.AccessControl.CryptoKeySecurity, IntPtr) declare in System.Security.Cryptography.CspParameters
bool w_vti4ssop(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ssop");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!apis->is_binary(env, _sv4) && !apis->is_null(env, _sv4) && !apis->is_undefined(env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    void* p4 = DataTransfer::GetPointer<void>(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(System.Security.Cryptography.CngUIProtectionLevels, System.String, System.String, System.String) declare in System.Security.Cryptography.CngUIPolicy
bool w_vti4sss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4sss");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(System.Security.Cryptography.CngUIProtectionLevels, System.String, System.String, System.String, System.String) declare in System.Security.Cryptography.CngUIPolicy
bool w_vti4ssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ssss");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int32_t p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void set_Item(Int32, Byte) declare in UnityEngine.Color32
bool w_vti4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, uint8_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int32, Byte, Byte, Byte, Byte, Int32, Int64) declare in System.Diagnostics.Eventing.EventDescriptor
bool w_vti4u1u1u1u1i4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4u1u1u1u1i4i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(apis, env, _sv6);

    typedef void (*FuncToCall)(void*,int32_t p0, uint8_t p1, uint8_t p2, uint8_t p3, uint8_t p4, int32_t p5, int64_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void set_Item(UInt16[], Int32, UInt16) declare in PuertsIl2cpp.ArrayExtension
bool w_vti4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, uint16_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetUint(Int32, UInt32) declare in UnityEngine.VFX.VFXEventAttribute
bool w_vti4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_Item(UInt64[], Int32, UInt64) declare in PuertsIl2cpp.ArrayExtension
bool w_vti4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti4u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int32_t p0, uint64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_UserQuota(Int64) declare in System.Security.Permissions.IsolatedStoragePermission
bool w_vti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef void (*FuncToCall)(void*,int64_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Write(Int64, System.Decimal) declare in System.IO.UnmanagedMemoryAccessor
bool w_vti8S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti8S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};

    typedef void (*FuncToCall)(void*,int64_t p0, struct S_i4i4i4i4u8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int64, System.TimeSpan) declare in System.DateTimeOffset
bool w_vti8S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti8S_i8_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef void (*FuncToCall)(void*,int64_t p0, struct S_i8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Write(Int64, Boolean) declare in System.IO.UnmanagedMemoryAccessor
bool w_vti8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti8b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int64_t p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Write(Int64, Char) declare in System.IO.UnmanagedMemoryAccessor
bool w_vti8c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti8c");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int64_t p0, Il2CppChar p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Write(Int64, SByte) declare in System.IO.UnmanagedMemoryAccessor
bool w_vti8i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti8i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int64_t p0, int8_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Write(Int64, Int16) declare in System.IO.UnmanagedMemoryAccessor
bool w_vti8i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti8i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int64_t p0, int16_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WriteData(Int64, Int16, UInt64, Boolean, Byte[]) declare in Codice.CM.Common.Serialization.DataPacketWriter
bool w_vti8i2u8bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti8i2u8bo");
    
    auto TIp4 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(void*,int64_t p0, int16_t p1, uint64_t p2, bool p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void WriteData(Int64, Int16, UInt64, Boolean, Byte[], Int32) declare in Codice.CM.Common.Serialization.DataPacketWriter
bool w_vti8i2u8boi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti8i2u8boi4");
    
    auto TIp4 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(void*,int64_t p0, int16_t p1, uint64_t p2, bool p3, Il2CppObject* p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Write(Int64, Int32) declare in System.IO.UnmanagedMemoryAccessor
bool w_vti8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti8i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,int64_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetTotals(Int64, Int32, Int32) declare in Codice.Client.BaseCommands.UpdateProgress
bool w_vti8i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti8i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int64_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int64, JetBrains.Rider.Model.Unity.LogEventType, JetBrains.Rider.Model.Unity.LogEventMode, System.String, System.String) declare in JetBrains.Rider.Model.Unity.LogEvent
bool w_vti8i4i4ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_vti8i4i4ss");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,int64_t p0, int32_t p1, int32_t p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

}

