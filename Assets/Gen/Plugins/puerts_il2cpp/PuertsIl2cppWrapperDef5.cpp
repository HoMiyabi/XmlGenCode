// Auto Gen

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "PuertsValueType.h"
#if defined(__EMSCRIPTEN__)
#include "pesapi_webgl.h"
using namespace pesapi::webglimpl;
#endif

namespace puerts
{


// Int32 mincore(IntPtr, UInt64, Byte[]) declare in Mono.Unix.Native.Syscall
bool w_i4pu8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4pu8o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int32_t (*FuncToCall)(void* p0, uint64_t p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 SingleToInt32Bits(Single) declare in System.BitConverter
bool w_i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(float p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GotoAll(Single, Boolean) declare in DG.Tweening.DOTween
bool w_i4r4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4r4Db");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(float p0, bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetAdaptiveHeightSegments(Single, Single) declare in TreeEditor.TreeData
bool w_i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(float p0, float p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ToInt32(Double) declare in System.Convert
bool w_i4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(double p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ToInt32(System.String) declare in System.Convert
bool w_i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 TokenCount(System.String, Boolean) declare in Betalgo.Ranul.OpenAI.Tokenizer.GPT3.TokenizerGpt3
bool w_i4sDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult IsEventEnabled(System.String, Int32, System.String) declare in UnityEngine.Analytics.Analytics
bool w_i4sDi4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sDi4Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Start(System.String, System.String, Options, Int32) declare in UnityEditor.Progress
bool w_i4sDsDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sDsDi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult SendEventWithLimit(System.String, System.Object) declare in UnityEditor.EditorAnalytics
bool w_i4sO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult SendEvent(System.String, System.Object, Int32, System.String) declare in UnityEngine.Analytics.Analytics
bool w_i4sODi4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sODi4Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal string  with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, int32_t p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult SendEventWithLimit(System.String, System.Object, Int32) declare in UnityEditor.EditorAnalytics
bool w_i4sOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 stat(System.String, Mono.Posix.Stat ByRef) declare in Mono.Posix.Syscall
bool w_i4sPS_i4i4i4i4i4i4i8i8i8i8S_u8_S_u8_S_u8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sPS_i4i4i4i4i4i4i8i8i8i8S_u8_S_u8_S_u8__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i4i4i4i4i4i4i8i8i8i8S_u8_S_u8_S_u8__* p1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i8i8i8i8S_u8_S_u8_S_u8__>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4i4i4i4i8i8i8i8S_u8_S_u8_S_u8__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i4i4i4i4i4i8i8i8i8S_u8_S_u8_S_u8__));
        p1 = &up1;
    }
        

    typedef int32_t (*FuncToCall)(Il2CppString* p0, struct S_i4i4i4i4i4i4i8i8i8i8S_u8_S_u8_S_u8__* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 utime(System.String, Mono.Unix.Native.Utimbuf ByRef) declare in Mono.Unix.Native.Syscall
bool w_i4sPS_i8i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sPS_i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i8i8_* p1 = DataTransfer::GetPointer<S_i8i8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i8i8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i8i8_));
        p1 = &up1;
    }
        

    typedef int32_t (*FuncToCall)(Il2CppString* p0, struct S_i8i8_* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 stat(System.String, Mono.Unix.Native.Stat ByRef) declare in Mono.Unix.Native.Syscall
bool w_i4sPS_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sPS_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_* p1 = DataTransfer::GetPointer<S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_));
        p1 = &up1;
    }
        

    typedef int32_t (*FuncToCall)(Il2CppString* p0, struct S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 statvfs(System.String, Mono.Unix.Native.Statvfs ByRef) declare in Mono.Unix.Native.Syscall
bool w_i4sPS_u8u8u8u8u8u8u8u8u8u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sPS_u8u8u8u8u8u8u8u8u8u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_u8u8u8u8u8u8u8u8u8u8u8_* p1 = DataTransfer::GetPointer<S_u8u8u8u8u8u8u8u8u8u8u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8u8u8u8u8u8u8u8u8u8u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8u8u8u8u8u8u8u8u8u8u8_));
        p1 = &up1;
    }
        

    typedef int32_t (*FuncToCall)(Il2CppString* p0, struct S_u8u8u8u8u8u8u8u8u8u8u8_* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// PlasticGui.ViewType GetLoadedView(System.String, System.Guid) declare in PlasticGui.WorkspaceWindow.SidebarSettings
bool w_i4sS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef int32_t (*FuncToCall)(Il2CppString* p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult Transaction(System.String, System.Decimal, System.String) declare in UnityEngine.Analytics.Analytics
bool w_i4sS_i4i4i4i4u8_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sS_i4i4i4i4u8_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, struct S_i4i4i4i4u8_ p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult Transaction(System.String, System.Decimal, System.String, System.String, System.String) declare in UnityEngine.Analytics.Analytics
bool w_i4sS_i4i4i4i4u8_sss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sS_i4i4i4i4u8_sss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, struct S_i4i4i4i4u8_ p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult Transaction(System.String, System.Decimal, System.String, System.String, System.String, Boolean) declare in UnityEngine.Analytics.Analytics
bool w_i4sS_i4i4i4i4u8_sssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sS_i4i4i4i4u8_sssb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, struct S_i4i4i4i4u8_ p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, bool p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult CustomEvent(System.String, UnityEngine.Vector3) declare in UnityEngine.Analytics.Analytics
bool w_i4sS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef int32_t (*FuncToCall)(Il2CppString* p0, struct S_r4r4r4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 printf(System.String, System.Object[]) declare in Mono.Unix.Native.Stdlib
bool w_i4sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppArray* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 LaunchSlave(System.String, System.String[]) declare in UnityEditor.MPE.ProcessService
bool w_i4sVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sVs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppArray* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult EnableCustomEvent(System.String, Boolean) declare in UnityEngine.Analytics.Analytics
bool w_i4sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult EnableEvent(System.String, Boolean, Int32, System.String) declare in UnityEngine.Analytics.Analytics
bool w_i4sbDi4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sbDi4Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal string  with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, bool p1, int32_t p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Run(System.String, Boolean, System.String ByRef, System.String ByRef) declare in FullscreenEditor.Cmd
bool w_i4sbPsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sbPsPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    // JSValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        

    typedef int32_t (*FuncToCall)(Il2CppString* p0, bool p1, Il2CppString** p2, Il2CppString** p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<Il2CppString*>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// System.Globalization.UnicodeCategory GetUnicodeCategory(System.String, Int32) declare in System.Char
bool w_i4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult SetEventPriority(System.String, UnityEngine.Analytics.AnalyticsEventPriority, Int32, System.String) declare in UnityEngine.Analytics.Analytics
bool w_i4si4Di4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4Di4Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal string  with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, int32_t p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// DG.Tweening.Ease FilteredEasePopup(System.String, DG.Tweening.Ease, UnityEngine.GUIStyle) declare in DG.DOTweenEditor.UI.EditorGUIUtils
bool w_i4si4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 NetGroupEnum(System.String, Int32, IntPtr ByRef, Int32, Int32 ByRef, Int32 ByRef, Int32 ByRef) declare in Codice.CM.SEIDInfo.NetWorkAPI
bool w_i4si4Ppi4Pi4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4Ppi4Pi4Pi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P not primitive
    void** p2 = nullptr;
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P primitive
    int32_t up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;
    // JSValToCSVal P primitive
    int32_t up5 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv5);
    int32_t* p5 = &up5;
    // JSValToCSVal P primitive
    int32_t up6 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv6);
    int32_t* p6 = &up6;

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, void** p2, int32_t p3, int32_t* p4, int32_t* p5, int32_t* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    apis->update_boxed_value(env, _sv2, apis->create_binary(env, *p2, 0));
    apis->update_boxed_value(env, _sv4, converter::Converter<int32_t>::toScript(apis, env, *p4));
    apis->update_boxed_value(env, _sv5, converter::Converter<int32_t>::toScript(apis, env, *p5));
    apis->update_boxed_value(env, _sv6, converter::Converter<int32_t>::toScript(apis, env, *p6));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IntField(System.String, Int32, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_i4si4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppArray* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.TextCore.LowLevel.FontEngineError LoadFontFace(System.String, Int32, Int32) declare in UnityEngine.TextCore.LowLevel.FontEngine
bool w_i4si4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult RegisterEvent(System.String, Int32, Int32, System.String, System.String) declare in UnityEngine.Analytics.Analytics
bool w_i4si4i4DsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4DsDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal string  with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal string  with default
    Il2CppString* p4 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, int32_t p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 NetUserEnum(System.String, Int32, Int32, IntPtr ByRef, Int32, Int32 ByRef, Int32 ByRef, Int32 ByRef) declare in Codice.CM.SEIDInfo.NetWorkAPI
bool w_i4si4i4Ppi4Pi4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4Ppi4Pi4Pi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
        if (!apis->is_boxed_value(env, _sv7)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P not primitive
    void** p3 = nullptr;
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P primitive
    int32_t up5 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv5);
    int32_t* p5 = &up5;
    // JSValToCSVal P primitive
    int32_t up6 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv6);
    int32_t* p6 = &up6;
    // JSValToCSVal P primitive
    int32_t up7 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv7);
    int32_t* p7 = &up7;

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, int32_t p2, void** p3, int32_t p4, int32_t* p5, int32_t* p6, int32_t* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    apis->update_boxed_value(env, _sv3, apis->create_binary(env, *p3, 0));
    apis->update_boxed_value(env, _sv5, converter::Converter<int32_t>::toScript(apis, env, *p5));
    apis->update_boxed_value(env, _sv6, converter::Converter<int32_t>::toScript(apis, env, *p6));
    apis->update_boxed_value(env, _sv7, converter::Converter<int32_t>::toScript(apis, env, *p7));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IntSlider(System.String, Int32, Int32, Int32, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_i4si4i4i4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4i4Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, int32_t p2, int32_t p3, Il2CppArray* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult RegisterEventWithLimit(System.String, Int32, Int32, System.String) declare in UnityEditor.EditorAnalytics
bool w_i4si4i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, int32_t p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult RegisterEventWithLimit(System.String, Int32, Int32, System.String, Int32) declare in UnityEditor.EditorAnalytics
bool w_i4si4i4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4si4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, int32_t p2, Il2CppString* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult RegisterEvent(System.String, Int32, Int32, System.String, Int32, System.String) declare in UnityEngine.Analytics.Analytics
bool w_i4si4i4si4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4si4Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal string  with default
    Il2CppString* p5 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, int32_t p2, Il2CppString* p3, int32_t p4, Il2CppString* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider) declare in System.Int32
bool w_i4si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IntField(System.String, Int32, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_i4si4oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4oVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Popup(System.String, Int32, System.String[], UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_i4si4ooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4ooVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppArray* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IntPopup(System.String, Int32, System.String[], Int32[], UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_i4si4oooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4oooVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len < 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        auto TIp5_V = il2cpp::vm::Class::GetElementClass(TIp5);if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal ref params
    Il2CppArray* p5 = Params<void*>::PackRef(apis, env, info, TIp5, js_args_len, 5);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppArray* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.NetworkConnectionError Connect(System.String, Int32, System.String) declare in UnityEngine.Network
bool w_i4si4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, Int32, System.String, Int32, Int32) declare in System.String
bool w_i4si4si4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppString* p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, Int32, System.String, Int32, Int32, Boolean) declare in System.String
bool w_i4si4si4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppString* p2, int32_t p3, int32_t p4, bool p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, Int32, System.String, Int32, Int32, Boolean, System.Globalization.CultureInfo) declare in System.String
bool w_i4si4si4i4bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4bo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppString* p2, int32_t p3, int32_t p4, bool p5, Il2CppObject* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, Int32, System.String, Int32, Int32, System.StringComparison) declare in System.String
bool w_i4si4si4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppString* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, Int32, System.String, Int32, Int32, System.Globalization.CultureInfo, System.Globalization.CompareOptions) declare in System.String
bool w_i4si4si4i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppString* p2, int32_t p3, int32_t p4, Il2CppObject* p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 open(System.String, Mono.Unix.Native.OpenFlags, Mono.Unix.Native.FilePermissions) declare in Mono.Unix.Native.Syscall
bool w_i4si4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4u4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int32_t p1, uint32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 truncate(System.String, Int64) declare in Mono.Unix.Native.Syscall
bool w_i4si8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4si8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, int64_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ToInt32(System.String, System.IFormatProvider) declare in System.Convert
bool w_i4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 getgrnam_r(System.String, Mono.Unix.Native.Group, Mono.Unix.Native.Group ByRef) declare in Mono.Unix.Native.Syscall
bool w_i4soPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4soPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject** p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ExecWaitWithCapture(System.String, System.CodeDom.Compiler.TempFileCollection, System.String ByRef, System.String ByRef) declare in System.CodeDom.Compiler.Executor
bool w_i4soPsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4soPsPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    // JSValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppString** p2, Il2CppString** p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<Il2CppString*>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 execve(System.String, System.String[], System.String[]) declare in Mono.Unix.Native.Syscall
bool w_i4soo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4soo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 readlink(System.String, System.Text.StringBuilder, UInt64) declare in Mono.Unix.Native.Syscall
bool w_i4sou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sou8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, uint64_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 fputs(System.String, IntPtr) declare in Mono.Unix.Native.Stdlib
bool w_i4sp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, System.String) declare in System.String
bool w_i4ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult SetEventEndPoint(System.String, System.String, Int32, System.String) declare in UnityEngine.Analytics.Analytics
bool w_i4ssDi4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssDi4Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal string  with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int32_t p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetRecentCommentsCount(System.String, System.String, System.Guid) declare in PlasticGui.WorkspaceWindow.RecentCommentsSettings
bool w_i4ssS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv2);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p2 = pp2 ? *pp2 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, System.String, Boolean) declare in System.String
bool w_i4ssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, System.String, Boolean, System.Globalization.CultureInfo) declare in System.String
bool w_i4ssbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssbo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, bool p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, System.String, System.StringComparison) declare in System.String
bool w_i4ssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 NetUserGetGroups(System.String, System.String, Int32, IntPtr ByRef, Int32, Int32 ByRef, Int32 ByRef) declare in Codice.CM.SEIDInfo.NetWorkAPI
bool w_i4ssi4Ppi4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssi4Ppi4Pi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P not primitive
    void** p3 = nullptr;
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P primitive
    int32_t up5 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv5);
    int32_t* p5 = &up5;
    // JSValToCSVal P primitive
    int32_t up6 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv6);
    int32_t* p6 = &up6;

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int32_t p2, void** p3, int32_t p4, int32_t* p5, int32_t* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    apis->update_boxed_value(env, _sv3, apis->create_binary(env, *p3, 0));
    apis->update_boxed_value(env, _sv5, converter::Converter<int32_t>::toScript(apis, env, *p5));
    apis->update_boxed_value(env, _sv6, converter::Converter<int32_t>::toScript(apis, env, *p6));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 NetGroupGetUsers(System.String, System.String, Int32, IntPtr ByRef, Int32, Int32 ByRef, Int32 ByRef, Int32 ByRef) declare in Codice.CM.SEIDInfo.NetWorkAPI
bool w_i4ssi4Ppi4Pi4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssi4Ppi4Pi4Pi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
        if (!apis->is_boxed_value(env, _sv7)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P not primitive
    void** p3 = nullptr;
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P primitive
    int32_t up5 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv5);
    int32_t* p5 = &up5;
    // JSValToCSVal P primitive
    int32_t up6 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv6);
    int32_t* p6 = &up6;
    // JSValToCSVal P primitive
    int32_t up7 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv7);
    int32_t* p7 = &up7;

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int32_t p2, void** p3, int32_t p4, int32_t* p5, int32_t* p6, int32_t* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    apis->update_boxed_value(env, _sv3, apis->create_binary(env, *p3, 0));
    apis->update_boxed_value(env, _sv5, converter::Converter<int32_t>::toScript(apis, env, *p5));
    apis->update_boxed_value(env, _sv6, converter::Converter<int32_t>::toScript(apis, env, *p6));
    apis->update_boxed_value(env, _sv7, converter::Converter<int32_t>::toScript(apis, env, *p7));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 NetUserGetLocalGroups(System.String, System.String, Int32, Int32, IntPtr ByRef, Int32, Int32 ByRef, Int32 ByRef) declare in Codice.CM.SEIDInfo.NetWorkAPI
bool w_i4ssi4i4Ppi4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssi4i4Ppi4Pi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
        if (!apis->is_boxed_value(env, _sv7)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P not primitive
    void** p4 = nullptr;
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P primitive
    int32_t up6 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv6);
    int32_t* p6 = &up6;
    // JSValToCSVal P primitive
    int32_t up7 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv7);
    int32_t* p7 = &up7;

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int32_t p2, int32_t p3, void** p4, int32_t p5, int32_t* p6, int32_t* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    apis->update_boxed_value(env, _sv4, apis->create_binary(env, *p4, 0));
    apis->update_boxed_value(env, _sv6, converter::Converter<int32_t>::toScript(apis, env, *p6));
    apis->update_boxed_value(env, _sv7, converter::Converter<int32_t>::toScript(apis, env, *p7));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 setxattr(System.String, System.String, Byte[]) declare in Mono.Unix.Native.Syscall
bool w_i4sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ExecWaitWithCapture(System.String, System.String, System.CodeDom.Compiler.TempFileCollection, System.String ByRef, System.String ByRef) declare in System.CodeDom.Compiler.Executor
bool w_i4ssoPsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssoPsPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        
    // JSValToCSVal Ps
    Il2CppString* up4 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv4); // string ref
    Il2CppString** p4 = &up4;
        

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, Il2CppString** p3, Il2CppString** p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<Il2CppString*>::toScript(apis, env, *p3));
    apis->update_boxed_value(env, _sv4, converter::Converter<Il2CppString*>::toScript(apis, env, *p4));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, System.String, System.Globalization.CultureInfo, System.Globalization.CompareOptions) declare in System.String
bool w_i4ssoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 DsGetDcName(System.String, System.String, GuidAsClass, System.String, Int32, IntPtr ByRef) declare in Codice.CM.SEIDInfo.NetWorkAPI
bool w_i4ssosi4Pp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssosi4Pp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P not primitive
    void** p5 = nullptr;

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, Il2CppString* p3, int32_t p4, void** p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv5, apis->create_binary(env, *p5, 0));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 setxattr(System.String, System.String, Byte[], UInt64) declare in Mono.Unix.Native.Syscall
bool w_i4ssou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssou8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    uint64_t p3 = converter::Converter<uint64_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, uint64_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 setxattr(System.String, System.String, Byte[], UInt64, Mono.Unix.Native.XattrFlags) declare in Mono.Unix.Native.Syscall
bool w_i4ssou8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssou8i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    uint64_t p3 = converter::Converter<uint64_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, uint64_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult ConfigureCustomEvent(System.String, System.String, Single, Single, Boolean) declare in UnityEngine.Analytics.ContinuousEvent
bool w_i4ssr4r4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssr4r4Db");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, float p2, float p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Analytics.AnalyticsResult ConfigureEvent(System.String, System.String, Single, Single, Boolean, Int32, System.String) declare in UnityEngine.Analytics.ContinuousEvent
bool w_i4ssr4r4DbDi4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssr4r4DbDi4Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal string  with default
    Il2CppString* p6 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, float p2, float p3, bool p4, int32_t p5, Il2CppString* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetInt(System.String, System.String, System.String) declare in Codice.Utils.ConfigurationManager
bool w_i4sss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 DisplayDialogComplex(System.String, System.String, System.String, System.String, System.String) declare in UnityEditor.EditorUtility
bool w_i4sssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sssss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// GuiMessageResponseButton ShowQuestionWithCheckBox(System.String, System.String, System.String, System.String, System.String, Codice.Client.Common.MultiLinkLabelData, Boolean ByRef) declare in Codice.Client.Common.GuiMessage
bool w_i4sssssoPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4sssssoPb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P primitive
    bool up6 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv6);
    bool* p6 = &up6;

    typedef int32_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppObject* p5, bool* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    apis->update_boxed_value(env, _sv6, converter::Converter<bool>::toScript(apis, env, *p6));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 creat(System.String, Mono.Unix.Native.FilePermissions) declare in Mono.Unix.Native.Syscall
bool w_i4su4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4su4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, uint32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 chown(System.String, UInt32, UInt32) declare in Mono.Unix.Native.Syscall
bool w_i4su4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4su4u4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, uint32_t p1, uint32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 mknod(System.String, Mono.Unix.Native.FilePermissions, UInt64) declare in Mono.Unix.Native.Syscall
bool w_i4su4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4su4u8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, uint32_t p1, uint64_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 sethostname(System.String, UInt64) declare in Mono.Unix.Native.Syscall
bool w_i4su8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4su8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(Il2CppString* p0, uint64_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 get_SubKeyCount() declare in Microsoft.Win32.RegistryKey
bool w_i4t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4t");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef int32_t (*FuncToCall)(void*,const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetByteCount(Boolean) declare in System.Numerics.BigInteger
bool w_i4tDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tDb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef int32_t (*FuncToCall)(void*,bool p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetTextureArraySlice(Int32) declare in UnityEngine.Experimental.Rendering.XRPass
bool w_i4tDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tDi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef int32_t (*FuncToCall)(void*,int32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Object) declare in System.String
bool w_i4tO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.Object, System.Object) declare in System.StringComparer
bool w_i4tOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tOO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.Object, Int32) declare in System.Collections.ArrayList
bool w_i4tOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.Object, Int32, Int32) declare in System.Collections.ArrayList
bool w_i4tOi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tOi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 BinarySearch(System.Object, System.Collections.IComparer) declare in System.Collections.ArrayList
bool w_i4tOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tOo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Experimental.AI.PathQueryStatus Raycast(UnityEngine.AI.NavMeshHit ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Experimental.AI.PolygonId], Int32 ByRef, UnityEngine.Experimental.AI.NavMeshLocation, UnityEngine.Vector3, Int32, Unity.Collections.NativeArray`1[System.Single]) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_i4tPS_S_r4r4r4_S_r4r4r4_r4i4i4_S_Pvi4i4i4i4S_pi4i4__Pi4S_S_u8_S_r4r4r4__S_r4r4r4_Di4DS_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPS_S_r4r4r4_S_r4r4r4_r4i4i4_S_Pvi4i4i4i4S_pi4i4__Pi4S_S_u8_S_r4r4r4__S_r4r4r4_Di4DS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 5) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_r4r4r4_S_r4r4r4_r4i4i4_));
        p0 = &up0;
    }
        
    // JSValToCSVal struct
    S_Pvi4i4i4i4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, _sv1);
    S_Pvi4i4i4i4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pvi4i4i4i4S_pi4i4__ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal struct
    S_S_u8_S_r4r4r4__* pp3 = DataTransfer::GetPointer<S_S_u8_S_r4r4r4__>(apis, env, _sv3);
    S_S_u8_S_r4r4r4__ p3 = pp3 ? *pp3 : S_S_u8_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal valuetype  with default
    S_Pvi4i4i4S_pi4i4_i4_ p6 = OptionalParameter<S_Pvi4i4i4S_pi4i4_i4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef int32_t (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_r4i4i4_* p0, struct S_Pvi4i4i4i4S_pi4i4__ p1, int32_t* p2, struct S_S_u8_S_r4r4r4__ p3, struct S_r4r4r4_ p4, int32_t p5, struct S_Pvi4i4i4S_pi4i4_i4_ p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Experimental.AI.PathQueryStatus Raycast(UnityEngine.AI.NavMeshHit ByRef, UnityEngine.Experimental.AI.NavMeshLocation, UnityEngine.Vector3, Int32, Unity.Collections.NativeArray`1[System.Single]) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_i4tPS_S_r4r4r4_S_r4r4r4_r4i4i4_S_S_u8_S_r4r4r4__S_r4r4r4_Di4DS_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPS_S_r4r4r4_S_r4r4r4_r4i4i4_S_S_u8_S_r4r4r4__S_r4r4r4_Di4DS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_r4r4r4_S_r4r4r4_r4i4i4_));
        p0 = &up0;
    }
        
    // JSValToCSVal struct
    S_S_u8_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_u8_S_r4r4r4__>(apis, env, _sv1);
    S_S_u8_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_u8_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal valuetype  with default
    S_Pvi4i4i4S_pi4i4_i4_ p4 = OptionalParameter<S_Pvi4i4i4S_pi4i4_i4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef int32_t (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_r4i4i4_* p0, struct S_S_u8_S_r4r4r4__ p1, struct S_r4r4r4_ p2, int32_t p3, struct S_Pvi4i4i4S_pi4i4_i4_ p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetDenseJacobian(UnityEngine.ArticulationJacobian ByRef) declare in UnityEngine.ArticulationBody
bool w_i4tPS_i4i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPS_i4i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4o_* p0 = DataTransfer::GetPointer<S_i4i4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4o_));
        p0 = &up0;
    }
        

    typedef int32_t (*FuncToCall)(void*,struct S_i4i4o_* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ReadFileMetadata(FileData ByRef) declare in Codice.CM.Common.Serialization.PacketFileReader
bool w_i4tPS_i8i2u8bo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPS_i8i2u8bo_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i8i2u8bo_* p0 = DataTransfer::GetPointer<S_i8i2u8bo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i8i2u8bo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i8i2u8bo_));
        p0 = &up0;
    }
        

    typedef int32_t (*FuncToCall)(void*,struct S_i8i2u8bo_* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetTrails(Trails ByRef) declare in UnityEngine.ParticleSystem
bool w_i4tPS_oooooi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPS_oooooi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_oooooi4i4_* p0 = DataTransfer::GetPointer<S_oooooi4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oooooi4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_oooooi4i4_));
        p0 = &up0;
    }
        

    typedef int32_t (*FuncToCall)(void*,struct S_oooooi4i4_* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Experimental.AI.PathQueryStatus EndFindPath(Int32 ByRef) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_i4tPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;

    typedef int32_t (*FuncToCall)(void*,int32_t* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 BakeTexture(UnityEngine.Texture2D ByRef, UnityEngine.Texture2D ByRef, UnityEngine.ParticleSystemBakeTextureOptions) declare in UnityEngine.ParticleSystemRenderer
bool w_i4tPoPoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPoPoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject** p0, Il2CppObject** p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 BakeTexture(UnityEngine.Texture2D ByRef, UnityEngine.Texture2D ByRef, UnityEngine.Camera, UnityEngine.ParticleSystemBakeTextureOptions) declare in UnityEngine.ParticleSystemRenderer
bool w_i4tPoPooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPoPooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject** p0, Il2CppObject** p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 BakeTexture(UnityEngine.Texture2D ByRef, UnityEngine.ParticleSystemBakeTextureOptions) declare in UnityEngine.ParticleSystemRenderer
bool w_i4tPoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject** p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 BakeTexture(UnityEngine.Texture2D ByRef, UnityEngine.Camera, UnityEngine.ParticleSystemBakeTextureOptions) declare in UnityEngine.ParticleSystemRenderer
bool w_i4tPooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject** p0, Il2CppObject* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetByteCount(Char*, Int32) declare in System.Text.ASCIIEncoding
bool w_i4tPvi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPvi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CopyTo(Unity.Profiling.ProfilerRecorderSample*, Int32, Boolean) declare in Unity.Profiling.ProfilerRecorder
bool w_i4tPvi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPvi4Db");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetBytes(Char*, Int32, Byte*, Int32) declare in System.Text.ASCIIEncoding
bool w_i4tPvi4Pvi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPvi4Pvi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetChars(Byte*, Int32, Char*, Int32, Boolean) declare in System.Text.Decoder
bool w_i4tPvi4Pvi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPvi4Pvi4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, int32_t p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetCharCount(Byte*, Int32, Boolean) declare in System.Text.Decoder
bool w_i4tPvi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPvi4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetPositions(Unity.Collections.NativeArray`1[UnityEngine.Vector3]) declare in UnityEngine.TrailRenderer
bool w_i4tS_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetCustomShapes(Unity.Collections.NativeArray`1[UnityEngine.PhysicsShape2D], Unity.Collections.NativeArray`1[UnityEngine.Vector2]) declare in UnityEngine.CustomCollider2D
bool w_i4tS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32) declare in UnityEngine.ParticleSystem
bool w_i4tS_Pvi4i4i4S_pi4i4_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pvi4i4i4S_pi4i4_i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32, Int32) declare in UnityEngine.ParticleSystem
bool w_i4tS_Pvi4i4i4S_pi4i4_i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pvi4i4i4S_pi4i4_i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetPathResult(Unity.Collections.NativeSlice`1[UnityEngine.Experimental.AI.PolygonId]) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_i4tS_Pvi4i4i4i4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pvi4i4i4i4S_pi4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4i4S_pi4i4__* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, _sv0);
    S_Pvi4i4i4i4S_pi4i4__ p0 = pp0 ? *pp0 : S_Pvi4i4i4i4S_pi4i4__ {};

    typedef int32_t (*FuncToCall)(void*,struct S_Pvi4i4i4i4S_pi4i4__ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetTilesBlockNonAlloc(UnityEngine.BoundsInt, UnityEngine.Tilemaps.TileBase[]) declare in UnityEngine.Tilemaps.Tilemap
bool w_i4tS_S_i4i4i4_S_i4i4i4__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_i4i4i4_S_i4i4i4__o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,struct S_S_i4i4i4_S_i4i4i4__ p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ToLowerInvariant(System.ReadOnlySpan`1[System.Char], System.Span`1[System.Char]) declare in System.MemoryExtensions
bool w_i4tS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// System.Buffers.OperationStatus Flush(System.Span`1[System.Byte], Int32 ByRef) declare in System.IO.Compression.BrotliEncoder
bool w_i4tS_S_p_i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p0, int32_t* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetChars(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Char]) declare in System.Text.Encoding
bool w_i4tS_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_S_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// System.Buffers.OperationStatus Decompress(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Byte], Int32 ByRef, Int32 ByRef) declare in System.IO.Compression.BrotliDecoder
bool w_i4tS_S_p_i4_S_S_p_i4_Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_S_S_p_i4_Pi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, int32_t* p2, int32_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// System.Buffers.OperationStatus EncodeUtf8(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Byte], Int32 ByRef, Int32 ByRef, Boolean) declare in System.Text.Encodings.Web.TextEncoder
bool w_i4tS_S_p_i4_S_S_p_i4_Pi4Pi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_S_S_p_i4_Pi4Pi4Db");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, int32_t* p2, int32_t* p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// System.Buffers.OperationStatus Compress(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Byte], Int32 ByRef, Int32 ByRef, Boolean) declare in System.IO.Compression.BrotliEncoder
bool w_i4tS_S_p_i4_S_S_p_i4_Pi4Pi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_S_S_p_i4_Pi4Pi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, int32_t* p2, int32_t* p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetChars(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Char], Boolean) declare in System.Text.Decoder
bool w_i4tS_S_p_i4_S_S_p_i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_S_S_p_i4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetCharCount(System.ReadOnlySpan`1[System.Byte], Boolean) declare in System.Text.Decoder
bool w_i4tS_S_p_i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p0, bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.StringComparison) declare in System.MemoryExtensions
bool w_i4tS_S_p_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Receive(System.Span`1[System.Byte], System.Net.Sockets.SocketFlags, System.Net.Sockets.SocketError ByRef) declare in System.Net.Sockets.Socket
bool w_i4tS_S_p_i4_i4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_i4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p0, int32_t p1, int32_t* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ToLower(System.ReadOnlySpan`1[System.Char], System.Span`1[System.Char], System.Globalization.CultureInfo) declare in System.MemoryExtensions
bool w_i4tS_S_p_i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UnityEngine.RaycastHit2D) declare in UnityEngine.RaycastHit2D
bool w_i4tS_S_r4r4_S_r4r4_S_r4r4_r4r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_r4r4_S_r4r4_S_r4r4_r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetRayIntersection(UnityEngine.Ray, Single, UnityEngine.RaycastHit2D[], Int32) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_S_r4r4r4_S_r4r4r4__r4oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_r4r4r4_S_r4r4r4__r4oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef int32_t (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UnityEditor.Build.Content.ObjectIdentifier) declare in UnityEditor.Build.Content.ObjectIdentifier
bool w_i4tS_S_u4u4u4u4_i8i4s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_u4u4u4u4_i8i4s_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_i8i4s_* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(apis, env, _sv0);
    S_S_u4u4u4u4_i8i4s_ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_i8i4s_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_S_u4u4u4u4_i8i4s_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Experimental.AI.PathQueryStatus BeginFindPath(UnityEngine.Experimental.AI.NavMeshLocation, UnityEngine.Experimental.AI.NavMeshLocation, Int32, Unity.Collections.NativeArray`1[System.Single]) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_i4tS_S_u8_S_r4r4r4__S_S_u8_S_r4r4r4__Di4DS_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_u8_S_r4r4r4__S_S_u8_S_r4r4r4__Di4DS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_u8_S_r4r4r4__>(apis, env, _sv0);
    S_S_u8_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_u8_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_u8_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_u8_S_r4r4r4__>(apis, env, _sv1);
    S_S_u8_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_u8_S_r4r4r4__ {};
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal valuetype  with default
    S_Pvi4i4i4S_pi4i4_i4_ p3 = OptionalParameter<S_Pvi4i4i4S_pi4i4_i4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef int32_t (*FuncToCall)(void*,struct S_S_u8_S_r4r4r4__ p0, struct S_S_u8_S_r4r4r4__ p1, int32_t p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.DateTimeOffset) declare in System.DateTimeOffset
bool w_i4tS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_S_u8_i2_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.ValueTuple) declare in System.ValueTuple
bool w_i4tS__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};

    typedef int32_t (*FuncToCall)(void*,struct S__ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 OverlapCollider(UnityEngine.ContactFilter2D, UnityEngine.Collider2D[]) declare in UnityEngine.Rigidbody2D
bool w_i4tS_bbbbbbS_i4_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv0);
    S_bbbbbbS_i4_r4r4r4r4_ p0 = pp0 ? *pp0 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,struct S_bbbbbbS_i4_r4r4r4r4_ p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Data.SqlTypes.SqlInt16) declare in System.Data.SqlTypes.SqlInt16
bool w_i4tS_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_bi2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi2_* pp0 = DataTransfer::GetPointer<S_bi2_>(apis, env, _sv0);
    S_bi2_ p0 = pp0 ? *pp0 : S_bi2_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_bi2_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Data.SqlTypes.SqlInt32) declare in System.Data.SqlTypes.SqlInt32
bool w_i4tS_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_bi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4_* pp0 = DataTransfer::GetPointer<S_bi4_>(apis, env, _sv0);
    S_bi4_ p0 = pp0 ? *pp0 : S_bi4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_bi4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Data.SqlTypes.SqlDateTime) declare in System.Data.SqlTypes.SqlDateTime
bool w_i4tS_bi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_bi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4i4_* pp0 = DataTransfer::GetPointer<S_bi4i4_>(apis, env, _sv0);
    S_bi4i4_ p0 = pp0 ? *pp0 : S_bi4i4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_bi4i4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Data.SqlTypes.SqlInt64) declare in System.Data.SqlTypes.SqlInt64
bool w_i4tS_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_bi8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_bi8_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Data.SqlTypes.SqlSingle) declare in System.Data.SqlTypes.SqlSingle
bool w_i4tS_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_br4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br4_* pp0 = DataTransfer::GetPointer<S_br4_>(apis, env, _sv0);
    S_br4_ p0 = pp0 ? *pp0 : S_br4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_br4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Data.SqlTypes.SqlDouble) declare in System.Data.SqlTypes.SqlDouble
bool w_i4tS_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_br8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_br8_* pp0 = DataTransfer::GetPointer<S_br8_>(apis, env, _sv0);
    S_br8_ p0 = pp0 ? *pp0 : S_br8_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_br8_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Data.SqlTypes.SqlByte) declare in System.Data.SqlTypes.SqlByte
bool w_i4tS_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_bu1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bu1_* pp0 = DataTransfer::GetPointer<S_bu1_>(apis, env, _sv0);
    S_bu1_ p0 = pp0 ? *pp0 : S_bu1_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_bu1_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 get_Item(Section) declare in System.Collections.Specialized.BitVector32
bool w_i4tS_i2i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i2i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i2i2_* pp0 = DataTransfer::GetPointer<S_i2i2_>(apis, env, _sv0);
    S_i2i2_ p0 = pp0 ? *pp0 : S_i2i2_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_i2i2_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Guid) declare in System.Guid
bool w_i4tS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Read(System.Guid, FileData ByRef) declare in Codice.CM.Common.Serialization.ExternalStorageDataReader
bool w_i4tS_i4i2i2u1u1u1u1u1u1u1u1_PS_i8i2u8bo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i2i2u1u1u1u1u1u1u1u1_PS_i8i2u8bo_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal Pstruct
    S_i8i2u8bo_* p1 = DataTransfer::GetPointer<S_i8i2u8bo_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i8i2u8bo_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i8i2u8bo_));
        p1 = &up1;
    }
        

    typedef int32_t (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, struct S_i8i2u8bo_* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetFrameMetaDataCount(System.Guid, Int32) declare in UnityEditor.Profiling.FrameDataView
bool w_i4tS_i4i2i2u1u1u1u1u1u1u1u1_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i2i2u1u1u1u1u1u1u1u1_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Tilemaps.TileFlags GetTileFlags(UnityEngine.Vector3Int) declare in UnityEngine.Tilemaps.ITilemap
bool w_i4tS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_i4i4i4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetTilesRangeCount(UnityEngine.Vector3Int, UnityEngine.Vector3Int) declare in UnityEngine.Tilemaps.Tilemap
bool w_i4tS_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i4i4_S_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetTilesRangeNonAlloc(UnityEngine.Vector3Int, UnityEngine.Vector3Int, UnityEngine.Vector3Int[], UnityEngine.Tilemaps.TileBase[]) declare in UnityEngine.Tilemaps.Tilemap
bool w_i4tS_i4i4i4_S_i4i4i4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i4i4_S_i4i4i4_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Decimal) declare in System.Decimal
bool w_i4tS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_i4i4i4i4u8_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_i4tS_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_i4o_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.TimeSpan) declare in System.TimeSpan
bool w_i4tS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_i8_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Data.SqlTypes.SqlBinary) declare in System.Data.SqlTypes.SqlBinary
bool w_i4tS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddSource(UnityEngine.Animations.ConstraintSource) declare in UnityEngine.Animations.AimConstraint
bool w_i4tS_or4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_or4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_or4_* pp0 = DataTransfer::GetPointer<S_or4_>(apis, env, _sv0);
    S_or4_ p0 = pp0 ? *pp0 : S_or4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_or4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetTokenFor(System.RuntimeFieldHandle) declare in System.Reflection.Emit.DynamicILInfo
bool w_i4tS_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_p_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_p_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetTokenFor(System.RuntimeMethodHandle, System.RuntimeTypeHandle) declare in System.Reflection.Emit.DynamicILInfo
bool w_i4tS_p_S_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_p_S_p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};
    // JSValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(apis, env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_p_ p0, struct S_p_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Rendering.RendererListStatus QueryRendererListStatus(UnityEngine.Rendering.RendererList) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_i4tS_pu4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_pu4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4u4u4_* pp0 = DataTransfer::GetPointer<S_pu4u4u4_>(apis, env, _sv0);
    S_pu4u4u4_ p0 = pp0 ? *pp0 : S_pu4u4u4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_pu4u4u4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetInsertionIndex(UnityEngine.Vector2) declare in UnityEditor.Experimental.GraphView.StackNode
bool w_i4tS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 OverlapPoint(UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.Collider2D[]) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv1);
    S_bbbbbbS_i4_r4r4r4r4_ p1 = pp1 ? *pp1 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_bbbbbbS_i4_r4r4r4r4_ p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Raycast(UnityEngine.Vector2, UnityEngine.ContactFilter2D, System.Collections.Generic.List`1[UnityEngine.RaycastHit2D], Single) declare in UnityEngine.Collider2D
bool w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv1);
    S_bbbbbbS_i4_r4r4r4r4_ p1 = pp1 ? *pp1 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_bbbbbbS_i4_r4r4r4r4_ p1, Il2CppObject* p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Cast(UnityEngine.Vector2, UnityEngine.ContactFilter2D, System.Collections.Generic.List`1[UnityEngine.RaycastHit2D], Single, Boolean) declare in UnityEngine.Collider2D
bool w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4Db");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv1);
    S_bbbbbbS_i4_r4r4r4r4_ p1 = pp1 ? *pp1 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_bbbbbbS_i4_r4r4r4r4_ p1, Il2CppObject* p2, float p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Cast(UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[], Single) declare in UnityEngine.Rigidbody2D
bool w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv1);
    S_bbbbbbS_i4_r4r4r4r4_ p1 = pp1 ? *pp1 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_bbbbbbS_i4_r4r4r4r4_ p1, Il2CppObject* p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Cast(UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[], Single, Boolean) declare in UnityEngine.Collider2D
bool w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv1);
    S_bbbbbbS_i4_r4r4r4r4_ p1 = pp1 ? *pp1 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_bbbbbbS_i4_r4r4r4r4_ p1, Il2CppObject* p2, float p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddBox(UnityEngine.Vector2, UnityEngine.Vector2, Single, Single) declare in UnityEngine.PhysicsShapeGroup2D
bool w_i4tS_r4r4_S_r4r4_Dr4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_Dr4Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Linecast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[]) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 OverlapCapsule(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.ContactFilter2D, UnityEngine.Collider2D[]) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_S_r4r4_i4r4S_bbbbbbS_i4_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_i4r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv4);
    S_bbbbbbS_i4_r4r4r4r4_ p4 = pp4 ? *pp4 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_bbbbbbS_i4_r4r4r4r4_ p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[]) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_S_r4r4_i4r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_i4r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv6);
    S_bbbbbbS_i4_r4r4r4r4_ p6 = pp6 ? *pp6 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, float p5, struct S_bbbbbbS_i4_r4r4r4r4_ p6, Il2CppObject* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, UnityEngine.RaycastHit2D[], Int32) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_S_r4r4_i4r4S_r4r4_r4oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_i4r4S_r4r4_r4oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (true) {
        if (js_args_len < 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (js_args_len > 7 && !converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, float p5, Il2CppObject* p6, int32_t p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 OverlapCapsule(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Collider2D[], Int32) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_S_r4r4_i4r4oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_i4r4oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, Il2CppObject* p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Linecast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Int32) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_S_r4r4_oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddCapsule(UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in UnityEngine.PhysicsShapeGroup2D
bool w_i4tS_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[]) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv3);
    S_bbbbbbS_i4_r4r4r4r4_ p3 = pp3 ? *pp3 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_bbbbbbS_i4_r4r4r4r4_ p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[]) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_S_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv5);
    S_bbbbbbS_i4_r4r4r4r4_ p5 = pp5 ? *pp5 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, struct S_bbbbbbS_i4_r4r4r4r4_ p5, Il2CppObject* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, UnityEngine.RaycastHit2D[], Int32) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_S_r4r4_r4S_r4r4_r4oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_r4S_r4r4_r4oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, Il2CppObject* p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.RaycastHit2D[], Int32) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_S_r4r4_r4oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_r4oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Cast(UnityEngine.Vector2, UnityEngine.RaycastHit2D[]) declare in UnityEngine.Rigidbody2D
bool w_i4tS_r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 OverlapPoint(UnityEngine.Vector2, UnityEngine.Collider2D[], Int32) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, Il2CppObject* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Cast(UnityEngine.Vector2, System.Collections.Generic.List`1[UnityEngine.RaycastHit2D], Single) declare in UnityEngine.Rigidbody2D
bool w_i4tS_r4r4_oDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_oDr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, Il2CppObject* p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Cast(UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single) declare in UnityEngine.Rigidbody2D
bool w_i4tS_r4r4_or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_or4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, Il2CppObject* p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Cast(UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Boolean) declare in UnityEngine.Collider2D
bool w_i4tS_r4r4_or4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_or4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, Il2CppObject* p1, float p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Raycast(UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32) declare in UnityEngine.Collider2D
bool w_i4tS_r4r4_or4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_or4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, Il2CppObject* p1, float p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Raycast(UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32, Single) declare in UnityEngine.Collider2D
bool w_i4tS_r4r4_or4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_or4i4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, Il2CppObject* p1, float p2, int32_t p3, float p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Raycast(UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32, Single, Single) declare in UnityEngine.Collider2D
bool w_i4tS_r4r4_or4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_or4i4r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, Il2CppObject* p1, float p2, int32_t p3, float p4, float p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddCircle(UnityEngine.Vector2, Single) declare in UnityEngine.PhysicsShapeGroup2D
bool w_i4tS_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, float p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 OverlapCircle(UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D, UnityEngine.Collider2D[]) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, float p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[]) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv4);
    S_bbbbbbS_i4_r4r4r4r4_ p4 = pp4 ? *pp4 : S_bbbbbbS_i4_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, float p3, struct S_bbbbbbS_i4_r4r4r4r4_ p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, UnityEngine.RaycastHit2D[], Int32) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_r4S_r4r4_r4oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_r4S_r4r4_r4oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, float p3, Il2CppObject* p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 OverlapCircle(UnityEngine.Vector2, Single, UnityEngine.Collider2D[], Int32) declare in UnityEngine.PhysicsScene2D
bool w_i4tS_r4r4_r4oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_r4oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p0, float p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.CollisionFlags Move(UnityEngine.Vector3) declare in UnityEngine.CharacterController
bool w_i4tS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[]) declare in UnityEngine.PhysicsScene
bool w_i4tS_r4r4r4_S_r4r4r4_S_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_S_r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.PhysicsScene
bool w_i4tS_r4r4r4_S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_Dr4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_Dr4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (js_args_len > 5 && !converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, Il2CppObject* p3, struct S_r4r4r4r4_ p4, float p5, int32_t p6, int32_t p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 OverlapBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Collider[]) declare in UnityEngine.PhysicsScene
bool w_i4tS_r4r4r4_S_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.PhysicsScene
bool w_i4tS_r4r4r4_S_r4r4r4_oDr4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_oDr4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, Il2CppObject* p2, float p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 OverlapBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Collider[], UnityEngine.Quaternion, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.PhysicsScene
bool w_i4tS_r4r4r4_S_r4r4r4_oS_r4r4r4r4_Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_oS_r4r4r4r4_Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.PhysicsScene
bool w_i4tS_r4r4r4_S_r4r4r4_r4S_r4r4r4_oDr4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_r4S_r4r4r4_oDr4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, Il2CppObject* p4, float p5, int32_t p6, int32_t p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 OverlapCapsule(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Collider[], Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.PhysicsScene
bool w_i4tS_r4r4r4_S_r4r4r4_r4oDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_r4oDi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.PhysicsScene
bool w_i4tS_r4r4r4_r4S_r4r4r4_oDr4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_r4S_r4r4r4_oDr4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p0, float p1, struct S_r4r4r4_ p2, Il2CppObject* p3, float p4, int32_t p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 OverlapSphere(UnityEngine.Vector3, Single, UnityEngine.Collider[], Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.PhysicsScene
bool w_i4tS_r4r4r4_r4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_r4oi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p0, float p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetHashCode(UnityEngine.Color) declare in UnityEngine.TestTools.Utils.ColorEqualityComparer
bool w_i4tS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetCursorStringIndex(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Vector2) declare in UnityEngine.GUIStyle
bool w_i4tS_r4r4r4r4_oS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4r4_oS_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, struct S_r4r4_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IntegerProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, System.String) declare in UnityEditor.MaterialEditor
bool w_i4tS_r4r4r4r4_os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4r4_os");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddKey(UnityEngine.Keyframe) declare in UnityEngine.AnimationCurve
bool w_i4tS_r4r4r4r4i4i4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4r4i4i4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4i4i4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4i4i4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4i4i4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4i4i4r4r4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4r4i4i4r4r4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.Collections.Generic.KeyValuePair`2[System.String,System.Object]) declare in System.Diagnostics.TagList
bool w_i4tS_sO_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_sO_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sO_* pp0 = DataTransfer::GetPointer<S_sO_>(apis, env, _sv0);
    S_sO_ p0 = pp0 ? *pp0 : S_sO_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_sO_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UnityEditor.Build.NamedBuildTarget) declare in UnityEditor.Build.NamedBuildTarget
bool w_i4tS_s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_s_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_s_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UnityEditor.Search.SearchResult) declare in UnityEditor.Search.SearchResult
bool w_i4tS_si4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_si4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_si4i4_* pp0 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv0);
    S_si4i4_ p0 = pp0 ? *pp0 : S_si4i4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_si4i4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(UnityEditor.Search.StringView, System.StringComparison) declare in UnityEditor.Search.StringView
bool w_i4tS_si4i4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_si4i4_Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_si4i4_* pp0 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv0);
    S_si4i4_ p0 = pp0 ? *pp0 : S_si4i4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(void*,struct S_si4i4_ p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(Microsoft.Extensions.Primitives.StringSegment, Microsoft.Extensions.Primitives.StringSegment) declare in Microsoft.Extensions.Primitives.StringSegmentComparer
bool w_i4tS_si4i4_S_si4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_si4i4_S_si4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_si4i4_* pp0 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv0);
    S_si4i4_ p0 = pp0 ? *pp0 : S_si4i4_ {};
    // JSValToCSVal struct
    S_si4i4_* pp1 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv1);
    S_si4i4_ p1 = pp1 ? *pp1 : S_si4i4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_si4i4_ p0, struct S_si4i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UnityEditor.Search.SearchDocument) declare in UnityEditor.Search.SearchDocument
bool w_i4tS_si4ssi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_si4ssi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_si4ssi4_* pp0 = DataTransfer::GetPointer<S_si4ssi4_>(apis, env, _sv0);
    S_si4ssi4_ p0 = pp0 ? *pp0 : S_si4ssi4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_si4ssi4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlString
bool w_i4tS_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_soi4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_soi4i4b_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UnityEditor.Search.SearchProposition) declare in UnityEditor.Search.SearchProposition
bool w_i4tS_sssi4i4osS_r4r4r4r4_oi4O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_sssi4i4osS_r4r4r4r4_oi4O_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sssi4i4osS_r4r4r4r4_oi4O_* pp0 = DataTransfer::GetPointer<S_sssi4i4osS_r4r4r4r4_oi4O_>(apis, env, _sv0);
    S_sssi4i4osS_r4r4r4r4_oi4O_ p0 = pp0 ? *pp0 : S_sssi4i4osS_r4r4r4r4_oi4O_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_sssi4i4osS_r4r4r4r4_oi4O_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UnityEditor.ManagedReferenceMissingType) declare in UnityEditor.ManagedReferenceMissingType
bool w_i4tS_sssi8s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_sssi8s_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sssi8s_* pp0 = DataTransfer::GetPointer<S_sssi8s_>(apis, env, _sv0);
    S_sssi8s_ p0 = pp0 ? *pp0 : S_sssi8s_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_sssi8s_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Data.SqlTypes.SqlBoolean) declare in System.Data.SqlTypes.SqlBoolean
bool w_i4tS_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_u1_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.Data.SqlTypes.SqlDecimal) declare in System.Data.SqlTypes.SqlDecimal
bool w_i4tS_u1u1u1u1u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u1u1u1u1u4u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u4u4u4u4_>(apis, env, _sv0);
    S_u1u1u1u1u4u4u4u4_ p0 = pp0 ? *pp0 : S_u1u1u1u1u4u4u4u4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_u1u1u1u1u4u4u4u4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UnityEngine.GraphicsBufferHandle) declare in UnityEngine.GraphicsBufferHandle
bool w_i4tS_u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4_* pp0 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv0);
    S_u4_ p0 = pp0 ? *pp0 : S_u4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_u4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetInt(UnityEngine.Animations.AnimationStream) declare in UnityEngine.Animations.PropertyStreamHandle
bool w_i4tS_u4pppppp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u4pppppp_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4pppppp_* pp0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, _sv0);
    S_u4pppppp_ p0 = pp0 ? *pp0 : S_u4pppppp_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_u4pppppp_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UnityEngine.RefreshRate) declare in UnityEngine.RefreshRate
bool w_i4tS_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_u4u4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UnityEditor.GUID) declare in UnityEditor.GUID
bool w_i4tS_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u4u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_u4u4u4u4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UnityEditor.Search.PropertyDatabaseRecordKey) declare in UnityEditor.Search.PropertyDatabaseRecordKey
bool w_i4tS_u8S_u8u8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u8S_u8u8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8S_u8u8__* pp0 = DataTransfer::GetPointer<S_u8S_u8u8__>(apis, env, _sv0);
    S_u8S_u8u8__ p0 = pp0 ? *pp0 : S_u8S_u8u8__ {};

    typedef int32_t (*FuncToCall)(void*,struct S_u8S_u8u8__ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(System.DateTime) declare in System.DateTime
bool w_i4tS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_u8_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Experimental.AI.PathQueryStatus GetEdgesAndNeighbors(UnityEngine.Experimental.AI.PolygonId, Unity.Collections.NativeSlice`1[UnityEngine.Vector3], Unity.Collections.NativeSlice`1[UnityEngine.Experimental.AI.PolygonId], Unity.Collections.NativeSlice`1[System.Byte], Int32 ByRef, Int32 ByRef) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_i4tS_u8_S_Pvi4i4i4i4S_pi4i4__S_Pvi4i4i4i4S_pi4i4__S_Pvi4i4i4i4S_pi4i4__Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u8_S_Pvi4i4i4i4S_pi4i4__S_Pvi4i4i4i4S_pi4i4__S_Pvi4i4i4i4S_pi4i4__Pi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4i4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, _sv1);
    S_Pvi4i4i4i4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pvi4i4i4i4S_pi4i4__ {};
    // JSValToCSVal struct
    S_Pvi4i4i4i4S_pi4i4__* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, _sv2);
    S_Pvi4i4i4i4S_pi4i4__ p2 = pp2 ? *pp2 : S_Pvi4i4i4i4S_pi4i4__ {};
    // JSValToCSVal struct
    S_Pvi4i4i4i4S_pi4i4__* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, _sv3);
    S_Pvi4i4i4i4S_pi4i4__ p3 = pp3 ? *pp3 : S_Pvi4i4i4i4S_pi4i4__ {};
    // JSValToCSVal P primitive
    int32_t up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;
    // JSValToCSVal P primitive
    int32_t up5 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv5);
    int32_t* p5 = &up5;

    typedef int32_t (*FuncToCall)(void*,struct S_u8_ p0, struct S_Pvi4i4i4i4S_pi4i4__ p1, struct S_Pvi4i4i4i4S_pi4i4__ p2, struct S_Pvi4i4i4i4S_pi4i4__ p3, int32_t* p4, int32_t* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv4, converter::Converter<int32_t>::toScript(apis, env, *p4));
    apis->update_boxed_value(env, _sv5, converter::Converter<int32_t>::toScript(apis, env, *p5));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetWeekOfYear(System.DateTime, System.Globalization.CalendarWeekRule, System.DayOfWeek) declare in System.Globalization.Calendar
bool w_i4tS_u8_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u8_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,struct S_u8_ p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UnityEngine.Hash128) declare in UnityEngine.Hash128
bool w_i4tS_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv0);
    S_u8u8_ p0 = pp0 ? *pp0 : S_u8u8_ {};

    typedef int32_t (*FuncToCall)(void*,struct S_u8u8_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 SetValues(System.Object[]) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_i4tVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tVO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
    }
    
    // JSValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, js_args_len, 0);
                

    typedef int32_t (*FuncToCall)(void*,Il2CppArray* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(Boolean) declare in System.Boolean
bool w_i4tb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,bool p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 FilterCount(Boolean, States[]) declare in UnityEditor.VersionControl.AssetList
bool w_i4tbVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tbVi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive params
    Il2CppArray* p1 = Params<int32_t>::PackPrimitive(apis, env, info, TIp1, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(void*,bool p0, Il2CppArray* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 QueryIndices(Boolean, Int32, Int32[], Int32) declare in UnityEngine.CullingGroup
bool w_i4tbi4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tbi4oi4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,bool p0, int32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 QueryIndices(Boolean, Int32[], Int32) declare in UnityEngine.CullingGroup
bool w_i4tboi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tboi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,bool p0, Il2CppObject* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(Char) declare in System.String
bool w_i4tc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tc");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,Il2CppChar p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(Char, System.StringComparison) declare in UnityEditor.Search.StringView
bool w_i4tcDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tcDi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(void*,Il2CppChar p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(Char, Int32) declare in System.String
bool w_i4tci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tci4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppChar p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(Char, Int32, Int32) declare in System.String
bool w_i4tci4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tci4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppChar p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(SByte) declare in System.SByte
bool w_i4ti1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,int8_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(Int16) declare in System.Int16
bool w_i4ti2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,int16_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetHashCode(System.StringComparison) declare in System.String
bool w_i4ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 MoveKey(Int32, UnityEngine.Keyframe ByRef) declare in UnityEngine.Rendering.TextureCurve
bool w_i4ti4PS_r4r4r4r4i4i4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4PS_r4r4r4r4i4i4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_r4r4r4r4i4i4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4i4i4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4i4i4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4r4i4i4r4r4_));
        p1 = &up1;
    }
        

    typedef int32_t (*FuncToCall)(void*,int32_t p0, struct S_r4r4r4r4i4i4r4r4_* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// UnityEngine.Experimental.AI.PathQueryStatus UpdateFindPath(Int32, Int32 ByRef) declare in UnityEngine.Experimental.AI.NavMeshQuery
bool w_i4ti4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4Pi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 MoveKey(Int32, UnityEngine.Keyframe) declare in UnityEngine.AnimationCurve
bool w_i4ti4S_r4r4r4r4i4i4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4S_r4r4r4r4i4i4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4i4i4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4i4i4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4i4i4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4i4i4r4r4_ {};

    typedef int32_t (*FuncToCall)(void*,int32_t p0, struct S_r4r4r4r4i4i4r4r4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 FindAssignedEditPositionFrom(Int32, Boolean) declare in System.ComponentModel.MaskedTextProvider
bool w_i4ti4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Next(Int32, Int32) declare in System.Random
bool w_i4ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 BinarySearch(Int32, Int32, System.Object, System.Collections.IComparer) declare in System.Collections.ArrayList
bool w_i4ti4i4Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4Oo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Fill(Int32, Int32, System.Data.DataTable[]) declare in System.Data.Common.DbDataAdapter
bool w_i4ti4i4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4Vo");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppArray* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 FindAssignedEditPositionInRange(Int32, Int32, Boolean) declare in System.ComponentModel.MaskedTextProvider
bool w_i4ti4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetDaysInMonth(Int32, Int32, Int32) declare in System.Globalization.PersianCalendar
bool w_i4ti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetColumn(Int32, Int32, Codice.CM.Client.Differences.MovementDirection, Int32 ByRef) declare in Codice.CM.Client.Differences.VirtualSpace
bool w_i4ti4i4i4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4i4Pi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Add(Int32, Int32, Codice.CM.Client.Differences.DifferenceType, System.String, System.String) declare in Codice.CM.Client.Differences.DiffCollection
bool w_i4ti4i4i4ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4i4ss");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Check(Int32, Int32, System.Func`2[System.Object,System.Boolean], System.Collections.Generic.Dictionary`2[System.Object,System.Int32]) declare in Puerts.ObjectPool
bool w_i4ti4i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4oo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetPhysicsShape(Int32, System.Collections.Generic.List`1[UnityEngine.Vector2]) declare in UnityEngine.Sprite
bool w_i4ti4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetTriggerParticles(UnityEngine.ParticleSystem, UnityEngine.ParticleSystemTriggerEventType, System.Collections.Generic.List`1[UnityEngine.ParticleSystem+Particle], ColliderData ByRef) declare in UnityEngine.ParticlePhysicsExtensions
bool w_i4ti4oPS_ooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4oPS_ooo_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Pstruct
    S_ooo_* p2 = DataTransfer::GetPointer<S_ooo_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_ooo_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_ooo_));
        p2 = &up2;
    }
        

    typedef int32_t (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, struct S_ooo_* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// PlasticGui.Help.HelpEntry GetEntryFromHelpButton(PlasticGui.ViewType, System.Collections.Generic.List`1[PlasticGui.Help.Condition], System.DateTime) declare in PlasticGui.Help.GuiHelp
bool w_i4ti4oS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4oS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};

    typedef int32_t (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, struct S_u8_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// PlasticGui.Help.HelpEntry GetEntryFromView(PlasticGui.ViewType, System.Collections.Generic.List`1[PlasticGui.Help.Condition], System.DateTime, System.Collections.Generic.HashSet`1[PlasticGui.Help.HelpEntry], System.Collections.Generic.HashSet`1[PlasticGui.Help.HelpEntry]) declare in PlasticGui.Help.GuiHelp
bool w_i4ti4oS_u8_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4oS_u8_oo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, struct S_u8_ p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 QueryIndices(Int32, Int32[], Int32) declare in UnityEngine.CullingGroup
bool w_i4ti4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4oi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IOControl(Int32, Byte[], Byte[]) declare in System.Net.Sockets.Socket
bool w_i4ti4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4oo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(Int64) declare in System.Int64
bool w_i4ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,int64_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IOControl(System.Net.Sockets.IOControlCode, Byte[], Byte[]) declare in System.Net.Sockets.Socket
bool w_i4ti8oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti8oo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,int64_t p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOfAny(Char[]) declare in System.String
bool w_i4to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4to");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddEdges(System.Collections.Generic.List`1[UnityEngine.Vector2], Single) declare in UnityEngine.PhysicsShapeGroup2D
bool w_i4toDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toDr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, float p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Fill(System.Data.DataTable, System.Object) declare in System.Data.OleDb.OleDbDataAdapter
bool w_i4toO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Fill(System.Data.DataSet, System.Object, System.String) declare in System.Data.OleDb.OleDbDataAdapter
bool w_i4toOs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toOs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 EndReceive(System.IAsyncResult, System.Net.Sockets.SocketError ByRef) declare in System.Net.Sockets.Socket
bool w_i4toPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toPi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 EndReceiveMessageFrom(System.IAsyncResult, System.Net.Sockets.SocketFlags ByRef, System.Net.EndPoint ByRef, System.Net.Sockets.IPPacketInformation ByRef) declare in System.Net.Sockets.Socket
bool w_i4toPi4PoPS_oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toPi4PoPS_oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        
    // JSValToCSVal Pstruct
    S_oi4_* p3 = DataTransfer::GetPointer<S_oi4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_oi4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_oi4_));
        p3 = &up3;
    }
        

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t* p1, Il2CppObject** p2, struct S_oi4_* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Codice.CM.Common.Zlib.Types.ZLibError Compress(Byte[], Int32 ByRef, Byte[], Int32) declare in Codice.CM.Common.Zlib.Unix.ZLibLinux
bool w_i4toPi4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toPi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t* p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Codice.CM.Common.Zlib.Types.ZLibError Compress2(Byte[], Int32 ByRef, Byte[], Int32, Codice.CM.Common.Zlib.Types.ZLibCompressionLevel) declare in Codice.CM.Common.Zlib.Unix.ZLibLinux
bool w_i4toPi4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toPi4oi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ReceiveFrom(Byte[], System.Net.EndPoint ByRef) declare in System.Net.Sockets.Socket
bool w_i4toPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject** p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext) declare in UnityEngine.UIElements.UxmlIntAttributeDescription
bool w_i4toS_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toS_oooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, struct S_oooo_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ExecuteAssemblyByName(System.Reflection.AssemblyName, System.String[]) declare in System.AppDomain
bool w_i4toVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toVs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppArray* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddEdges(System.Collections.Generic.List`1[UnityEngine.Vector2], Boolean, Boolean, UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in UnityEngine.PhysicsShapeGroup2D
bool w_i4tobbS_r4r4_S_r4r4_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tobbS_r4r4_S_r4r4_Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (js_args_len > 5 && !converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, bool p1, bool p2, struct S_r4r4_ p3, struct S_r4r4_ p4, float p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Wait(IntPtr[], Boolean, Int32) declare in System.Threading.SynchronizationContext
bool w_i4tobi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tobi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, bool p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOfAny(Char[], Int32) declare in System.String
bool w_i4toi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetShapes(UnityEngine.PhysicsShapeGroup2D, Int32, Int32) declare in UnityEngine.Collider2D
bool w_i4toi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Receive(System.Collections.Generic.IList`1[System.ArraySegment`1[System.Byte]], System.Net.Sockets.SocketFlags, System.Net.Sockets.SocketError ByRef) declare in System.Net.Sockets.Socket
bool w_i4toi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ReceiveFrom(Byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint ByRef) declare in System.Net.Sockets.Socket
bool w_i4toi4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, Il2CppObject** p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Decrypt(System.IO.BinaryReader, Int32, Codice.CM.Common.EnumCompressionType, Byte[]) declare in Codice.CM.Common.Encryption.AesEncryptionService
bool w_i4toi4i2o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i2o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int16_t p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOfAny(Char[], Int32, Int32) declare in System.String
bool w_i4toi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ReceiveMessageFrom(Byte[], Int32, Int32, System.Net.Sockets.SocketFlags ByRef, System.Net.EndPoint ByRef, System.Net.Sockets.IPPacketInformation ByRef) declare in System.Net.Sockets.Socket
bool w_i4toi4i4Pi4PoPS_oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4Pi4PoPS_oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;
    // JSValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv4)); // object ref
    Il2CppObject** p4 = &up4;
        
    // JSValToCSVal Pstruct
    S_oi4_* p5 = DataTransfer::GetPointer<S_oi4_>(apis, env, apis->unboxing(env, _sv5)); // valuetype ref
    S_oi4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(S_oi4_));
        p5 = &up5;
    }
        

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, int32_t* p3, Il2CppObject** p4, struct S_oi4_* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    apis->update_boxed_value(env, _sv4, CSRefToJsValue(apis, env, TIp4, *p4));
    if (p5 == &up5)
    {
        apis->update_boxed_value(env, _sv5, DataTransfer::CopyValueType(apis, env, *p5, TIp5));
    }
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ReceiveFrom(Byte[], Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint ByRef) declare in System.Net.Sockets.Socket
bool w_i4toi4i4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv3)); // object ref
    Il2CppObject** p3 = &up3;
        

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject** p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, CSRefToJsValue(apis, env, TIp3, *p3));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetCharCount(Byte[], Int32, Int32, Boolean) declare in System.Text.Decoder
bool w_i4toi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Send(Byte[], Int32, Int32, System.Net.Sockets.SocketFlags) declare in System.Net.Sockets.Socket
bool w_i4toi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Receive(Byte[], Int32, Int32, System.Net.Sockets.SocketFlags, System.Net.Sockets.SocketError ByRef) declare in System.Net.Sockets.Socket
bool w_i4toi4i4i4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4i4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P primitive
    int32_t up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, int32_t* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv4, converter::Converter<int32_t>::toScript(apis, env, *p4));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ReceiveFrom(Byte[], Int32, Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint ByRef) declare in System.Net.Sockets.Socket
bool w_i4toi4i4i4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4i4Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv4)); // object ref
    Il2CppObject** p4 = &up4;
        

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, Il2CppObject** p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv4, CSRefToJsValue(apis, env, TIp4, *p4));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 SendTo(Byte[], Int32, Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint) declare in System.Net.Sockets.Socket
bool w_i4toi4i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ReadAtOffset(Byte[], Int32, Int32, Int64) declare in Mono.Unix.UnixStream
bool w_i4toi4i4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, int64_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 SendTo(Byte[], Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint) declare in System.Net.Sockets.Socket
bool w_i4toi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetBytes(Char[], Int32, Int32, Byte[], Int32) declare in System.Text.ASCIIEncoding
bool w_i4toi4i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetChars(Byte[], Int32, Int32, Char[], Int32, Boolean) declare in System.Text.Decoder
bool w_i4toi4i4oi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4oi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject* p3, int32_t p4, bool p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Fill(System.Data.DataSet, Int32, Int32, System.String) declare in System.Data.Common.DbDataAdapter
bool w_i4toi4i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 SendTo(Byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint) declare in System.Net.Sockets.Socket
bool w_i4toi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Send(Byte[], Int32, System.String, Int32) declare in System.Net.Sockets.UdpClient
bool w_i4toi4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4si4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, int32_t p1, Il2CppString* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetCollisionEvents(UnityEngine.ParticleSystem, UnityEngine.GameObject, UnityEngine.ParticleCollisionEvent[]) declare in UnityEngine.ParticlePhysicsExtensions
bool w_i4too(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4too");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ExecuteAssemblyByName(System.Reflection.AssemblyName, System.Security.Policy.Evidence, System.String[]) declare in System.AppDomain
bool w_i4tooVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tooVs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal string params
    Il2CppArray* p2 = Params<void*>::PackString(apis, env, info, TIp2, js_args_len, 2);
                

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Clone(Codice.CM.Common.RepositoryInfo, CloneOptions, Boolean, Codice.CM.Common.IUnityOrgResolver) declare in Codice.Client.BaseCommands.Replication.ReplicationCmdImpl
bool w_i4toobo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toobo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 PopupShaderProperty(UnityEditor.MaterialEditor, UnityEditor.MaterialProperty, UnityEngine.GUIContent, System.String[]) declare in UnityEditor.Rendering.MaterialEditorExtension
bool w_i4tooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ReadArray(System.Xml.XmlDictionaryString, System.Xml.XmlDictionaryString, Boolean[], Int32, Int32) declare in System.Xml.XmlDictionaryReader
bool w_i4toooi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toooi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(Codice.CM.Common.Tree.TreeNode, Codice.CM.Common.RepositorySpec, Codice.CM.Common.Tree.TreeNode, Codice.CM.Common.RepositorySpec) declare in PlasticGui.WorkspaceWindow.BrowseRepository.BrowseRepositoryViewComparer
bool w_i4toooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetJointExternalForces(System.Collections.Generic.List`1[System.Single], Single) declare in UnityEngine.ArticulationBody
bool w_i4tor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tor4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, float p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetSprites(UnityEngine.Sprite[], System.String) declare in UnityEngine.U2D.SpriteAtlas
bool w_i4tos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Codice.CM.Common.EnumRevisionType ChangeRevisionType(Codice.CM.Common.WorkspaceInfo, System.String, Codice.CM.Common.EnumRevisionType) declare in PlasticGui.PlasticAPI
bool w_i4tosi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tosi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IntPopupShaderProperty(UnityEditor.MaterialEditor, UnityEditor.MaterialProperty, System.String, System.String[], Int32[]) declare in UnityEditor.Rendering.MaterialEditorExtension
bool w_i4tosoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tosoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Codice.CM.Common.EnumRevisionType ChangeRevisionType(Codice.CM.Common.WorkspaceInfo, System.String, System.String) declare in Codice.Client.BaseCommands.BaseCommandsImpl
bool w_i4toss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4toss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 RegisterDecimalFormat(System.Xml.XmlQualifiedName, System.String, System.String, System.String) declare in System.Xml.Xsl.Runtime.XsltLibrary
bool w_i4tosss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tosss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddInstance(UnityEngine.GraphicsBuffer, UInt32, Boolean, UnityEngine.Matrix4x4, UnityEngine.Material, Boolean, UnityEngine.MaterialPropertyBlock, UInt32, UInt32) declare in UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure
bool w_i4tou4bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oboDu4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tou4bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oboDu4Du4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (true) {
        if (js_args_len < 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (js_args_len > 7 && !converter::Converter<uint32_t>::accept(apis, env, _sv7)) return false;
        if (js_args_len > 8 && !converter::Converter<uint32_t>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal primitive with default
    uint32_t p7 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                
    // JSValToCSVal primitive with default
    uint32_t p8 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 8);
                

    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p0, uint32_t p1, bool p2, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3, Il2CppObject* p4, bool p5, Il2CppObject* p6, uint32_t p7, uint32_t p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Puerts.JsValueType GetJsValueType(IntPtr, IntPtr, Boolean) declare in Puerts.GetValueFromResultImpl
bool w_i4tppb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tppb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(Single) declare in System.Single
bool w_i4tr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tr4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,float p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 DOGoto(UnityEngine.Audio.AudioMixer, Single, Boolean) declare in DG.Tweening.DOTweenModuleAudio
bool w_i4tr4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tr4Db");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(void*,float p0, bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddKey(Single, Single) declare in UnityEngine.AnimationCurve
bool w_i4tr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tr4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,float p0, float p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(Double) declare in System.Double
bool w_i4tr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tr8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,double p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Microsoft.Win32.RegistryValueKind GetValueKind(System.String) declare in Microsoft.Win32.RegistryKey
bool w_i4ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddDocument(System.String, Boolean) declare in UnityEditor.Search.SearchIndexer
bool w_i4tsDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.String, System.StringComparison) declare in UnityEditor.Search.StringView
bool w_i4tsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ExecuteAssemblyByName(System.String, System.String[]) declare in System.AppDomain
bool w_i4tsVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsVs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, js_args_len, 1);
                

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppArray* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 LangToLcid(System.String, Boolean) declare in System.Xml.Xsl.Runtime.XsltLibrary
bool w_i4tsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.String, Char) declare in System.Globalization.CompareInfo
bool w_i4tsc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppChar p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.String, Char, System.Globalization.CompareOptions) declare in System.Globalization.CompareInfo
bool w_i4tsci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsci4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppChar p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.String, Char, Int32, System.Globalization.CompareOptions) declare in System.Globalization.CompareInfo
bool w_i4tsci4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsci4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppChar p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.String, Char, Int32, Int32, System.Globalization.CompareOptions) declare in System.Globalization.CompareInfo
bool w_i4tsci4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsci4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppChar p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.String, Int32) declare in System.String
bool w_i4tsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.String, Int32, Int32) declare in System.String
bool w_i4tsi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.String, Int32, Int32, System.StringComparison) declare in System.String
bool w_i4tsi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 GetBytes(System.String, Int32, Int32, Byte[], Int32) declare in System.Text.ASCIIEncoding
bool w_i4tsi4i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsi4i4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, int32_t p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, Int32, Int32, System.String, Int32, Int32) declare in System.Globalization.CompareInfo
bool w_i4tsi4i4si4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsi4i4si4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, Int32, Int32, System.String, Int32, Int32, System.Globalization.CompareOptions) declare in System.Globalization.CompareInfo
bool w_i4tsi4i4si4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsi4i4si4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, Int32, System.String, Int32) declare in System.Globalization.CompareInfo
bool w_i4tsi4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsi4si4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, Il2CppString* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, Int32, System.String, Int32, System.Globalization.CompareOptions) declare in System.Globalization.CompareInfo
bool w_i4tsi4si4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsi4si4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, int32_t p1, Il2CppString* p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ExecuteAssembly(System.String, System.Security.Policy.Evidence) declare in System.AppDomain
bool w_i4tso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ExecuteAssemblyByName(System.String, System.Security.Policy.Evidence, System.String[]) declare in System.AppDomain
bool w_i4tsoVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsoVs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal string params
    Il2CppArray* p2 = Params<void*>::PackString(apis, env, info, TIp2, js_args_len, 2);
                

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 DefineNamespace(System.String, System.String[], Int32) declare in Mono.CompilerServices.SymbolWriter.CompileUnitEntry
bool w_i4tsoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ExecuteAssembly(System.String, System.Security.Policy.Evidence, System.String[]) declare in System.AppDomain
bool w_i4tsoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ExecuteAssembly(System.String, System.String[], Byte[], System.Configuration.Assemblies.AssemblyHashAlgorithm) declare in System.AppDomain
bool w_i4tsooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ExecuteAssembly(System.String, System.Security.Policy.Evidence, System.String[], Byte[], System.Configuration.Assemblies.AssemblyHashAlgorithm) declare in System.AppDomain
bool w_i4tsoooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsoooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, System.String) declare in System.CultureAwareComparer
bool w_i4tss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 Compare(System.String, System.String, System.Globalization.CompareOptions) declare in System.Globalization.CompareInfo
bool w_i4tssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tssi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.String, System.String, Int32, System.Globalization.CompareOptions) declare in System.Globalization.CompareInfo
bool w_i4tssi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tssi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 IndexOf(System.String, System.String, Int32, Int32, System.Globalization.CompareOptions) declare in System.Globalization.CompareInfo
bool w_i4tssi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tssi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ReadArray(System.String, System.String, Boolean[], Int32, Int32) declare in System.Xml.XmlDictionaryReader
bool w_i4tssoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tssoi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ApplyPatch(System.String, System.String, System.String) declare in Codice.Client.BaseCommands.ApplyPatchCmdImpl
bool w_i4tsss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddDocument(System.String, System.String, System.String, Boolean, UnityEditor.Search.SearchDocumentFlags) declare in UnityEditor.Search.SearchIndexer
bool w_i4tsssbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsssbi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, bool p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(Byte) declare in System.Byte
bool w_i4tu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tu1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,uint8_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UInt16) declare in System.UInt16
bool w_i4tu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tu2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,uint16_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UInt32) declare in System.UInt32
bool w_i4tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tu4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,uint32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddGlyphPairAdjustmentRecord(UInt32, TMPro.GlyphValueRecord_Legacy, UInt32, TMPro.GlyphValueRecord_Legacy) declare in TMPro.KerningTable
bool w_i4tu4S_r4r4r4r4_u4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tu4S_r4r4r4r4_u4S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};

    typedef int32_t (*FuncToCall)(void*,uint32_t p0, struct S_r4r4r4r4_ p1, uint32_t p2, struct S_r4r4r4r4_ p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 AddKerningPair(UInt32, UInt32, Single) declare in TMPro.KerningTable
bool w_i4tu4u4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tu4u4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(void*,uint32_t p0, uint32_t p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 CompareTo(UInt64) declare in System.UInt64
bool w_i4tu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4tu8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(void*,uint64_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ToInt32(Byte) declare in System.Convert
bool w_i4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(uint8_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ToInt32(UInt16) declare in System.Convert
bool w_i4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(uint16_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ToInt32(UInt32) declare in System.Convert
bool w_i4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(uint32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 getgrgid_r(UInt32, Mono.Unix.Native.Group, Mono.Unix.Native.Group ByRef) declare in Mono.Unix.Native.Syscall
bool w_i4u4oPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4oPo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef int32_t (*FuncToCall)(uint32_t p0, Il2CppObject* p1, Il2CppObject** p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 setreuid(UInt32, UInt32) declare in Mono.Unix.Native.Syscall
bool w_i4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef int32_t (*FuncToCall)(uint32_t p0, uint32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 setresuid(UInt32, UInt32, UInt32) declare in Mono.Unix.Native.Syscall
bool w_i4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4u4u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef int32_t (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 ToInt32(UInt64) declare in System.Convert
bool w_i4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef int32_t (*FuncToCall)(uint64_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int32 setgroups(UInt64, UInt32[]) declare in Mono.Unix.Native.Syscall
bool w_i4u8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i4u8o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int32_t (*FuncToCall)(uint64_t p0, Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int32_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetAllocatedBytesForCurrentThread() declare in System.GC
bool w_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef int64_t (*FuncToCall)(const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(System.Object) declare in System.Convert
bool w_i8O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8O");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef int64_t (*FuncToCall)(Il2CppObject* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ReadInt64(System.Object, Int32) declare in System.Runtime.InteropServices.Marshal
bool w_i8Oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8Oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(System.Object, System.IFormatProvider) declare in System.Convert
bool w_i8Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8Oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int64_t (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 VolatileRead(Int64 ByRef) declare in System.Threading.Thread
bool w_i8Pi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8Pi8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv0);
    int64_t* p0 = &up0;

    typedef int64_t (*FuncToCall)(int64_t* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int64_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 Exchange(Int64 ByRef, Int64) declare in System.Threading.Interlocked
bool w_i8Pi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8Pi8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv0);
    int64_t* p0 = &up0;
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(int64_t* p0, int64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int64_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 CompareExchange(Int64 ByRef, Int64, Int64) declare in System.Threading.Interlocked
bool w_i8Pi8i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8Pi8i8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv0);
    int64_t* p0 = &up0;
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(int64_t* p0, int64_t p1, int64_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int64_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetTotalFragmentationInfo(Unity.Collections.NativeArray`1[System.Int32]) declare in UnityEngine.Profiling.Profiler
bool w_i8S_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef int64_t (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(System.ReadOnlySpan`1[System.Byte]) declare in System.BitConverter
bool w_i8S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef int64_t (*FuncToCall)(struct S_S_p_i4_ p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider) declare in System.Int64
bool w_i8S_S_p_i4_Di4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_S_p_i4_Di4Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef int64_t (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 op_Explicit(System.Data.SqlTypes.SqlInt64) declare in System.Data.SqlTypes.SqlInt64
bool w_i8S_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_bi8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi8_* pp0 = DataTransfer::GetPointer<S_bi8_>(apis, env, _sv0);
    S_bi8_ p0 = pp0 ? *pp0 : S_bi8_ {};

    typedef int64_t (*FuncToCall)(struct S_bi8_ p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(System.Decimal) declare in System.Convert
bool w_i8S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef int64_t (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 op_Explicit(System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_i8S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};

    typedef int64_t (*FuncToCall)(struct S_i4o_ p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 LongField(UnityEngine.Rect, Int64) declare in UnityEditor.EditorGUI
bool w_i8S_r4r4r4r4_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_r4r4r4r4_i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(struct S_r4r4r4r4_ p0, int64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 LongField(UnityEngine.Rect, Int64, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_i8S_r4r4r4r4_i8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_r4r4r4r4_i8o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int64_t (*FuncToCall)(struct S_r4r4r4r4_ p0, int64_t p1, Il2CppObject* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 LongField(UnityEngine.Rect, UnityEngine.GUIContent, Int64) declare in UnityEditor.EditorGUI
bool w_i8S_r4r4r4r4_oi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_r4r4r4r4_oi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, int64_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 LongField(UnityEngine.Rect, UnityEngine.GUIContent, Int64, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_i8S_r4r4r4r4_oi8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_r4r4r4r4_oi8o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int64_t (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, int64_t p2, Il2CppObject* p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 LongField(UnityEngine.Rect, System.String, Int64) declare in UnityEditor.EditorGUI
bool w_i8S_r4r4r4r4_si8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_r4r4r4r4_si8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, int64_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 LongField(UnityEngine.Rect, System.String, Int64, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_i8S_r4r4r4r4_si8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_r4r4r4r4_si8o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef int64_t (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, int64_t p2, Il2CppObject* p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(System.DateTime) declare in System.Convert
bool w_i8S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef int64_t (*FuncToCall)(struct S_u8_ p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(Boolean) declare in System.Convert
bool w_i8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(bool p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(Char) declare in System.Convert
bool w_i8c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8c");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(Il2CppChar p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(SByte) declare in System.Convert
bool w_i8i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(int8_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(Int16) declare in System.Convert
bool w_i8i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(int16_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(Int32) declare in System.Convert
bool w_i8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(int32_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 flistxattr(Int32, System.String[] ByRef) declare in Mono.Unix.Native.Syscall
bool w_i8i4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4Po");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef int64_t (*FuncToCall)(int32_t p0, Il2CppObject** p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 read(Int32, Void*, UInt64) declare in Mono.Unix.Native.Syscall
bool w_i8i4Pvu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4Pvu8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(int32_t p0, void* p1, uint64_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 recv(Int32, Void*, UInt64, Mono.Unix.Native.MessageFlags) declare in Mono.Unix.Native.Syscall
bool w_i8i4Pvu8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4Pvu8i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int64_t (*FuncToCall)(int32_t p0, void* p1, uint64_t p2, int32_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 recvfrom(Int32, Void*, UInt64, Mono.Unix.Native.MessageFlags, Mono.Unix.Native.Sockaddr) declare in Mono.Unix.Native.Syscall
bool w_i8i4Pvu8i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4Pvu8i4o");
    
    auto TIp4 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef int64_t (*FuncToCall)(int32_t p0, void* p1, uint64_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 pread(Int32, Void*, UInt64, Int64) declare in Mono.Unix.Native.Syscall
bool w_i8i4Pvu8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4Pvu8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);

    typedef int64_t (*FuncToCall)(int32_t p0, void* p1, uint64_t p2, int64_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 BigMul(Int32, Int32) declare in System.Math
bool w_i8i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 sendfile(Int32, Int32, Int64 ByRef, UInt64) declare in Mono.Unix.Native.Syscall
bool w_i8i4i4Pi8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4i4Pi8u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv2);
    int64_t* p2 = &up2;
    // JSValToCSVal P any
    uint64_t p3 = converter::Converter<uint64_t>::toCpp(apis, env, _sv3);

    typedef int64_t (*FuncToCall)(int32_t p0, int32_t p1, int64_t* p2, uint64_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int64_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetApproxCacheSizeInByte(Int32, Int32, Boolean, UnityEngine.Experimental.Rendering.GraphicsFormat) declare in UnityEngine.Rendering.PowerOfTwoTextureAtlas
bool w_i8i4i4bi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4i4bi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int64_t (*FuncToCall)(int32_t p0, int32_t p1, bool p2, int32_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 fpathconf(Int32, Mono.Unix.Native.PathconfName, Mono.Unix.Native.Errno) declare in Mono.Unix.Native.Syscall
bool w_i8i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 lseek(Int32, Int64, Mono.Unix.Native.SeekFlags) declare in Mono.Unix.Native.Syscall
bool w_i8i4i8i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4i8i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(int32_t p0, int64_t p1, int16_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 readv(Int32, Mono.Unix.Native.Iovec[]) declare in Mono.Unix.Native.Syscall
bool w_i8i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int64_t (*FuncToCall)(int32_t p0, Il2CppObject* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 flistxattr(Int32, System.Text.Encoding, System.String[] ByRef) declare in Mono.Unix.Native.Syscall
bool w_i8i4oPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4oPo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef int64_t (*FuncToCall)(int32_t p0, Il2CppObject* p1, Il2CppObject** p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 recvmsg(Int32, Mono.Unix.Native.Msghdr, Mono.Unix.Native.MessageFlags) declare in Mono.Unix.Native.Syscall
bool w_i8i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4oi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(int32_t p0, Il2CppObject* p1, int32_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 preadv(Int32, Mono.Unix.Native.Iovec[], Int64) declare in Mono.Unix.Native.Syscall
bool w_i8i4oi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4oi8");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(int32_t p0, Il2CppObject* p1, int64_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 flistxattr(Int32, Byte[], UInt64) declare in Mono.Unix.Native.Syscall
bool w_i8i4ou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4ou8");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(int32_t p0, Il2CppObject* p1, uint64_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 recv(Int32, Byte[], UInt64, Mono.Unix.Native.MessageFlags) declare in Mono.Unix.Native.Syscall
bool w_i8i4ou8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4ou8i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int64_t (*FuncToCall)(int32_t p0, Il2CppObject* p1, uint64_t p2, int32_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 recvfrom(Int32, Byte[], UInt64, Mono.Unix.Native.MessageFlags, Mono.Unix.Native.Sockaddr) declare in Mono.Unix.Native.Syscall
bool w_i8i4ou8i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4ou8i4o");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef int64_t (*FuncToCall)(int32_t p0, Il2CppObject* p1, uint64_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetInt64(Int32, IntPtr, Puerts.IGetValueFromJs, IntPtr, Boolean) declare in Puerts.PrimitiveTypeTranslate
bool w_i8i4popb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4popb");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef int64_t (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, void* p3, bool p4, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 read(Int32, IntPtr, UInt64) declare in Mono.Unix.Native.Syscall
bool w_i8i4pu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4pu8");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(int32_t p0, void* p1, uint64_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 recv(Int32, IntPtr, UInt64, Mono.Unix.Native.MessageFlags) declare in Mono.Unix.Native.Syscall
bool w_i8i4pu8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4pu8i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int64_t (*FuncToCall)(int32_t p0, void* p1, uint64_t p2, int32_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 recvfrom(Int32, IntPtr, UInt64, Mono.Unix.Native.MessageFlags, Mono.Unix.Native.Sockaddr) declare in Mono.Unix.Native.Syscall
bool w_i8i4pu8i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4pu8i4o");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef int64_t (*FuncToCall)(int32_t p0, void* p1, uint64_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 pread(Int32, IntPtr, UInt64, Int64) declare in Mono.Unix.Native.Syscall
bool w_i8i4pu8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4pu8i8");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);

    typedef int64_t (*FuncToCall)(int32_t p0, void* p1, uint64_t p2, int64_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 fgetxattr(Int32, System.String, Byte[] ByRef) declare in Mono.Unix.Native.Syscall
bool w_i8i4sPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4sPo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef int64_t (*FuncToCall)(int32_t p0, Il2CppString* p1, Il2CppObject** p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 fgetxattr(Int32, System.String, Byte[]) declare in Mono.Unix.Native.Syscall
bool w_i8i4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4so");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int64_t (*FuncToCall)(int32_t p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 fgetxattr(Int32, System.String, Byte[], UInt64) declare in Mono.Unix.Native.Syscall
bool w_i8i4sou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4sou8");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    uint64_t p3 = converter::Converter<uint64_t>::toCpp(apis, env, _sv3);

    typedef int64_t (*FuncToCall)(int32_t p0, Il2CppString* p1, Il2CppObject* p2, uint64_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(Int64) declare in System.Convert
bool w_i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(int64_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 LongField(Int64, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_i8i8Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i8Vo");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef int64_t (*FuncToCall)(int64_t p0, Il2CppArray* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 rol(Int64, Int32) declare in Unity.Mathematics.math
bool w_i8i8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i8i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(int64_t p0, int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 Max(Int64, Int64) declare in System.Math
bool w_i8i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(int64_t p0, int64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 DivRem(Int64, Int64, Int64 ByRef) declare in System.Math
bool w_i8i8i8Pi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i8i8Pi8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv2);
    int64_t* p2 = &up2;

    typedef int64_t (*FuncToCall)(int64_t p0, int64_t p1, int64_t* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int64_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 select(Int64, Int64, Boolean) declare in Unity.Mathematics.math
bool w_i8i8i8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i8i8b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(int64_t p0, int64_t p1, bool p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 Clamp(Int64, Int64, Int64) declare in System.Math
bool w_i8i8i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i8i8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(int64_t p0, int64_t p1, int64_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 LongField(Int64, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_i8i8oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8i8oVo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef int64_t (*FuncToCall)(int64_t p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetRuntimeMemorySizeLong(UnityEngine.Object) declare in UnityEngine.Profiling.Profiler
bool w_i8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8o");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef int64_t (*FuncToCall)(Il2CppObject* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ReadInt64FromBytes(Byte[], Int32) declare in JetBrains.Serialization.UnsafeReader
bool w_i8oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef int64_t (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetManagedReferenceIdForObject(UnityEngine.Object, System.Object) declare in UnityEngine.Serialization.ManagedReferenceUtility
bool w_i8oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8oO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int64_t (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(Byte[], Int32) declare in System.BitConverter
bool w_i8oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 CMSG_NXTHDR(Mono.Unix.Native.Msghdr, Int64) declare in Mono.Unix.Native.Syscall
bool w_i8oi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8oi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(Il2CppObject* p0, int64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 LongField(UnityEngine.GUIContent, Int64, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_i8oi8Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8oi8Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef int64_t (*FuncToCall)(Il2CppObject* p0, int64_t p1, Il2CppArray* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 LongField(UnityEngine.GUIContent, Int64, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_i8oi8oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8oi8oVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef int64_t (*FuncToCall)(Il2CppObject* p0, int64_t p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetCachedCset(Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.Mount.MountPointId) declare in Codice.CM.WorkspaceServer.DataStore.Trees.LocalTreesStorage
bool w_i8oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int64_t (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 op_Explicit(IntPtr) declare in System.IntPtr
bool w_i8p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8p");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(void* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ReadInt64(IntPtr, Int32) declare in System.Runtime.InteropServices.Marshal
bool w_i8pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetLongField(IntPtr, IntPtr) declare in UnityEngine.AndroidJNI
bool w_i8pp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8pp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(void* p0, void* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 CallLongMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*) declare in UnityEngine.AndroidJNI
bool w_i8ppPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ppPv");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 CallLongMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue]) declare in UnityEngine.AndroidJNI
bool w_i8ppS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ppS_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};

    typedef int64_t (*FuncToCall)(void* p0, void* p1, struct S_S_p_i4_ p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetBigIntFromValue(IntPtr, IntPtr, Boolean) declare in Puerts.PuertsDLL
bool w_i8ppb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ppb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(void* p0, void* p1, bool p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 CallLongMethod(IntPtr, IntPtr, UnityEngine.jvalue[]) declare in UnityEngine.AndroidJNI
bool w_i8ppo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int64_t (*FuncToCall)(void* p0, void* p1, Il2CppObject* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 pesapi_get_value_int64(IntPtr, IntPtr, IntPtr) declare in Puerts.NativeAPI
bool w_i8ppp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ppp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(Single) declare in System.Convert
bool w_i8r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(float p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 DoubleToInt64Bits(Double) declare in System.BitConverter
bool w_i8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(double p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(System.String) declare in System.Convert
bool w_i8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(Il2CppString* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 Hash(System.String, Int64) declare in JetBrains.Rd.RdId
bool w_i8sDi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8sDi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    int64_t p1 = OptionalParameter<int64_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef int64_t (*FuncToCall)(Il2CppString* p0, int64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 listxattr(System.String, System.String[] ByRef) declare in Mono.Unix.Native.Syscall
bool w_i8sPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8sPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef int64_t (*FuncToCall)(Il2CppString* p0, Il2CppObject** p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 CalcFileSize(System.String, Boolean) declare in Codice.Client.BaseCommands.BaseServices
bool w_i8sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8sb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(Il2CppString* p0, bool p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(System.String, Int32) declare in System.Convert
bool w_i8si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8si4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 pathconf(System.String, Mono.Unix.Native.PathconfName, Mono.Unix.Native.Errno) declare in Mono.Unix.Native.Syscall
bool w_i8si4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8si4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(Il2CppString* p0, int32_t p1, int32_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider) declare in System.Int64
bool w_i8si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8si4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int64_t (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetLong(System.String, Int64) declare in UnityEngine.RemoteSettings
bool w_i8si8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8si8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(Il2CppString* p0, int64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 LongField(System.String, Int64, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_i8si8Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8si8Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef int64_t (*FuncToCall)(Il2CppString* p0, int64_t p1, Il2CppArray* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 LongField(System.String, Int64, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_i8si8oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8si8oVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef int64_t (*FuncToCall)(Il2CppString* p0, int64_t p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(System.String, System.IFormatProvider) declare in System.Convert
bool w_i8so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int64_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 listxattr(System.String, System.Text.Encoding, System.String[] ByRef) declare in Mono.Unix.Native.Syscall
bool w_i8soPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8soPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef int64_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject** p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 listxattr(System.String, Byte[], UInt64) declare in Mono.Unix.Native.Syscall
bool w_i8sou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8sou8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, uint64_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetLong(System.String, System.String) declare in Codice.Utils.ConfigurationManager
bool w_i8ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 getxattr(System.String, System.String, Byte[] ByRef) declare in Mono.Unix.Native.Syscall
bool w_i8ssPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ssPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef int64_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject** p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetLong(System.String, System.String, Int64) declare in Codice.Utils.ConfigurationManager
bool w_i8ssi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ssi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int64_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 getxattr(System.String, System.String, Byte[]) declare in Mono.Unix.Native.Syscall
bool w_i8sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8sso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int64_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 getxattr(System.String, System.String, Byte[], UInt64) declare in Mono.Unix.Native.Syscall
bool w_i8ssou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ssou8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    uint64_t p3 = converter::Converter<uint64_t>::toCpp(apis, env, _sv3);

    typedef int64_t (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, uint64_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToBinary() declare in System.DateTime
bool w_i8t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8t");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef int64_t (*FuncToCall)(void*,const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(System.Object) declare in System.Runtime.Serialization.FormatterConverter
bool w_i8tO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8tO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef int64_t (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetId(System.Object, Boolean ByRef) declare in System.Runtime.Serialization.ObjectIDGenerator
bool w_i8tOPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8tOPb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;

    typedef int64_t (*FuncToCall)(void*,Il2CppObject* p0, bool* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetLongLength(Int32) declare in System.Array
bool w_i8ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ti4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(void*,int32_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 Seek(Int32, System.IO.SeekOrigin) declare in System.IO.BinaryWriter
bool w_i8ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ti4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetItemMergedSamplesMetadataAsLong(Int32, Int32, Int32) declare in UnityEditor.Profiling.HierarchyFrameDataView
bool w_i8ti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ti4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetBytes(Int32, Int64, Byte[], Int32, Int32) declare in Microsoft.SqlServer.Server.SqlDataRecord
bool w_i8ti4i8oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ti4i8oi4i4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int64_t (*FuncToCall)(void*,int32_t p0, int64_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ReadInt64(Int64) declare in System.IO.UnmanagedMemoryAccessor
bool w_i8ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ti8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(void*,int64_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 Seek(Int64, System.IO.SeekOrigin) declare in System.Security.Cryptography.CryptoStream
bool w_i8ti8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ti8i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(void*,int64_t p0, int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 NextLong(Int64, Int64) declare in NUnit.Framework.Internal.Randomizer
bool w_i8ti8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ti8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(void*,int64_t p0, int64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 Read(Int64, Byte[], Int32, Int32) declare in System.Data.SqlTypes.SqlBytes
bool w_i8ti8oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ti8oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef int64_t (*FuncToCall)(void*,int64_t p0, Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 AddCallback(Puerts.JSFunctionCallback) declare in Puerts.JsEnv
bool w_i8to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8to");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef int64_t (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetChangesetId(Codice.CM.Common.RepositoryInfo, System.Guid) declare in Codice.Client.Common.Xlinks.XlinkResolver
bool w_i8toS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8toS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef int64_t (*FuncToCall)(void*,Il2CppObject* p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext) declare in UnityEngine.UIElements.UxmlLongAttributeDescription
bool w_i8toS_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8toS_oooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};

    typedef int64_t (*FuncToCall)(void*,Il2CppObject* p0, struct S_oooo_ p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetParentChangeset(Codice.CM.Common.RepositorySpec, Int64) declare in PlasticGui.PlasticAPI
bool w_i8toi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8toi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(void*,Il2CppObject* p0, int64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 CreateComment(Codice.CM.Common.RepositorySpec, Int64, Codice.CM.Common.CodeReviewCommentInfo) declare in PlasticGui.PlasticAPI
bool w_i8toi8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8toi8o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef int64_t (*FuncToCall)(void*,Il2CppObject* p0, int64_t p1, Il2CppObject* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetParentChangesetIdForBranch(Codice.CM.Common.RepositoryInfo, Codice.CM.Common.BranchInfo) declare in PlasticGui.PlasticAPI
bool w_i8too(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8too");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef int64_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetLoadedRevisionId(Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.RepositorySpec, Int64) declare in PlasticGui.PlasticAPI
bool w_i8tooi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8tooi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, int64_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetAttributeIdForRepository(Codice.CM.Common.RepositorySpec, System.String) declare in PlasticGui.PlasticAPI
bool w_i8tos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8tos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetBigInt(IntPtr, IntPtr, Boolean) declare in Puerts.GetValueFromResultImpl
bool w_i8tppb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8tppb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef int64_t (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetInt64(System.String) declare in System.Runtime.Serialization.SerializationInfo
bool w_i8ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetLong(System.String, Int64) declare in UnityEngine.RemoteConfigSettings
bool w_i8tsi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8tsi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(void*,Il2CppString* p0, int64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetBytes(System.Data.Common.DbDataReader, System.String, Int64, Byte[], Int32, Int32) declare in System.Data.DataReaderExtensions
bool w_i8tsi8oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8tsi8oi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef int64_t (*FuncToCall)(void*,Il2CppString* p0, int64_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ReadElementContentAsLong(System.String, System.String) declare in System.Xml.XmlReader
bool w_i8tss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8tss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef int64_t (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 GetBytesRead(UInt32) declare in Unity.IO.LowLevel.Unsafe.ReadHandle
bool w_i8tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8tu4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(void*,uint32_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(Byte) declare in System.Convert
bool w_i8u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8u1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(uint8_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(UInt16) declare in System.Convert
bool w_i8u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8u2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(uint16_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(UInt32) declare in System.Convert
bool w_i8u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8u4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(uint32_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Int64 ToInt64(UInt64) declare in System.Convert
bool w_i8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_i8u8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef int64_t (*FuncToCall)(uint64_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<int64_t>::toScript(apis, env, ret));
    return true;
}

// Microsoft.Win32.SafeHandles.SafeAccessTokenHandle get_InvalidHandle() declare in Microsoft.Win32.SafeHandles.SafeAccessTokenHandle
bool w_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_o");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef Il2CppObject* (*FuncToCall)(const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.IDOTweenInit Init(System.Nullable`1[System.Boolean], System.Nullable`1[System.Boolean], System.Nullable`1[DG.Tweening.LogBehaviour]) declare in DG.Tweening.DOTween
bool w_oDN_bb_DN_bb_DN_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oDN_bb_DN_bb_DN_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    N_bb_ p0 = OptionalParameter<N_bb_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                
    // JSValToCSVal valuetype  with default
    N_bb_ p1 = OptionalParameter<N_bb_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal valuetype  with default
    N_bi4_ p2 = OptionalParameter<N_bi4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bb_ p0, struct N_bb_ p1, struct N_bi4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task`1[System.String] GetServiceTokenAsync(System.Threading.CancellationToken) declare in UnityEditor.CloudProjectSettings
bool w_oDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_o_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[System.Type] GetAllTypes(Boolean) declare in Puerts.Utils
bool w_oDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oDb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef Il2CppObject* (*FuncToCall)(bool p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// FullscreenEditor.FullscreenContainer[] GetAllFullscreen(Boolean, Boolean) declare in FullscreenEditor.Fullscreen
bool w_oDbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oDbDb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(bool p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[Cysharp.Threading.Tasks.AsyncUnit] EveryUpdate(Cysharp.Threading.Tasks.PlayerLoopTiming, Boolean) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_oDi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oDi4Db");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.IEnumerable`1[UnityEditor.Search.SearchColumn] Enumerate(System.Collections.Generic.IEnumerable`1[UnityEditor.Search.SearchItem]) declare in UnityEditor.Search.ItemSelectors
bool w_oDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal ref  with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 0, TIp0);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.PackageManager.Requests.AddAndRemoveRequest AddAndRemove(System.String[], System.String[]) declare in UnityEditor.PackageManager.Client
bool w_oDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oDoDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal ref  with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 0, TIp0);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Search.ISearchView ShowWindow(UnityEditor.Search.SearchContext, System.String, Single, Single, Boolean, Boolean, Boolean, Boolean) declare in UnityEditor.Search.SearchService
bool w_oDoDsDr4Dr4DbDbDbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oDoDsDr4Dr4DbDbDbDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<bool>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal ref  with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 0, TIp0);
                
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    bool p6 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    bool p7 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, float p2, float p3, bool p4, bool p5, bool p6, bool p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.IDictionary`2[System.String,System.Object] GetDictionary(System.String) declare in UnityEngine.RemoteSettings
bool w_oDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal string  with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task`1[System.Collections.Generic.List`1[NugetForUnity.Models.INugetPackage]] SearchAsync(System.String, Boolean, Int32, Int32, System.Threading.CancellationToken) declare in NugetForUnity.Configuration.ConfigurationManager
bool w_oDsDbDi4Di4DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oDsDbDi4Di4DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal string  with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 0);
                
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal valuetype  with default
    S_o_ p4 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p0, bool p1, int32_t p2, int32_t p3, struct S_o_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.DateTimeOffset]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bS_S_u8_i2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bS_S_u8_i2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bS_S_u8_i2__* pp0 = DataTransfer::GetPointer<N_bS_S_u8_i2__>(apis, env, _sv0);
    N_bS_S_u8_i2__ p0 = pp0 ? *pp0 : N_bS_S_u8_i2__ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bS_S_u8_i2__ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.DateTimeOffset], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bS_S_u8_i2__DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bS_S_u8_i2__DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bS_S_u8_i2__* pp0 = DataTransfer::GetPointer<N_bS_S_u8_i2__>(apis, env, _sv0);
    N_bS_S_u8_i2__ p0 = pp0 ? *pp0 : N_bS_S_u8_i2__ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bS_S_u8_i2__ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.Guid]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bS_i4i2i2u1u1u1u1u1u1u1u1__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bS_i4i2i2u1u1u1u1u1u1u1u1__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bS_i4i2i2u1u1u1u1u1u1u1u1__* pp0 = DataTransfer::GetPointer<N_bS_i4i2i2u1u1u1u1u1u1u1u1__>(apis, env, _sv0);
    N_bS_i4i2i2u1u1u1u1u1u1u1u1__ p0 = pp0 ? *pp0 : N_bS_i4i2i2u1u1u1u1u1u1u1u1__ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bS_i4i2i2u1u1u1u1u1u1u1u1__ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.Guid], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bS_i4i2i2u1u1u1u1u1u1u1u1__DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bS_i4i2i2u1u1u1u1u1u1u1u1__DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bS_i4i2i2u1u1u1u1u1u1u1u1__* pp0 = DataTransfer::GetPointer<N_bS_i4i2i2u1u1u1u1u1u1u1u1__>(apis, env, _sv0);
    N_bS_i4i2i2u1u1u1u1u1u1u1u1__ p0 = pp0 ? *pp0 : N_bS_i4i2i2u1u1u1u1u1u1u1u1__ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bS_i4i2i2u1u1u1u1u1u1u1u1__ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.Decimal]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bS_i4i4i4i4u8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bS_i4i4i4i4u8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bS_i4i4i4i4u8__* pp0 = DataTransfer::GetPointer<N_bS_i4i4i4i4u8__>(apis, env, _sv0);
    N_bS_i4i4i4i4u8__ p0 = pp0 ? *pp0 : N_bS_i4i4i4i4u8__ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bS_i4i4i4i4u8__ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.Decimal], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bS_i4i4i4i4u8__DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bS_i4i4i4i4u8__DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bS_i4i4i4i4u8__* pp0 = DataTransfer::GetPointer<N_bS_i4i4i4i4u8__>(apis, env, _sv0);
    N_bS_i4i4i4i4u8__ p0 = pp0 ? *pp0 : N_bS_i4i4i4i4u8__ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bS_i4i4i4i4u8__ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Unity.Plastic.Newtonsoft.Json.Linq.JToken op_Implicit(System.Nullable`1[System.TimeSpan]) declare in Unity.Plastic.Newtonsoft.Json.Linq.JToken
bool w_oN_bS_i8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bS_i8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bS_i8__* pp0 = DataTransfer::GetPointer<N_bS_i8__>(apis, env, _sv0);
    N_bS_i8__ p0 = pp0 ? *pp0 : N_bS_i8__ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bS_i8__ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.Text.Json.JsonElement], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bS_oi4__DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bS_oi4__DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bS_oi4__* pp0 = DataTransfer::GetPointer<N_bS_oi4__>(apis, env, _sv0);
    N_bS_oi4__ p0 = pp0 ? *pp0 : N_bS_oi4__ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bS_oi4__ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.DateTime]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bS_u8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bS_u8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bS_u8__* pp0 = DataTransfer::GetPointer<N_bS_u8__>(apis, env, _sv0);
    N_bS_u8__ p0 = pp0 ? *pp0 : N_bS_u8__ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bS_u8__ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.DateTime], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bS_u8__DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bS_u8__DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bS_u8__* pp0 = DataTransfer::GetPointer<N_bS_u8__>(apis, env, _sv0);
    N_bS_u8__ p0 = pp0 ? *pp0 : N_bS_u8__ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bS_u8__ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.Boolean]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bb_* pp0 = DataTransfer::GetPointer<N_bb_>(apis, env, _sv0);
    N_bb_ p0 = pp0 ? *pp0 : N_bb_ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bb_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.Boolean], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bb_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bb_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bb_* pp0 = DataTransfer::GetPointer<N_bb_>(apis, env, _sv0);
    N_bb_ p0 = pp0 ? *pp0 : N_bb_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bb_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.Char]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bc_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bc_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bc_* pp0 = DataTransfer::GetPointer<N_bc_>(apis, env, _sv0);
    N_bc_ p0 = pp0 ? *pp0 : N_bc_ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bc_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.Char], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bc_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bc_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bc_* pp0 = DataTransfer::GetPointer<N_bc_>(apis, env, _sv0);
    N_bc_ p0 = pp0 ? *pp0 : N_bc_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bc_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.SByte]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bi1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bi1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bi1_* pp0 = DataTransfer::GetPointer<N_bi1_>(apis, env, _sv0);
    N_bi1_ p0 = pp0 ? *pp0 : N_bi1_ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bi1_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.SByte], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bi1_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bi1_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bi1_* pp0 = DataTransfer::GetPointer<N_bi1_>(apis, env, _sv0);
    N_bi1_ p0 = pp0 ? *pp0 : N_bi1_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bi1_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.Int16]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bi2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bi2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bi2_* pp0 = DataTransfer::GetPointer<N_bi2_>(apis, env, _sv0);
    N_bi2_ p0 = pp0 ? *pp0 : N_bi2_ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bi2_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.Int16], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bi2_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bi2_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bi2_* pp0 = DataTransfer::GetPointer<N_bi2_>(apis, env, _sv0);
    N_bi2_ p0 = pp0 ? *pp0 : N_bi2_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bi2_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.Int32]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bi4_* pp0 = DataTransfer::GetPointer<N_bi4_>(apis, env, _sv0);
    N_bi4_ p0 = pp0 ? *pp0 : N_bi4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bi4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.Int32], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bi4_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bi4_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bi4_* pp0 = DataTransfer::GetPointer<N_bi4_>(apis, env, _sv0);
    N_bi4_ p0 = pp0 ? *pp0 : N_bi4_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bi4_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.Int64]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bi8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bi8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bi8_* pp0 = DataTransfer::GetPointer<N_bi8_>(apis, env, _sv0);
    N_bi8_ p0 = pp0 ? *pp0 : N_bi8_ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bi8_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.Int64], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bi8_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bi8_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bi8_* pp0 = DataTransfer::GetPointer<N_bi8_>(apis, env, _sv0);
    N_bi8_ p0 = pp0 ? *pp0 : N_bi8_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bi8_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.Single]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_br4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_br4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_br4_* pp0 = DataTransfer::GetPointer<N_br4_>(apis, env, _sv0);
    N_br4_ p0 = pp0 ? *pp0 : N_br4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_br4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.Single], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_br4_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_br4_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_br4_* pp0 = DataTransfer::GetPointer<N_br4_>(apis, env, _sv0);
    N_br4_ p0 = pp0 ? *pp0 : N_br4_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_br4_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.Double]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_br8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_br8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_br8_* pp0 = DataTransfer::GetPointer<N_br8_>(apis, env, _sv0);
    N_br8_ p0 = pp0 ? *pp0 : N_br8_ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_br8_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.Double], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_br8_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_br8_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_br8_* pp0 = DataTransfer::GetPointer<N_br8_>(apis, env, _sv0);
    N_br8_ p0 = pp0 ? *pp0 : N_br8_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_br8_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.Byte]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bu1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bu1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bu1_* pp0 = DataTransfer::GetPointer<N_bu1_>(apis, env, _sv0);
    N_bu1_ p0 = pp0 ? *pp0 : N_bu1_ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bu1_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.Byte], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bu1_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bu1_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bu1_* pp0 = DataTransfer::GetPointer<N_bu1_>(apis, env, _sv0);
    N_bu1_ p0 = pp0 ? *pp0 : N_bu1_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bu1_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.UInt16]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bu2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bu2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bu2_* pp0 = DataTransfer::GetPointer<N_bu2_>(apis, env, _sv0);
    N_bu2_ p0 = pp0 ? *pp0 : N_bu2_ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bu2_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.UInt16], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bu2_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bu2_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bu2_* pp0 = DataTransfer::GetPointer<N_bu2_>(apis, env, _sv0);
    N_bu2_ p0 = pp0 ? *pp0 : N_bu2_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bu2_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.UInt32]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bu4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bu4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bu4_* pp0 = DataTransfer::GetPointer<N_bu4_>(apis, env, _sv0);
    N_bu4_ p0 = pp0 ? *pp0 : N_bu4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bu4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.UInt32], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bu4_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bu4_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bu4_* pp0 = DataTransfer::GetPointer<N_bu4_>(apis, env, _sv0);
    N_bu4_ p0 = pp0 ? *pp0 : N_bu4_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bu4_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.Nullable`1[System.UInt64]) declare in System.Text.Json.Nodes.JsonNode
bool w_oN_bu8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bu8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bu8_* pp0 = DataTransfer::GetPointer<N_bu8_>(apis, env, _sv0);
    N_bu8_ p0 = pp0 ? *pp0 : N_bu8_ {};

    typedef Il2CppObject* (*FuncToCall)(struct N_bu8_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Nullable`1[System.UInt64], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oN_bu8_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oN_bu8_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    N_bu8_* pp0 = DataTransfer::GetPointer<N_bu8_>(apis, env, _sv0);
    N_bu8_ p0 = pp0 ? *pp0 : N_bu8_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct N_bu8_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Runtime.Remoting.Metadata.SoapAttribute GetCachedSoapAttribute(System.Object) declare in System.Runtime.Remoting.InternalRemotingServices
bool w_oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[DG.Tweening.Tween] TweensById(System.Object, Boolean, System.Collections.Generic.List`1[DG.Tweening.Tween]) declare in DG.Tweening.DOTween
bool w_oODbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oODbDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Delegate Remove(System.Object, System.Guid, Int32, System.Delegate) declare in System.Runtime.InteropServices.ComEventsHelper
bool w_oOS_i4i2i2u1u1u1u1u1u1u1u1_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oOS_i4i2i2u1u1u1u1u1u1u1u1_i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.ComponentModel.TypeDescriptionProvider AddAttributes(System.Object, System.Attribute[]) declare in System.ComponentModel.TypeDescriptor
bool w_oOVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oOVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.ComponentModel.AttributeCollection GetAttributes(System.Object, Boolean) declare in System.ComponentModel.TypeDescriptor
bool w_oOb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oOb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.ArrayList Repeat(System.Object, Int32) declare in System.Collections.ArrayList
bool w_oOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oOi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Object[] GetObjectData(System.Object, System.Reflection.MemberInfo[]) declare in System.Runtime.Serialization.FormatterServices
bool w_oOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Net.Http.Json.JsonContent Create(System.Object, System.Text.Json.Serialization.Metadata.JsonTypeInfo, System.Net.Http.Headers.MediaTypeHeaderValue) declare in System.Net.Http.Json.JsonContent
bool w_oOoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oOoDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Net.Http.Json.JsonContent Create(System.Object, System.Type, System.Net.Http.Headers.MediaTypeHeaderValue, System.Text.Json.JsonSerializerOptions) declare in System.Net.Http.Json.JsonContent
bool w_oOoDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oOoDoDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.ComponentModel.EventDescriptorCollection GetEvents(System.Object, System.Attribute[], Boolean) declare in System.ComponentModel.TypeDescriptor
bool w_oOob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oOob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.JsonDocument SerializeToDocument(System.Object, System.Type, System.Text.Json.Serialization.JsonSerializerContext) declare in System.Text.Json.JsonSerializer
bool w_oOoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oOoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Microsoft.SqlServer.Server.SqlMetaData InferFromValue(System.Object, System.String) declare in Microsoft.SqlServer.Server.SqlMetaData
bool w_oOs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oOs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Reflection.MethodInfo GetValidMethodInfo(System.Object, System.String, System.Type[]) declare in UnityEngine.Events.UnityEventBase
bool w_oOso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oOso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.JsonDocument ParseValue(System.Text.Json.Utf8JsonReader ByRef) declare in System.Text.Json.JsonDocument
bool w_oPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0 = DataTransfer::GetPointer<S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__));
        p0 = &up0;
    }
        

    typedef Il2CppObject* (*FuncToCall)(struct S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode Parse(System.Text.Json.Utf8JsonReader ByRef, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonNode
bool w_oPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0 = DataTransfer::GetPointer<S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__));
        p0 = &up0;
    }
        
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.RTHandle Alloc(UnityEngine.RenderTextureDescriptor ByRef, UnityEngine.FilterMode, UnityEngine.TextureWrapMode, Boolean, Int32, Single, System.String) declare in UnityEngine.Rendering.RTHandles
bool w_oPS_i4i4i4i4i4i4i4i4i4i4i4i4i4_Di4Di4DbDi4Dr4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oPS_i4i4i4i4i4i4i4i4i4i4i4i4i4_Di4Di4DbDi4Dr4Ds");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* p0 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4i4i4i4i4i4i4i4i4i4i4i4_));
        p0 = &up0;
    }
        
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal string  with default
    Il2CppString* p6 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* p0, int32_t p1, int32_t p2, bool p3, int32_t p4, float p5, Il2CppString* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.AsyncOperation MoveMainWindowTo(UnityEngine.DisplayInfo ByRef, UnityEngine.Vector2Int) declare in UnityEngine.Screen
bool w_oPS_u8i4i4S_u4u4_S_i4i4i4i4_s_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oPS_u8i4i4S_u4u4_S_i4i4i4i4_s_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u8i4i4S_u4u4_S_i4i4i4i4_s_* p0 = DataTransfer::GetPointer<S_u8i4i4S_u4u4_S_i4i4i4i4_s_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8i4i4S_u4u4_S_i4i4i4i4_s_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u8i4i4S_u4u4_S_i4i4i4i4_s_));
        p0 = &up0;
    }
        
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_u8i4i4S_u4u4_S_i4i4i4i4_s_* p0, struct S_i4i4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Cysharp.Threading.Tasks.AutoResetUniTaskCompletionSource CreateCompleted(Int16 ByRef) declare in Cysharp.Threading.Tasks.AutoResetUniTaskCompletionSource
bool w_oPi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oPi2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    int16_t up0 = converter::Converter<std::reference_wrapper<int16_t>>::toCpp(apis, env, _sv0);
    int16_t* p0 = &up0;

    typedef Il2CppObject* (*FuncToCall)(int16_t* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int16_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Texture2D GetTypeIcon(System.Type ByRef) declare in UnityEditor.Search.SearchUtils
bool w_oPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oPo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject** p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Search.ISearchQuery CreateQuery(System.String ByRef, UnityEditor.Search.SearchContext, UnityEditor.Search.SearchTable) declare in UnityEditor.Search.SearchUtils
bool w_oPsoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oPsoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString** p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Overlapped Unpack(System.Threading.NativeOverlapped*) declare in System.Threading.Overlapped
bool w_oPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oPv");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Client.Commands.FileLocalInfo ReadFileLocalInfo(Byte*, Int32 ByRef) declare in Codice.CM.WorkspaceServer.DataStore.WkTree.ReadWorkspaceTree
bool w_oPvPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oPvPi4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef Il2CppObject* (*FuncToCall)(void* p0, int32_t* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// JetBrains.Serialization.UnsafeReader CreateReader(Byte*, Int32) declare in JetBrains.Serialization.UnsafeReader
bool w_oPvi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oPvi4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[Codice.CM.Common.SEID] ReadSeids(Byte*, Byte[], Int32 ByRef, Int32 ByRef, System.IO.FileStream, Int32) declare in Codice.CM.WorkspaceServer.DataStore.WkTree.ReadWorkspaceTree
bool w_oPvoPi4Pi4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oPvoPi4Pi4oi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(void* p0, Il2CppObject* p1, int32_t* p2, int32_t* p3, Il2CppObject* p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.IO.Pipelines.PipeReader Create(System.Buffers.ReadOnlySequence`1[System.Byte]) declare in System.IO.Pipelines.PipeReader
bool w_oS_OOi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_OOi4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_OOi4i4_* pp0 = DataTransfer::GetPointer<S_OOi4i4_>(apis, env, _sv0);
    S_OOi4i4_ p0 = pp0 ? *pp0 : S_OOi4i4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_OOi4i4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.JsonDocument Parse(System.Buffers.ReadOnlySequence`1[System.Byte], System.Text.Json.JsonDocumentOptions) declare in System.Text.Json.JsonDocument
bool w_oS_OOi4i4_DS_i4u1b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_OOi4i4_DS_i4u1b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_OOi4i4_* pp0 = DataTransfer::GetPointer<S_OOi4i4_>(apis, env, _sv0);
    S_OOi4i4_ p0 = pp0 ? *pp0 : S_OOi4i4_ {};
    // JSValToCSVal valuetype  with default
    S_i4u1b_ p1 = OptionalParameter<S_i4u1b_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_OOi4i4_ p0, struct S_i4u1b_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.String[] op_Implicit(Microsoft.Extensions.Primitives.StringValues) declare in Microsoft.Extensions.Primitives.StringValues
bool w_oS_O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_O_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_O_* pp0 = DataTransfer::GetPointer<S_O_>(apis, env, _sv0);
    S_O_ p0 = pp0 ? *pp0 : S_O_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_O_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.JsonDocument Parse(System.ReadOnlyMemory`1[System.Byte], System.Text.Json.JsonDocumentOptions) declare in System.Text.Json.JsonDocument
bool w_oS_Oi4i4_DS_i4u1b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_Oi4i4_DS_i4u1b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};
    // JSValToCSVal valuetype  with default
    S_i4u1b_ p1 = OptionalParameter<S_i4u1b_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_Oi4i4_ p0, struct S_i4u1b_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Experimental.Rendering.XRPass CreateDefault(UnityEngine.Experimental.Rendering.XRPassCreateInfo) declare in UnityEngine.Experimental.Rendering.XRPass
bool w_oS_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__>(apis, env, _sv0);
    S_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__ p0 = pp0 ? *pp0 : S_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_or4pi4i4bS_pi4S_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bS_i4i4i4pi4i4i4_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_bi4p__ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// JetBrains.Lifetimes.LifetimeDefinition Define(JetBrains.Lifetimes.OuterLifetime, System.String, System.Action`2[JetBrains.Lifetimes.LifetimeDefinition,JetBrains.Lifetimes.Lifetime]) declare in JetBrains.Lifetimes.OuterLifetime
bool w_oS_S_o__DsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_o__DsDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_o__* pp0 = DataTransfer::GetPointer<S_S_o__>(apis, env, _sv0);
    S_S_o__ p0 = pp0 ? *pp0 : S_S_o__ {};
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_S_o__ p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task UsingAsync(JetBrains.Lifetimes.OuterLifetime, System.Func`2[JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task]) declare in JetBrains.Lifetimes.Lifetime
bool w_oS_S_o__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_o__o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_o__* pp0 = DataTransfer::GetPointer<S_S_o__>(apis, env, _sv0);
    S_S_o__ p0 = pp0 ? *pp0 : S_S_o__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_o__ p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Security.Cryptography.ECDiffieHellman Create(System.Security.Cryptography.ECParameters) declare in System.Security.Cryptography.ECDiffieHellman
bool w_oS_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__* pp0 = DataTransfer::GetPointer<S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__>(apis, env, _sv0);
    S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ p0 = pp0 ? *pp0 : S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Version Parse(System.ReadOnlySpan`1[System.Char]) declare in System.Version
bool w_oS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_S_p_i4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode Parse(System.ReadOnlySpan`1[System.Byte], System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions], System.Text.Json.JsonDocumentOptions) declare in System.Text.Json.Nodes.JsonNode
bool w_oS_S_p_i4_DN_bS_b__DS_i4u1b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_p_i4_DN_bS_b__DS_i4u1b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal valuetype  with default
    S_i4u1b_ p2 = OptionalParameter<S_i4u1b_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_S_p_i4_ p0, struct N_bS_b__ p1, struct S_i4u1b_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Type GetTargetType(TypedReference) declare in System.TypedReference
bool w_oS_S_p_pp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_p_pp_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_pp_* pp0 = DataTransfer::GetPointer<S_S_p_pp_>(apis, env, _sv0);
    S_S_p_pp_ p0 = pp0 ? *pp0 : S_S_p_pp_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_S_p_pp_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Ray) declare in UnityEngine.Physics
bool w_oS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Ray, Single) declare in UnityEngine.Physics
bool w_oS_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Ray, Single, Int32) declare in UnityEngine.Physics
bool w_oS_S_r4r4r4_S_r4r4r4__r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_r4r4r4_S_r4r4r4__r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Ray, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_oS_S_r4r4r4_S_r4r4r4__r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_r4r4r4_S_r4r4r4__r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Ray, Single, Single) declare in UnityEngine.Physics
bool w_oS_S_r4r4r4_S_r4r4r4__r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_r4r4r4_S_r4r4r4__r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Ray, Single, Single, Int32) declare in UnityEngine.Physics
bool w_oS_S_r4r4r4_S_r4r4r4__r4r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_r4r4r4_S_r4r4r4__r4r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, float p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Ray, Single, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_oS_S_r4r4r4_S_r4r4r4__r4r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_r4r4r4_S_r4r4r4__r4r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, float p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.ComputeBuffer op_Implicit(UnityEngine.Experimental.Rendering.RenderGraphModule.ComputeBufferHandle) declare in UnityEngine.Experimental.Rendering.RenderGraphModule.ComputeBufferHandle
bool w_oS_S_u4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_u4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4i4__* pp0 = DataTransfer::GetPointer<S_S_u4i4__>(apis, env, _sv0);
    S_S_u4i4__ p0 = pp0 ? *pp0 : S_S_u4i4__ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_S_u4i4__ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Type GetTypeForObject(UnityEditor.Build.Content.ObjectIdentifier) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_oS_S_u4u4u4u4_i8i4s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_u4u4u4u4_i8i4s_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_i8i4s_* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(apis, env, _sv0);
    S_S_u4u4u4u4_i8i4s_ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_i8i4s_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_S_u4u4u4u4_i8i4s_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Build.Content.ObjectIdentifier[] GetPlayerDependenciesForObject(UnityEditor.Build.Content.ObjectIdentifier, UnityEditor.BuildTarget, UnityEditor.Build.Player.TypeDB) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_oS_S_u4u4u4u4_i8i4s_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_u4u4u4u4_i8i4s_i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_i8i4s_* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(apis, env, _sv0);
    S_S_u4u4u4u4_i8i4s_ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_i8i4s_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_u4u4u4u4_i8i4s_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Build.Content.ObjectIdentifier[] GetPlayerDependenciesForObject(UnityEditor.Build.Content.ObjectIdentifier, UnityEditor.BuildTarget, UnityEditor.Build.Player.TypeDB, UnityEditor.Build.Content.DependencyType) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_oS_S_u4u4u4u4_i8i4s_i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_u4u4u4u4_i8i4s_i4oi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_i8i4s_* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(apis, env, _sv0);
    S_S_u4u4u4u4_i8i4s_ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_i8i4s_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_S_u4u4u4u4_i8i4s_ p0, int32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(System.DateTimeOffset) declare in System.Text.Json.Nodes.JsonNode
bool w_oS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_u8_i2_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_S_u8_i2_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.DateTimeOffset, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oS_S_u8_i2_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_u8_i2_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_S_u8_i2_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Object GlobalObjectIdentifierToObjectSlow(UnityEditor.GlobalObjectId) declare in UnityEditor.GlobalObjectId
bool w_oS_S_u8u8_S_u4u4u4u4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_S_u8u8_S_u4u4u4u4_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8u8_S_u4u4u4u4_i4_* pp0 = DataTransfer::GetPointer<S_S_u8u8_S_u4u4u4u4_i4_>(apis, env, _sv0);
    S_S_u8u8_S_u4u4u4u4_i4_ p0 = pp0 ? *pp0 : S_S_u8u8_S_u4u4u4u4_i4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_S_u8u8_S_u4u4u4u4_i4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.AsyncOperation UnloadSceneAsync(UnityEngine.SceneManagement.Scene) declare in UnityEngine.SceneManagement.SceneManager
bool w_oS_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_i4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.AsyncOperation UnloadSceneAsync(UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.UnloadSceneOptions) declare in UnityEngine.SceneManagement.SceneManager
bool w_oS_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_i4_ p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject CreateGameObject(UnityEngine.SceneManagement.Scene, UnityEngine.HideFlags, System.String, System.Type[]) declare in UnityEditor.ObjectFactory
bool w_oS_i4_i4sVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4_i4sVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_i4_ p0, int32_t p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.VolumeProfile CreateVolumeProfile(UnityEngine.SceneManagement.Scene, System.String) declare in UnityEditor.Rendering.VolumeProfileFactory
bool w_oS_i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_i4_ p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Type GetTypeFromCLSID(System.Guid) declare in System.Type
bool w_oS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Guid, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oS_i4i2i2u1u1u1u1u1u1u1u1_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i2i2u1u1u1u1u1u1u1u1_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Type GetTypeFromCLSID(System.Guid, Boolean) declare in System.Type
bool w_oS_i4i2i2u1u1u1u1u1u1u1u1_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i2i2u1u1u1u1u1u1u1u1_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.Mount.MountPointId BuildForXlink(System.Guid, Codice.CM.Common.Mount.MountPointId) declare in Codice.CM.Common.Mount.MountPointId
bool w_oS_i4i2i2u1u1u1u1u1u1u1u1_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i2i2u1u1u1u1u1u1u1u1_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Transactions.Enlistment Reenlist(System.Guid, Byte[], System.Transactions.IEnlistmentNotification) declare in System.Transactions.TransactionManager
bool w_oS_i4i2i2u1u1u1u1u1u1u1u1_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i2i2u1u1u1u1u1u1u1u1_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Type GetTypeFromCLSID(System.Guid, System.String) declare in System.Type
bool w_oS_i4i2i2u1u1u1u1u1u1u1u1_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i2i2u1u1u1u1u1u1u1u1_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Type GetTypeFromCLSID(System.Guid, System.String, Boolean) declare in System.Type
bool w_oS_i4i2i2u1u1u1u1u1u1u1u1_sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i2i2u1u1u1u1u1u1u1u1_sb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppString* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.Serialization.ExternalDataInfo Create(System.Guid, System.String, System.String, Codice.CM.Common.RepId, Int64) declare in Codice.CM.Common.Serialization.ExternalDataInfo
bool w_oS_i4i2i2u1u1u1u1u1u1u1u1_ssS_u4u4_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i2i2u1u1u1u1u1u1u1u1_ssS_u4u4_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_u4u4_* pp3 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv3);
    S_u4u4_ p3 = pp3 ? *pp3 : S_u4u4_ {};
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, Il2CppString* p1, Il2CppString* p2, struct S_u4u4_ p3, int64_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.IEnumerable`1[System.Single] GetSupportedFrameRatesForResolution(UnityEngine.Resolution) declare in UnityEngine.Windows.WebCam.VideoCapture
bool w_oS_i4i4S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i4S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4S_u4u4__* pp0 = DataTransfer::GetPointer<S_i4i4S_u4u4__>(apis, env, _sv0);
    S_i4i4S_u4u4__ p0 = pp0 ? *pp0 : S_i4i4S_u4u4__ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i4S_u4u4__ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(UnityEngine.RenderTextureDescriptor) declare in UnityEngine.RenderTexture
bool w_oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Int32[] GetBits(System.Decimal) declare in System.Decimal
bool w_oS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.Decimal, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oS_i4i4i4i4u8_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i4i4i4u8_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i4i4i4u8_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.Schema.XmlAtomicValue DecimalToAtomicValue(System.Decimal, Int32, System.Xml.Xsl.Runtime.XmlQueryRuntime) declare in System.Xml.Xsl.Runtime.XmlILStorageConverter
bool w_oS_i4i4i4i4u8_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i4i4i4u8_i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i4i4i4u8_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.RTHandle Alloc(UnityEngine.Rendering.RenderTargetIdentifier) declare in UnityEngine.Rendering.RTHandles
bool w_oS_i4i4i4pi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i4i4pi4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i4i4pi4i4i4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.RTHandle Alloc(UnityEngine.Rendering.RenderTargetIdentifier, System.String) declare in UnityEngine.Rendering.RTHandles
bool w_oS_i4i4i4pi4i4i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i4i4pi4i4i4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_i4i4i4pi4i4i4_ p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Presets.DefaultPreset[] GetDefaultPresetsForType(UnityEditor.Presets.PresetType) declare in UnityEditor.Presets.Preset
bool w_oS_i4os_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4os_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4os_* pp0 = DataTransfer::GetPointer<S_i4os_>(apis, env, _sv0);
    S_i4os_ p0 = pp0 ? *pp0 : S_i4os_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_i4os_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.AI.NavMeshData BuildNavMeshData(UnityEngine.AI.NavMeshBuildSettings, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildSource], UnityEngine.Bounds, UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.AI.NavMeshBuilder
bool w_oS_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__oS_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__oS_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__* pp0 = DataTransfer::GetPointer<S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__>(apis, env, _sv0);
    S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ p0 = pp0 ? *pp0 : S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv2);
    S_S_r4r4r4_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ p0, Il2CppObject* p1, struct S_S_r4r4r4_S_r4r4r4__ p2, struct S_r4r4r4_ p3, struct S_r4r4r4r4_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task Delay(System.TimeSpan) declare in System.Threading.Tasks.Task
bool w_oS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_i8_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[Cysharp.Threading.Tasks.AsyncUnit] Timer(System.TimeSpan, Cysharp.Threading.Tasks.PlayerLoopTiming, Boolean, Boolean) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_oS_i8_Di4DbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i8_Di4DbDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_i8_ p0, int32_t p1, bool p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[Cysharp.Threading.Tasks.AsyncUnit] Timer(System.TimeSpan, System.TimeSpan, Cysharp.Threading.Tasks.PlayerLoopTiming, Boolean, Boolean) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_oS_i8_S_i8_Di4DbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i8_S_i8_Di4DbDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_i8_ p0, struct S_i8_ p1, int32_t p2, bool p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task Delay(System.TimeSpan, System.Threading.CancellationToken) declare in System.Threading.Tasks.Task
bool w_oS_i8_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i8_S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_i8_ p0, struct S_o_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Cysharp.Threading.Tasks.PlayerLoopTimer Create(System.TimeSpan, Boolean, Cysharp.Threading.Tasks.DelayType, Cysharp.Threading.Tasks.PlayerLoopTiming, System.Threading.CancellationToken, System.Action`1[System.Object], System.Object) declare in Cysharp.Threading.Tasks.PlayerLoopTimer
bool w_oS_i8_bi4i4S_o_oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i8_bi4i4S_o_oO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_o_* pp4 = DataTransfer::GetPointer<S_o_>(apis, env, _sv4);
    S_o_ p4 = pp4 ? *pp4 : S_o_ {};
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(struct S_i8_ p0, bool p1, int32_t p2, int32_t p3, struct S_o_ p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.Schema.XmlAtomicValue TimeSpanToAtomicValue(System.TimeSpan, Int32, System.Xml.Xsl.Runtime.XmlQueryRuntime) declare in System.Xml.Xsl.Runtime.XmlILStorageConverter
bool w_oS_i8_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i8_i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_i8_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task FromCanceled(System.Threading.CancellationToken) declare in System.Threading.Tasks.Task
bool w_oS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_o_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// JetBrains.Lifetimes.LifetimeDefinition Define(JetBrains.Lifetimes.Lifetime, System.String, System.Action`1[JetBrains.Lifetimes.LifetimeDefinition]) declare in JetBrains.Lifetimes.Lifetime
bool w_oS_o_DsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_o_DsDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_o_ p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Cysharp.Threading.Tasks.AutoResetUniTaskCompletionSource CreateFromCanceled(System.Threading.CancellationToken, Int16 ByRef) declare in Cysharp.Threading.Tasks.AutoResetUniTaskCompletionSource
bool w_oS_o_Pi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_o_Pi2");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal P primitive
    int16_t up1 = converter::Converter<std::reference_wrapper<int16_t>>::toCpp(apis, env, _sv1);
    int16_t* p1 = &up1;

    typedef Il2CppObject* (*FuncToCall)(struct S_o_ p0, int16_t* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int16_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.CancellationTokenSource CreateLinkedTokenSource(System.Threading.CancellationToken, System.Threading.CancellationToken) declare in System.Threading.CancellationTokenSource
bool w_oS_o_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_o_S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_o_ p0, struct S_o_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// JetBrains.Lifetimes.LifetimeDefinition Define(JetBrains.Lifetimes.Lifetime, System.Action`1[JetBrains.Lifetimes.Lifetime]) declare in JetBrains.Lifetimes.Lifetime
bool w_oS_o_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_o_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_o_ p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// JetBrains.Lifetimes.LifetimeDefinition Define(JetBrains.Lifetimes.Lifetime, System.String, System.Action`1[JetBrains.Lifetimes.Lifetime]) declare in JetBrains.Lifetimes.Lifetime
bool w_oS_o_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_o_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_o_ p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonArray Create(System.Text.Json.JsonElement, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonArray
bool w_oS_oi4_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_oi4_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oi4_* pp0 = DataTransfer::GetPointer<S_oi4_>(apis, env, _sv0);
    S_oi4_ p0 = pp0 ? *pp0 : S_oi4_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_oi4_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Microsoft.Extensions.AI.ChatResponseFormatJson ForJsonSchema(System.Text.Json.JsonElement, System.String, System.String) declare in Microsoft.Extensions.AI.ChatResponseFormat
bool w_oS_oi4_DsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_oi4_DsDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_oi4_* pp0 = DataTransfer::GetPointer<S_oi4_>(apis, env, _sv0);
    S_oi4_ p0 = pp0 ? *pp0 : S_oi4_ {};
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_oi4_ p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Security.Cryptography.ECDiffieHellman Create(System.Security.Cryptography.ECCurve) declare in System.Security.Cryptography.ECDiffieHellman
bool w_oS_ooS_oo_oooi4N_bS_s__ooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_ooS_oo_oooi4N_bS_s__ooo_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_ooS_oo_oooi4N_bS_s__ooo_* pp0 = DataTransfer::GetPointer<S_ooS_oo_oooi4N_bS_s__ooo_>(apis, env, _sv0);
    S_ooS_oo_oooi4N_bS_s__ooo_ p0 = pp0 ? *pp0 : S_ooS_oo_oooi4N_bS_s__ooo_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_ooS_oo_oooi4N_bS_s__ooo_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// JetBrains.Rd.RdContextBase Read(JetBrains.Rd.SerializationCtx, JetBrains.Serialization.UnsafeReader) declare in JetBrains.Rd.RdContextBase
bool w_oS_oo_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_oo_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_oo_* pp0 = DataTransfer::GetPointer<S_oo_>(apis, env, _sv0);
    S_oo_ p0 = pp0 ? *pp0 : S_oo_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_oo_ p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject CreatePanel(Resources) declare in UnityEngine.UI.DefaultControls
bool w_oS_ooooooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_ooooooo_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_ooooooo_* pp0 = DataTransfer::GetPointer<S_ooooooo_>(apis, env, _sv0);
    S_ooooooo_ p0 = pp0 ? *pp0 : S_ooooooo_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_ooooooo_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Security.Cryptography.DSA Create(System.Security.Cryptography.DSAParameters) declare in System.Security.Cryptography.DSA
bool w_oS_oooooooi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_oooooooi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oooooooi4_* pp0 = DataTransfer::GetPointer<S_oooooooi4_>(apis, env, _sv0);
    S_oooooooi4_ p0 = pp0 ? *pp0 : S_oooooooi4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_oooooooi4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Security.Cryptography.RSA Create(System.Security.Cryptography.RSAParameters) declare in System.Security.Cryptography.RSA
bool w_oS_oooooooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_oooooooo_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oooooooo_* pp0 = DataTransfer::GetPointer<S_oooooooo_>(apis, env, _sv0);
    S_oooooooo_ p0 = pp0 ? *pp0 : S_oooooooo_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_oooooooo_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Build.Reporting.BuildReport BuildPlayer(UnityEditor.BuildPlayerOptions) declare in UnityEditor.BuildPipeline
bool w_oS_ossi4i4i4i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_ossi4i4i4i4o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_ossi4i4i4i4o_* pp0 = DataTransfer::GetPointer<S_ossi4i4i4i4o_>(apis, env, _sv0);
    S_ossi4i4i4i4o_ p0 = pp0 ? *pp0 : S_ossi4i4i4i4o_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_ossi4i4i4i4o_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Type GetTypeFromHandle(System.RuntimeTypeHandle) declare in System.Type
bool w_oS_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_p_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Reflection.FieldInfo GetFieldFromHandle(System.RuntimeFieldHandle, System.RuntimeTypeHandle) declare in System.Reflection.FieldInfo
bool w_oS_p_S_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_p_S_p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};
    // JSValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(apis, env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_p_ p0, struct S_p_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider2D OverlapPoint(UnityEngine.Vector2) declare in UnityEngine.Physics2D
bool w_oS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.UIElements.NavigationMoveEvent GetPooled(UnityEngine.Vector2, UnityEngine.EventModifiers) declare in UnityEngine.UIElements.NavigationMoveEvent
bool w_oS_r4r4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.RTHandle Alloc(UnityEngine.Vector2, Int32, UnityEngine.Rendering.DepthBits, UnityEngine.Experimental.Rendering.GraphicsFormat, UnityEngine.FilterMode, UnityEngine.TextureWrapMode, UnityEngine.Rendering.TextureDimension, Boolean, Boolean, Boolean, Boolean, Int32, Single, UnityEngine.Rendering.MSAASamples, Boolean, Boolean, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage, System.String) declare in UnityEngine.Rendering.RTHandles
bool w_oS_r4r4_Di4Di4Di4Di4Di4Di4DbDbDbDbDi4Dr4Di4DbDbDi4Di4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_Di4Di4Di4Di4Di4Di4DbDbDbDbDi4Dr4Di4DbDbDi4Di4Ds");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp18 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);
    pesapi_value _sv16 = apis->get_arg(info, 16);
    pesapi_value _sv17 = apis->get_arg(info, 17);
    pesapi_value _sv18 = apis->get_arg(info, 18);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (js_args_len > 8 && !converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (js_args_len > 9 && !converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (js_args_len > 10 && !converter::Converter<bool>::accept(apis, env, _sv10)) return false;
        if (js_args_len > 11 && !converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
        if (js_args_len > 12 && !converter::Converter<float>::accept(apis, env, _sv12)) return false;
        if (js_args_len > 13 && !converter::Converter<int32_t>::accept(apis, env, _sv13)) return false;
        if (js_args_len > 14 && !converter::Converter<bool>::accept(apis, env, _sv14)) return false;
        if (js_args_len > 15 && !converter::Converter<bool>::accept(apis, env, _sv15)) return false;
        if (js_args_len > 16 && !converter::Converter<int32_t>::accept(apis, env, _sv16)) return false;
        if (js_args_len > 17 && !converter::Converter<int32_t>::accept(apis, env, _sv17)) return false;
        if (js_args_len > 18 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv18)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    bool p7 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                
    // JSValToCSVal primitive with default
    bool p8 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 8);
                
    // JSValToCSVal primitive with default
    bool p9 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 9);
                
    // JSValToCSVal primitive with default
    bool p10 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 10);
                
    // JSValToCSVal primitive with default
    int32_t p11 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 11);
                
    // JSValToCSVal primitive with default
    float p12 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 12);
                
    // JSValToCSVal primitive with default
    int32_t p13 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 13);
                
    // JSValToCSVal primitive with default
    bool p14 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 14);
                
    // JSValToCSVal primitive with default
    bool p15 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 15);
                
    // JSValToCSVal primitive with default
    int32_t p16 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 16);
                
    // JSValToCSVal primitive with default
    int32_t p17 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 17);
                
    // JSValToCSVal string  with default
    Il2CppString* p18 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 18);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, bool p7, bool p8, bool p9, bool p10, int32_t p11, float p12, int32_t p13, bool p14, bool p15, int32_t p16, int32_t p17, Il2CppString* p18, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.RTHandle Alloc(UnityEngine.Vector2, UnityEngine.RenderTextureDescriptor ByRef, UnityEngine.FilterMode, UnityEngine.TextureWrapMode, Boolean, Int32, Single, System.String) declare in UnityEngine.Rendering.RTHandles
bool w_oS_r4r4_PS_i4i4i4i4i4i4i4i4i4i4i4i4i4_Di4Di4DbDi4Dr4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_PS_i4i4i4i4i4i4i4i4i4i4i4i4i4_Di4Di4DbDi4Dr4Ds");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal Pstruct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* p1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i4i4i4i4i4i4i4i4i4i4i4i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    float p6 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal string  with default
    Il2CppString* p7 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 7);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* p1, int32_t p2, int32_t p3, bool p4, int32_t p5, float p6, Il2CppString* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject PickGameObject(UnityEngine.Vector2, Int32 ByRef) declare in UnityEditor.HandleUtility
bool w_oS_r4r4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_Pi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, int32_t* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] LinecastAll(UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.TerrainUtils.TerrainMap CreateFromPlacement(UnityEngine.Vector2, UnityEngine.Vector2, System.Predicate`1[UnityEngine.Terrain], Boolean) declare in UnityEngine.TerrainUtils.TerrainMap
bool w_oS_r4r4_S_r4r4_DoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_DoDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] LinecastAll(UnityEngine.Vector2, UnityEngine.Vector2, Int32) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] LinecastAll(UnityEngine.Vector2, UnityEngine.Vector2, Int32, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] CapsuleCastAll(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_i4r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_i4r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] CapsuleCastAll(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_i4r4S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_i4r4S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] CapsuleCastAll(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, Int32) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_i4r4S_r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_i4r4S_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, float p5, int32_t p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] CapsuleCastAll(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, Int32, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_i4r4S_r4r4_r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_i4r4S_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, float p5, int32_t p6, float p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] CapsuleCastAll(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_i4r4S_r4r4_r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_i4r4S_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, struct S_r4r4_ p4, float p5, int32_t p6, float p7, float p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider2D OverlapCapsule(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, Int32) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_i4r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_i4r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider2D OverlapCapsule(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, Int32, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_i4r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_i4r4i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, int32_t p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider2D OverlapCapsule(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_i4r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_i4r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, int32_t p4, float p5, float p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] LinecastAll(UnityEngine.Vector2, UnityEngine.Vector2, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, int32_t p2, float p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] RaycastAll(UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] BoxCastAll(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] BoxCastAll(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_r4S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_r4S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] BoxCastAll(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_r4S_r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_r4S_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] BoxCastAll(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_r4S_r4r4_r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_r4S_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, int32_t p5, float p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] BoxCastAll(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_r4S_r4r4_r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_r4S_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, int32_t p5, float p6, float p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] RaycastAll(UnityEngine.Vector2, UnityEngine.Vector2, Single, Int32) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] RaycastAll(UnityEngine.Vector2, UnityEngine.Vector2, Single, Int32, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, int32_t p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] RaycastAll(UnityEngine.Vector2, UnityEngine.Vector2, Single, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_S_r4r4_r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, int32_t p3, float p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.Tweener Vector2(UnityEngine.Vector2, UnityEngine.Vector2, Single, DG.Tweening.TweenCallback`1[UnityEngine.Vector2]) declare in DG.Tweening.DOVirtual
bool w_oS_r4r4_S_r4r4_r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_S_r4r4_r4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, float p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject PickGameObject(UnityEngine.Vector2, Boolean) declare in UnityEditor.HandleUtility
bool w_oS_r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject PickGameObject(UnityEngine.Vector2, Boolean, UnityEngine.GameObject[]) declare in UnityEditor.HandleUtility
bool w_oS_r4r4_bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_bo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, bool p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject PickGameObject(UnityEngine.Vector2, Boolean, UnityEngine.GameObject[], UnityEngine.GameObject[]) declare in UnityEditor.HandleUtility
bool w_oS_r4r4_boo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_boo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, bool p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject PickGameObject(UnityEngine.Vector2, Boolean, UnityEngine.GameObject[], UnityEngine.GameObject[], Int32 ByRef) declare in UnityEditor.HandleUtility
bool w_oS_r4r4_booPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_booPi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P primitive
    int32_t up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, bool p1, Il2CppObject* p2, Il2CppObject* p3, int32_t* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv4, converter::Converter<int32_t>::toScript(apis, env, *p4));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider2D OverlapPoint(UnityEngine.Vector2, Int32) declare in UnityEngine.Physics2D
bool w_oS_r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Color[] ReadScreenPixel(UnityEngine.Vector2, Int32, Int32) declare in UnityEditorInternal.InternalEditorUtility
bool w_oS_r4r4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, int32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider2D OverlapPoint(UnityEngine.Vector2, Int32, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, int32_t p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider2D OverlapPoint(UnityEngine.Vector2, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, int32_t p1, float p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject PickGameObject(UnityEngine.Vector2, UnityEngine.GameObject[], Int32 ByRef) declare in UnityEditor.HandleUtility
bool w_oS_r4r4_oPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_oPi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, Il2CppObject* p1, int32_t* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject PickGameObject(UnityEngine.Vector2, UnityEngine.GameObject[], UnityEngine.GameObject[], Int32 ByRef) declare in UnityEditor.HandleUtility
bool w_oS_r4r4_ooPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_ooPi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, int32_t* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider2D OverlapCircle(UnityEngine.Vector2, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, float p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] CircleCastAll(UnityEngine.Vector2, Single, UnityEngine.Vector2) declare in UnityEngine.Physics2D
bool w_oS_r4r4_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] CircleCastAll(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_r4S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_r4S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] CircleCastAll(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32) declare in UnityEngine.Physics2D
bool w_oS_r4r4_r4S_r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_r4S_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, float p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] CircleCastAll(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_r4S_r4r4_r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_r4S_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, float p3, int32_t p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit2D[] CircleCastAll(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_r4S_r4r4_r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_r4S_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, float p1, struct S_r4r4_ p2, float p3, int32_t p4, float p5, float p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider2D OverlapCircle(UnityEngine.Vector2, Single, Int32) declare in UnityEngine.Physics2D
bool w_oS_r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, float p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider2D OverlapCircle(UnityEngine.Vector2, Single, Int32, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_r4i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, float p1, int32_t p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider2D OverlapCircle(UnityEngine.Vector2, Single, Int32, Single, Single) declare in UnityEngine.Physics2D
bool w_oS_r4r4_r4i4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p0, float p1, int32_t p2, float p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] BoxCastAll(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Vector3[] MakeBezierPoints(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Int32) declare in UnityEditor.Handles
bool w_oS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] BoxCastAll(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] BoxCastAll(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] BoxCastAll(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Int32) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] BoxCastAll(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, int32_t p5, int32_t p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider[] OverlapBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider[] OverlapBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Int32) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_S_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_S_r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider[] OverlapBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_S_r4r4r4r4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_S_r4r4r4r4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] CapsuleCastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_r4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] CapsuleCastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] CapsuleCastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, float p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] CapsuleCastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, float p4, int32_t p5, int32_t p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_oS_r4r4r4_S_r4r4r4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.Tweener Vector3(UnityEngine.Vector3, UnityEngine.Vector3, Single, DG.Tweening.TweenCallback`1[UnityEngine.Vector3]) declare in DG.Tweening.DOVirtual
bool w_oS_r4r4r4_S_r4r4r4_r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_S_r4r4r4_r4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider[] OverlapSphere(UnityEngine.Vector3, Single) declare in UnityEngine.Physics
bool w_oS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, float p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Vector3, Single, UnityEngine.Vector3) declare in UnityEngine.Physics
bool w_oS_r4r4r4_r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_r4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, float p1, struct S_r4r4r4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Vector3, Single, UnityEngine.Vector3, Single) declare in UnityEngine.Physics
bool w_oS_r4r4r4_r4S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_r4S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, float p1, struct S_r4r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32) declare in UnityEngine.Physics
bool w_oS_r4r4r4_r4S_r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_r4S_r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, float p1, struct S_r4r4r4_ p2, float p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_oS_r4r4r4_r4S_r4r4r4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_r4S_r4r4r4_r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, float p1, struct S_r4r4r4_ p2, float p3, int32_t p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider[] OverlapSphere(UnityEngine.Vector3, Single, Int32) declare in UnityEngine.Physics
bool w_oS_r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, float p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Collider[] OverlapSphere(UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_oS_r4r4r4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4_r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4_ p0, float p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject[] PickRectObjects(UnityEngine.Rect) declare in UnityEditor.HandleUtility
bool w_oS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.UIElements.GeometryChangedEvent GetPooled(UnityEngine.Rect, UnityEngine.Rect) declare in UnityEngine.UIElements.GeometryChangedEvent
bool w_oS_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.Tweener Color(UnityEngine.Color, UnityEngine.Color, Single, DG.Tweening.TweenCallback`1[UnityEngine.Color]) declare in DG.Tweening.DOVirtual
bool w_oS_r4r4r4r4_S_r4r4r4r4_r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_S_r4r4r4r4_r4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, float p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject[] PickRectObjects(UnityEngine.Rect, Boolean) declare in UnityEditor.HandleUtility
bool w_oS_r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumFlagsField(UnityEngine.Rect, System.Enum) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.AnimationCurve CurveField(UnityEngine.Rect, UnityEngine.AnimationCurve, UnityEngine.Color, UnityEngine.Rect) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_oS_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_oS_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumFlagsField(UnityEngine.Rect, System.Enum, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.AnimationCurve CurveField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.AnimationCurve, UnityEngine.Color, UnityEngine.Rect) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_ooS_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_ooS_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4r4_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Object ObjectField(UnityEngine.Rect, UnityEngine.Object, System.Type, Boolean) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_oob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_oob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumFlagsField(UnityEngine.Rect, UnityEngine.GUIContent, System.Enum, Boolean, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_oobDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_oobDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Gradient GradientField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Gradient, Boolean, UnityEngine.ColorSpace) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_oobi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_oobi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumFlagsField(UnityEngine.Rect, UnityEngine.GUIContent, System.Enum, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumPopup(UnityEngine.Rect, UnityEngine.GUIContent, System.Enum, System.Func`2[System.Enum,System.Boolean], Boolean, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_oooDbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_oooDbDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 5, TIp5);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Object ObjectField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Object, System.Type, Boolean) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_ooob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_ooob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Object ObjectField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Object, System.Type, UnityEngine.Object) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_oooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Object DoObjectField(UnityEngine.Rect, UnityEngine.Object, System.Type, UnityEngine.GUIContent, UnityEditor.Search.SearchContext, UnityEngine.Search.SearchViewFlags) declare in UnityEditor.Search.ObjectField
bool w_oS_r4r4r4r4_ooooDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_ooooDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[UnityEngine.Rect] GetFlowLayoutedRects(UnityEngine.Rect, UnityEngine.GUIStyle, Single, Single, System.Collections.Generic.List`1[System.String]) declare in UnityEditor.EditorGUIUtility
bool w_oS_r4r4r4r4_or4r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_or4r4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, float p2, float p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Texture2D CreateColoredTexture2D(UnityEngine.Color, System.String) declare in UnityEditor.Rendering.CoreEditorUtils
bool w_oS_r4r4r4r4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumFlagsField(UnityEngine.Rect, System.String, System.Enum) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.AnimationCurve CurveField(UnityEngine.Rect, System.String, UnityEngine.AnimationCurve, UnityEngine.Color, UnityEngine.Rect) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_soS_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_soS_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4r4_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumFlagsField(UnityEngine.Rect, System.String, System.Enum, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_soo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_soo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Object ObjectField(UnityEngine.Rect, System.String, UnityEngine.Object, System.Type, Boolean) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_soob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_soob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Object ObjectField(UnityEngine.Rect, System.String, UnityEngine.Object, System.Type, UnityEngine.Object) declare in UnityEditor.EditorGUI
bool w_oS_r4r4r4r4_sooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4_sooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Plane[] CalculateFrustumPlanes(UnityEngine.Matrix4x4) declare in UnityEngine.GeometryUtility
bool w_oS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.WSA.Tile CreateOrUpdateSecondary(UnityEngine.WSA.SecondaryTileData) declare in UnityEngine.WSA.Tile
bool w_oS_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_* pp0 = DataTransfer::GetPointer<S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_>(apis, env, _sv0);
    S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_ p0 = pp0 ? *pp0 : S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.WSA.Tile CreateOrUpdateSecondary(UnityEngine.WSA.SecondaryTileData, UnityEngine.Vector2) declare in UnityEngine.WSA.Tile
bool w_oS_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_* pp0 = DataTransfer::GetPointer<S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_>(apis, env, _sv0);
    S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_ p0 = pp0 ? *pp0 : S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_ p0, struct S_r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.WSA.Tile CreateOrUpdateSecondary(UnityEngine.WSA.SecondaryTileData, UnityEngine.Rect) declare in UnityEngine.WSA.Tile
bool w_oS_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_* pp0 = DataTransfer::GetPointer<S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_>(apis, env, _sv0);
    S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_ p0 = pp0 ? *pp0 : S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_sS_i4u1u1u1u1_bsi4sbsbbbbssssss_ p0, struct S_r4r4r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Security.Cryptography.RSAEncryptionPadding CreateOaep(System.Security.Cryptography.HashAlgorithmName) declare in System.Security.Cryptography.RSAEncryptionPadding
bool w_oS_s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_s_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_s_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Texture2D[] GetIcons(UnityEditor.Build.NamedBuildTarget, UnityEditor.IconKind) declare in UnityEditor.PlayerSettings
bool w_oS_s_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_s_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_s_ p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.PlatformIcon[] GetPlatformIcons(UnityEditor.Build.NamedBuildTarget, UnityEditor.PlatformIconKind) declare in UnityEditor.PlayerSettings
bool w_oS_s_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_s_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_s_ p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Data.SqlTypes.SqlChars op_Explicit(System.Data.SqlTypes.SqlString) declare in System.Data.SqlTypes.SqlChars
bool w_oS_soi4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_soi4i4b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4b_* pp0 = DataTransfer::GetPointer<S_soi4i4b_>(apis, env, _sv0);
    S_soi4i4b_ p0 = pp0 ? *pp0 : S_soi4i4b_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_soi4i4b_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.AssetBundleManifest BuildAssetBundles(UnityEditor.BuildAssetBundlesParameters) declare in UnityEditor.BuildPipeline
bool w_oS_soi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_soi4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_soi4i4i4_* pp0 = DataTransfer::GetPointer<S_soi4i4i4_>(apis, env, _sv0);
    S_soi4i4i4_ p0 = pp0 ? *pp0 : S_soi4i4i4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_soi4i4i4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Mono.Cecil.Cil.Instruction Create(Mono.Cecil.Cil.OpCode) declare in Mono.Cecil.Cil.Instruction
bool w_oS_u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Mono.Cecil.Cil.Instruction Create(Mono.Cecil.Cil.OpCode, SByte) declare in Mono.Cecil.Cil.Instruction
bool w_oS_u1u1u1u1u1u1u1u1_i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u1u1u1u1u1u1u1u1_i1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p0, int8_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Mono.Cecil.Cil.Instruction Create(Mono.Cecil.Cil.OpCode, Int32) declare in Mono.Cecil.Cil.Instruction
bool w_oS_u1u1u1u1u1u1u1u1_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u1u1u1u1u1u1u1u1_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Mono.Cecil.Cil.Instruction Create(Mono.Cecil.Cil.OpCode, Int64) declare in Mono.Cecil.Cil.Instruction
bool w_oS_u1u1u1u1u1u1u1u1_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u1u1u1u1u1u1u1u1_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p0, int64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Mono.Cecil.Cil.Instruction Create(Mono.Cecil.Cil.OpCode, Mono.Cecil.TypeReference) declare in Mono.Cecil.Cil.Instruction
bool w_oS_u1u1u1u1u1u1u1u1_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u1u1u1u1u1u1u1u1_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Mono.Cecil.Cil.Instruction Create(Mono.Cecil.Cil.OpCode, Single) declare in Mono.Cecil.Cil.Instruction
bool w_oS_u1u1u1u1u1u1u1u1_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u1u1u1u1u1u1u1u1_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p0, float p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Mono.Cecil.Cil.Instruction Create(Mono.Cecil.Cil.OpCode, Double) declare in Mono.Cecil.Cil.Instruction
bool w_oS_u1u1u1u1u1u1u1u1_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u1u1u1u1u1u1u1u1_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p0, double p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Mono.Cecil.Cil.Instruction Create(Mono.Cecil.Cil.OpCode, System.String) declare in Mono.Cecil.Cil.Instruction
bool w_oS_u1u1u1u1u1u1u1u1_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u1u1u1u1u1u1u1u1_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Mono.Cecil.Cil.Instruction Create(Mono.Cecil.Cil.OpCode, Byte) declare in Mono.Cecil.Cil.Instruction
bool w_oS_u1u1u1u1u1u1u1u1_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u1u1u1u1u1u1u1u1_u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p0, uint8_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Net.IPAddress ToIPAddress(Mono.Unix.Native.InAddr) declare in Mono.Unix.Native.NativeConvert
bool w_oS_u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4_* pp0 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv0);
    S_u4_ p0 = pp0 ? *pp0 : S_u4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_u4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.RevisionInfo BuildRevisionInfo(Codice.CM.Common.RepId, Codice.CM.WorkspaceServer.DataStore.WkTree.RawWorkspaceTreeNode, System.Collections.Generic.List`1[Codice.CM.Common.SEID]) declare in Codice.CM.WorkspaceServer.DataStore.WkTree.ReadWorkspaceTree
bool w_oS_u4u4_S_i8i8i4i4i4i4i4i4i4S_u1_u2u2u1u1_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u4u4_S_i8i8i4i4i4i4i4i4i4S_u1_u2u2u1u1_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_i8i8i4i4i4i4i4i4i4S_u1_u2u2u1u1_* pp1 = DataTransfer::GetPointer<S_i8i8i4i4i4i4i4i4i4S_u1_u2u2u1u1_>(apis, env, _sv1);
    S_i8i8i4i4i4i4i4i4i4S_u1_u2u2u1u1_ p1 = pp1 ? *pp1 : S_i8i8i4i4i4i4i4i4i4S_u1_u2u2u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_u4u4_ p0, struct S_i8i8i4i4i4i4i4i4i4S_u1_u2u2u1u1_ p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.RevisionInfo BuildLocalAddRevisionInfo(Codice.CM.Common.RepId, Int64, Int64, Codice.CM.Common.EnumRevisionType, Codice.CM.Common.SEID) declare in Codice.CM.WorkspaceServer.Tree.LocalRevisionInfoBuilder
bool w_oS_u4u4_i8i8i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u4u4_i8i8i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(struct S_u4u4_ p0, int64_t p1, int64_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.Tree.TreeNode GetRevisionTree(Codice.CM.Common.RepId, Codice.CM.Common.RevSpec, Codice.CM.Interfaces.IItemHandler, Codice.CM.Common.TreeOptions) declare in Codice.Client.Common.RevisionTreeRetriever
bool w_oS_u4u4_ooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u4u4_ooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_u4u4_ p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// PlasticGui.WorkspaceWindow.Merge.MergeChangesTree BuildForIncomingChangesView(Codice.CM.Common.RepId, Codice.CM.Common.Merge.MergeTreeResult, IGetConflictResolution, Codice.CM.Common.Mount.MountPointWithPath) declare in PlasticGui.WorkspaceWindow.Merge.MergeChangesTree
bool w_oS_u4u4_ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u4u4_ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(struct S_u4u4_ p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.RepositoryInfo CreateRepositoryInfoFromNetwork(Codice.CM.Common.RepId, System.String, System.String, System.Guid, Codice.CM.Common.RepositoryType, Codice.CM.Common.SEID) declare in Codice.CM.Common.RepositoryInfo
bool w_oS_u4u4_ssS_i4i2i2u1u1u1u1u1u1u1u1_u1o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u4u4_ssS_i4i2i2u1u1u1u1u1u1u1u1_u1o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp3 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv3);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p3 = pp3 ? *pp3 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(struct S_u4u4_ p0, Il2CppString* p1, Il2CppString* p2, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p3, uint8_t p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Type GetMainAssetTypeFromGUID(UnityEditor.GUID) declare in UnityEditor.AssetDatabase
bool w_oS_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_u4u4u4u4_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Build.Content.ObjectIdentifier[] GetPlayerObjectIdentifiersInAsset(UnityEditor.GUID, UnityEditor.BuildTarget) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_oS_u4u4u4u4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u4u4u4u4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(struct S_u4u4u4u4_ p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Unity.Loading.ContentFile[] GetContentFiles(Unity.Content.ContentNamespace) declare in Unity.Loading.ContentLoadInterface
bool w_oS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_u8_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(System.DateTime, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oS_u8_DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u8_DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(struct S_u8_ p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.Schema.XmlAtomicValue DateTimeToAtomicValue(System.DateTime, Int32, System.Xml.Xsl.Runtime.XmlQueryRuntime) declare in System.Xml.Xsl.Runtime.XmlILStorageConverter
bool w_oS_u8_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u8_i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(struct S_u8_ p0, int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Net.IPAddress ToIPAddress(Mono.Unix.Native.In6Addr) declare in Mono.Unix.Native.NativeConvert
bool w_oS_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u8u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv0);
    S_u8u8_ p0 = pp0 ? *pp0 : S_u8u8_ {};

    typedef Il2CppObject* (*FuncToCall)(struct S_u8u8_ p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Type GetType() declare in System.Object
bool w_oT(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oT");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef Il2CppObject* (*FuncToCall)(void*,const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// JetBrains.Lifetimes.LifetimeDefinition DefineIntersection(JetBrains.Lifetimes.OuterLifetime[]) declare in JetBrains.Lifetimes.OuterLifetime
bool w_oVS_S_o__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oVS_S_o__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, true)) return false;
    }
    
    // JSValToCSVal valuetype params
    Il2CppArray* p0 = Params<S_S_o__>::PackValueType(apis, env, info, TIp0, js_args_len, 0);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppArray* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.CancellationTokenSource CreateLinkedTokenSource(System.Threading.CancellationToken[]) declare in System.Threading.CancellationTokenSource
bool w_oVS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oVS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, true)) return false;
    }
    
    // JSValToCSVal valuetype params
    Il2CppArray* p0 = Params<S_o_>::PackValueType(apis, env, info, TIp0, js_args_len, 0);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppArray* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Mono.Reflection.ILPattern Optional(System.Reflection.Emit.OpCode[]) declare in Mono.Reflection.ILPattern
bool w_oVS_u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oVS_u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, true)) return false;
    }
    
    // JSValToCSVal valuetype params
    Il2CppArray* p0 = Params<S_u1u1u1u1u1u1u1u1_>::PackValueType(apis, env, info, TIp0, js_args_len, 0);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppArray* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Delegate Combine(System.Delegate[]) declare in System.Delegate
bool w_oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, false)) return false;
    }
    
    // JSValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, js_args_len, 0);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppArray* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Search.ISearchView ShowContextual(System.String[]) declare in UnityEditor.Search.SearchService
bool w_oVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oVs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal string params
    Il2CppArray* p0 = Params<void*>::PackString(apis, env, info, TIp0, js_args_len, 0);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppArray* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Byte[] GetBytes(Boolean) declare in System.BitConverter
bool w_ob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ob");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(bool p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(Boolean, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_obDN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_obDN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(bool p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.PackageManager.Requests.ListRequest List(Boolean, Boolean) declare in UnityEditor.PackageManager.Client
bool w_obb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_obb");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(bool p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.Schema.XmlAtomicValue BooleanToAtomicValue(Boolean, Int32, System.Xml.Xsl.Runtime.XmlQueryRuntime) declare in System.Xml.Xsl.Runtime.XmlILStorageConverter
bool w_obi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_obi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(bool p0, int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Client.Differences.DifferenceRange FoundMoveText(Boolean, Int32, Codice.CM.Client.Differences.Merge.ConflictCollection, Codice.CM.Client.Differences.ComparisonMethodTypes, Double, Int32) declare in Codice.CM.Client.Differences.Merge.FileMerge
bool w_obi4oi4r8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_obi4oi4r8i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    double p4 = converter::Converter<double>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(bool p0, int32_t p1, Il2CppObject* p2, int32_t p3, double p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.RepositoryInfo DeserializeRepositoryInfo(Boolean, Codice.CM.Common.Serialization.PlasticBinaryReader) declare in PlasticPipe.PlasticProtocol.Messages.Serialization.ObjectSerialization
bool w_obo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_obo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(bool p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.RepositorySpec Parse(Boolean, System.String, System.String, Codice.CM.Common.IUnityOrgResolver) declare in Codice.Client.Common.Specs.Generators.RepositorySpecGenerator
bool w_obsso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_obsso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(bool p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Byte[] GetBytes(Char) declare in System.BitConverter
bool w_oc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oc");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(Il2CppChar p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(Char, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_ocDN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ocDN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppChar p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Unicode.UnicodeRange Create(Char, Char) declare in System.Text.Unicode.UnicodeRange
bool w_occ(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_occ");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppChar p0, Il2CppChar p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode op_Implicit(SByte) declare in System.Text.Json.Nodes.JsonNode
bool w_oi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(int8_t p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(SByte, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oi1DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi1DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(int8_t p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Byte[] GetBytes(Int16) declare in System.BitConverter
bool w_oi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(int16_t p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(Int16, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oi2DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi2DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(int16_t p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// CodiceApp.EventTracking.EventModel FromUse(Int16, Int16, System.String) declare in CodiceApp.EventTracking.BuildEventModel
bool w_oi2i2s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi2i2s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(int16_t p0, int16_t p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// CodiceApp.EventTracking.EventModel FromUse(CodiceApp.EventTracking.Plastic.EventName, System.String) declare in CodiceApp.EventTracking.Plastic.BuildEvent
bool w_oi2s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi2s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(int16_t p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Byte[] GetBytes(Int32) declare in System.BitConverter
bool w_oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(Int32, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oi4DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.EaseFunction StopMotion(Int32, System.Nullable`1[DG.Tweening.Ease]) declare in DG.Tweening.EaseFactory
bool w_oi4DN_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4DN_bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    N_bi4_ p1 = OptionalParameter<N_bi4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, struct N_bi4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Material GetBlitMaterial(UnityEngine.Rendering.TextureDimension, Boolean) declare in UnityEngine.Rendering.Blitter
bool w_oi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4Db");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.IEnumerator WaitForSaveDialog(PickMode, Boolean, System.String, System.String, System.String, System.String) declare in SimpleFileBrowser.FileBrowser
bool w_oi4DbDsDsDsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4DbDsDsDsDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal string  with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal string  with default
    Il2CppString* p4 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal string  with default
    Il2CppString* p5 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, bool p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.UIElements.NavigationMoveEvent GetPooled(Direction, UnityEngine.EventModifiers) declare in UnityEngine.UIElements.NavigationMoveEvent
bool w_oi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4Di4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[Cysharp.Threading.Tasks.AsyncUnit] TimerFrame(Int32, Cysharp.Threading.Tasks.PlayerLoopTiming, Boolean) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_oi4Di4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4Di4Db");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Search.SearchItem CreateItem(Int32, System.String) declare in UnityEditor.Search.SearchExpression
bool w_oi4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4Ds");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.IO.IsolatedStorage.IsolatedStorageFile GetStore(System.IO.IsolatedStorage.IsolatedStorageScope, System.Object) declare in System.IO.IsolatedStorage.IsolatedStorageFile
bool w_oi4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4O");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.IO.IsolatedStorage.IsolatedStorageFile GetStore(System.IO.IsolatedStorage.IsolatedStorageScope, System.Object, System.Object) declare in System.IO.IsolatedStorage.IsolatedStorageFile
bool w_oi4OO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4OO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[System.String] ReadStrings(Int32, Byte*, Byte[], Int32 ByRef, Int32 ByRef, System.IO.FileStream, Int32) declare in Codice.CM.WorkspaceServer.DataStore.WkTree.ReadWorkspaceTree
bool w_oi4PvoPi4Pi4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4PvoPi4Pi4oi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;
    // JSValToCSVal P primitive
    int32_t up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, int32_t* p3, int32_t* p4, Il2CppObject* p5, int32_t p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    apis->update_boxed_value(env, _sv4, converter::Converter<int32_t>::toScript(apis, env, *p4));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.AsyncOperation LoadSceneAsync(Int32, UnityEngine.SceneManagement.LoadSceneParameters) declare in UnityEngine.SceneManagement.SceneManager
bool w_oi4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, struct S_i4i4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Action`2[Microsoft.Extensions.Logging.ILogger,System.Exception] Define(Microsoft.Extensions.Logging.LogLevel, Microsoft.Extensions.Logging.EventId, System.String) declare in Microsoft.Extensions.Logging.LoggerMessage
bool w_oi4S_i4s_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4S_i4s_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4s_* pp1 = DataTransfer::GetPointer<S_i4s_>(apis, env, _sv1);
    S_i4s_ p1 = pp1 ? *pp1 : S_i4s_ {};
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, struct S_i4s_ p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Action`2[Microsoft.Extensions.Logging.ILogger,System.Exception] Define(Microsoft.Extensions.Logging.LogLevel, Microsoft.Extensions.Logging.EventId, System.String, Microsoft.Extensions.Logging.LogDefineOptions) declare in Microsoft.Extensions.Logging.LoggerMessage
bool w_oi4S_i4s_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4S_i4s_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4s_* pp1 = DataTransfer::GetPointer<S_i4s_>(apis, env, _sv1);
    S_i4s_ p1 = pp1 ? *pp1 : S_i4s_ {};
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, struct S_i4s_ p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task Delay(Int32, System.Threading.CancellationToken) declare in System.Threading.Tasks.Task
bool w_oi4S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, struct S_o_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Microsoft.Win32.RegistryKey OpenBaseKey(Microsoft.Win32.RegistryHive, Microsoft.Win32.RegistryView) declare in Microsoft.Win32.RegistryKey
bool w_oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable`1[Cysharp.Threading.Tasks.AsyncUnit] TimerFrame(Int32, Int32, Cysharp.Threading.Tasks.PlayerLoopTiming, Boolean) declare in Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable
bool w_oi4i4Di4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4Di4Db");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.RTHandle Alloc(Int32, Int32, Int32, UnityEngine.Rendering.DepthBits, UnityEngine.Experimental.Rendering.GraphicsFormat, UnityEngine.FilterMode, UnityEngine.TextureWrapMode, UnityEngine.Rendering.TextureDimension, Boolean, Boolean, Boolean, Boolean, Int32, Single, UnityEngine.Rendering.MSAASamples, Boolean, Boolean, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage, System.String) declare in UnityEngine.Rendering.RTHandles
bool w_oi4i4Di4Di4Di4Di4Di4Di4DbDbDbDbDi4Dr4Di4DbDbDi4Di4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4Di4Di4Di4Di4Di4Di4DbDbDbDbDi4Dr4Di4DbDbDi4Di4Ds");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp19 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);
    pesapi_value _sv16 = apis->get_arg(info, 16);
    pesapi_value _sv17 = apis->get_arg(info, 17);
    pesapi_value _sv18 = apis->get_arg(info, 18);
    pesapi_value _sv19 = apis->get_arg(info, 19);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (js_args_len > 8 && !converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (js_args_len > 9 && !converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (js_args_len > 10 && !converter::Converter<bool>::accept(apis, env, _sv10)) return false;
        if (js_args_len > 11 && !converter::Converter<bool>::accept(apis, env, _sv11)) return false;
        if (js_args_len > 12 && !converter::Converter<int32_t>::accept(apis, env, _sv12)) return false;
        if (js_args_len > 13 && !converter::Converter<float>::accept(apis, env, _sv13)) return false;
        if (js_args_len > 14 && !converter::Converter<int32_t>::accept(apis, env, _sv14)) return false;
        if (js_args_len > 15 && !converter::Converter<bool>::accept(apis, env, _sv15)) return false;
        if (js_args_len > 16 && !converter::Converter<bool>::accept(apis, env, _sv16)) return false;
        if (js_args_len > 17 && !converter::Converter<int32_t>::accept(apis, env, _sv17)) return false;
        if (js_args_len > 18 && !converter::Converter<int32_t>::accept(apis, env, _sv18)) return false;
        if (js_args_len > 19 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv19)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                
    // JSValToCSVal primitive with default
    bool p8 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 8);
                
    // JSValToCSVal primitive with default
    bool p9 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 9);
                
    // JSValToCSVal primitive with default
    bool p10 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 10);
                
    // JSValToCSVal primitive with default
    bool p11 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 11);
                
    // JSValToCSVal primitive with default
    int32_t p12 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 12);
                
    // JSValToCSVal primitive with default
    float p13 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 13);
                
    // JSValToCSVal primitive with default
    int32_t p14 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 14);
                
    // JSValToCSVal primitive with default
    bool p15 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 15);
                
    // JSValToCSVal primitive with default
    bool p16 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 16);
                
    // JSValToCSVal primitive with default
    int32_t p17 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 17);
                
    // JSValToCSVal primitive with default
    int32_t p18 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 18);
                
    // JSValToCSVal string  with default
    Il2CppString* p19 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 19);
                

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, bool p9, bool p10, bool p11, int32_t p12, float p13, int32_t p14, bool p15, bool p16, int32_t p17, int32_t p18, Il2CppString* p19, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Cubemap CreateExternalTexture(Int32, UnityEngine.TextureFormat, Boolean, IntPtr) declare in UnityEngine.Cubemap
bool w_oi4i4bp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4bp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, bool p2, void* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Concurrent.OrderablePartitioner`1[System.Tuple`2[System.Int32,System.Int32]] Create(Int32, Int32, Int32) declare in System.Collections.Concurrent.Partitioner
bool w_oi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Texture2D UISystemProfilerRender(Int32, Int32, Int32, Boolean) declare in UnityEditorInternal.ProfilerProperty
bool w_oi4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Texture2D CreateExternalTexture(Int32, Int32, UnityEngine.TextureFormat, Boolean, Boolean, IntPtr) declare in UnityEngine.Texture2D
bool w_oi4i4i4bbp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4bbp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!apis->is_binary(env, _sv5) && !apis->is_null(env, _sv5) && !apis->is_undefined(env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, bool p3, bool p4, void* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.RTHandle Alloc(Int32, Int32, UnityEngine.TextureWrapMode, UnityEngine.TextureWrapMode, UnityEngine.TextureWrapMode, Int32, UnityEngine.Rendering.DepthBits, UnityEngine.Experimental.Rendering.GraphicsFormat, UnityEngine.FilterMode, UnityEngine.Rendering.TextureDimension, Boolean, Boolean, Boolean, Boolean, Int32, Single, UnityEngine.Rendering.MSAASamples, Boolean, Boolean, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage, System.String) declare in UnityEngine.Rendering.RTHandles
bool w_oi4i4i4i4Di4Di4Di4Di4Di4Di4DbDbDbDbDi4Dr4Di4DbDbDi4Di4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4Di4Di4Di4Di4Di4Di4DbDbDbDbDi4Dr4Di4DbDbDi4Di4Ds");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp21 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);
    pesapi_value _sv16 = apis->get_arg(info, 16);
    pesapi_value _sv17 = apis->get_arg(info, 17);
    pesapi_value _sv18 = apis->get_arg(info, 18);
    pesapi_value _sv19 = apis->get_arg(info, 19);
    pesapi_value _sv20 = apis->get_arg(info, 20);
    pesapi_value _sv21 = apis->get_arg(info, 21);

    if (true) {
        if (js_args_len < 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (js_args_len > 8 && !converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (js_args_len > 9 && !converter::Converter<int32_t>::accept(apis, env, _sv9)) return false;
        if (js_args_len > 10 && !converter::Converter<bool>::accept(apis, env, _sv10)) return false;
        if (js_args_len > 11 && !converter::Converter<bool>::accept(apis, env, _sv11)) return false;
        if (js_args_len > 12 && !converter::Converter<bool>::accept(apis, env, _sv12)) return false;
        if (js_args_len > 13 && !converter::Converter<bool>::accept(apis, env, _sv13)) return false;
        if (js_args_len > 14 && !converter::Converter<int32_t>::accept(apis, env, _sv14)) return false;
        if (js_args_len > 15 && !converter::Converter<float>::accept(apis, env, _sv15)) return false;
        if (js_args_len > 16 && !converter::Converter<int32_t>::accept(apis, env, _sv16)) return false;
        if (js_args_len > 17 && !converter::Converter<bool>::accept(apis, env, _sv17)) return false;
        if (js_args_len > 18 && !converter::Converter<bool>::accept(apis, env, _sv18)) return false;
        if (js_args_len > 19 && !converter::Converter<int32_t>::accept(apis, env, _sv19)) return false;
        if (js_args_len > 20 && !converter::Converter<int32_t>::accept(apis, env, _sv20)) return false;
        if (js_args_len > 21 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv21)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                
    // JSValToCSVal primitive with default
    int32_t p8 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 8);
                
    // JSValToCSVal primitive with default
    int32_t p9 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 9);
                
    // JSValToCSVal primitive with default
    bool p10 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 10);
                
    // JSValToCSVal primitive with default
    bool p11 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 11);
                
    // JSValToCSVal primitive with default
    bool p12 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 12);
                
    // JSValToCSVal primitive with default
    bool p13 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 13);
                
    // JSValToCSVal primitive with default
    int32_t p14 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 14);
                
    // JSValToCSVal primitive with default
    float p15 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 15);
                
    // JSValToCSVal primitive with default
    int32_t p16 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 16);
                
    // JSValToCSVal primitive with default
    bool p17 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 17);
                
    // JSValToCSVal primitive with default
    bool p18 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 18);
                
    // JSValToCSVal primitive with default
    int32_t p19 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 19);
                
    // JSValToCSVal primitive with default
    int32_t p20 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 20);
                
    // JSValToCSVal string  with default
    Il2CppString* p21 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 21);
                

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, bool p10, bool p11, bool p12, bool p13, int32_t p14, float p15, int32_t p16, bool p17, bool p18, int32_t p19, int32_t p20, Il2CppString* p21, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Profiling.HierarchyFrameDataView GetHierarchyFrameDataView(Int32, Int32, ViewModes, Int32, Boolean) declare in UnityEditorInternal.ProfilerDriver
bool w_oi4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Texture3D CreateExternalTexture(Int32, Int32, Int32, UnityEngine.TextureFormat, Boolean, IntPtr) declare in UnityEngine.Texture3D
bool w_oi4i4i4i4bp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4bp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!apis->is_binary(env, _sv5) && !apis->is_null(env, _sv5) && !apis->is_undefined(env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, bool p4, void* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, UnityEngine.RenderTextureMemoryless) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage, Boolean) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4i4i4i4b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, bool p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage, Boolean) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4i4i4i4i4b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.RTHandle AllocShadowRT(Int32, Int32, Int32, Int32, Single, System.String) declare in UnityEngine.Rendering.Universal.ShadowUtils
bool w_oi4i4i4i4r4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4r4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, float p4, Il2CppString* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.Schema.XmlAtomicValue Int32ToAtomicValue(Int32, Int32, System.Xml.Xsl.Runtime.XmlQueryRuntime) declare in System.Xml.Xsl.Runtime.XmlILStorageConverter
bool w_oi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Utils.Buffers.FlexibleBufferPool BuildPool(Int32, Int32, System.Collections.Generic.Dictionary`2[System.Int32,System.Int32], System.Collections.Generic.Dictionary`2[System.Int32,System.Int32]) declare in Codice.Utils.Buffers.FlexibleBufferPool
bool w_oi4i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.Tweener Int(Int32, Int32, Single, DG.Tweening.TweenCallback`1[System.Int32]) declare in DG.Tweening.DOVirtual
bool w_oi4i4r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4r4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, int32_t p1, float p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Reflection.Emit.SignatureHelper GetMethodSigHelper(System.Reflection.CallingConventions, System.Type) declare in System.Reflection.Emit.SignatureHelper
bool w_oi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[PlasticGui.Help.Condition] Get(PlasticGui.WorkspaceWindow.Merge.EnumMergeType, Codice.CM.Common.MergeResult, PlasticGui.WorkspaceWindow.Merge.ShowIncomingChangesFrom, Boolean, Boolean) declare in PlasticGui.Help.Conditions.MergeConditions
bool w_oi4oi4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4oi4bb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppObject* p1, int32_t p2, bool p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Encoding GetEncoding(Int32, System.Text.EncoderFallback, System.Text.DecoderFallback) declare in System.Text.Encoding
bool w_oi4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Linq.Expressions.BinaryExpression MakeBinary(System.Linq.Expressions.ExpressionType, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, Boolean, System.Reflection.MethodInfo) declare in System.Linq.Expressions.Expression
bool w_oi4oobo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4oobo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Linq.Expressions.BinaryExpression MakeBinary(System.Linq.Expressions.ExpressionType, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, Boolean, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) declare in System.Linq.Expressions.Expression
bool w_oi4ooboo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4ooboo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[System.Int32] GetNewSelection(Int32, System.Collections.Generic.List`1[System.Int32], System.Collections.Generic.List`1[System.Int32], Int32, Boolean, Boolean, Boolean) declare in UnityEditorInternal.InternalEditorUtility
bool w_oi4ooi4bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4ooi4bbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, bool p4, bool p5, bool p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Linq.Expressions.GotoExpression MakeGoto(System.Linq.Expressions.GotoExpressionKind, System.Linq.Expressions.LabelTarget, System.Linq.Expressions.Expression, System.Type) declare in System.Linq.Expressions.Expression
bool w_oi4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.IO.IsolatedStorage.IsolatedStorageFile GetStore(System.IO.IsolatedStorage.IsolatedStorageScope, System.Security.Policy.Evidence, System.Type, System.Security.Policy.Evidence, System.Type) declare in System.IO.IsolatedStorage.IsolatedStorageFile
bool w_oi4oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4oooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Exception GetExceptionForHR(Int32, IntPtr) declare in System.Runtime.InteropServices.Marshal
bool w_oi4p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4p");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, void* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.String[] PtrToStringArray(Int32, IntPtr, System.Text.Encoding) declare in Mono.Unix.UnixMarshal
bool w_oi4po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4po");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Microsoft.Win32.RegistryKey OpenRemoteBaseKey(Microsoft.Win32.RegistryHive, System.String) declare in Microsoft.Win32.RegistryKey
bool w_oi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Microsoft.Win32.RegistryKey OpenRemoteBaseKey(Microsoft.Win32.RegistryHive, System.String, Microsoft.Win32.RegistryView) declare in Microsoft.Win32.RegistryKey
bool w_oi4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4si4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppString* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.LicenseData GetLicenseData(Int32, System.String, Int32, System.DateTime, Codice.CM.Common.Features, Codice.CM.Common.EnumLicenseType, Codice.CM.Common.Edition, Int32, Int16, Int16) declare in Codice.CM.Common.LicenseData
bool w_oi4si4S_u8_i8i4i4i4i2i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4si4S_u8_i8i4i4i4i2i2");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (checkJSArgument) {
        if (js_args_len != 10) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv9)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_u8_* pp3 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv3);
    S_u8_ p3 = pp3 ? *pp3 : S_u8_ {};
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int16_t p8 = converter::Converter<int16_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    int16_t p9 = converter::Converter<int16_t>::toCpp(apis, env, _sv9);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppString* p1, int32_t p2, struct S_u8_ p3, int64_t p4, int32_t p5, int32_t p6, int32_t p7, int16_t p8, int16_t p9, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[PlasticGui.Help.Condition] Get(Int32, System.String, System.String, System.String, PlasticGui.IPlasticAPI) declare in PlasticGui.Help.Conditions.CloudConditions
bool w_oi4ssso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi4ssso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Byte[] GetBytes(Int64) declare in System.BitConverter
bool w_oi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(int64_t p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonValue Create(Int64, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions]) declare in System.Text.Json.Nodes.JsonValue
bool w_oi8DN_bS_b__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi8DN_bS_b__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(int64_t p0, struct N_bS_b__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.Schema.XmlAtomicValue Int64ToAtomicValue(Int64, Int32, System.Xml.Xsl.Runtime.XmlQueryRuntime) declare in System.Xml.Xsl.Runtime.XmlILStorageConverter
bool w_oi8i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi8i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(int64_t p0, int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Concurrent.OrderablePartitioner`1[System.Tuple`2[System.Int64,System.Int64]] Create(Int64, Int64) declare in System.Collections.Concurrent.Partitioner
bool w_oi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi8i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(int64_t p0, int64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Concurrent.OrderablePartitioner`1[System.Tuple`2[System.Int64,System.Int64]] Create(Int64, Int64, Int64) declare in System.Collections.Concurrent.Partitioner
bool w_oi8i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi8i8i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(int64_t p0, int64_t p1, int64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[PlasticGui.WorkspaceWindow.CodeReview.ReviewChanges.Comments.CodeReviewCommentIndented] Create(Int64, Int64, Int64, Int32, Codice.CM.Common.SEID) declare in PlasticGui.WorkspaceWindow.CodeReview.ReviewChanges.Comments.NewCodeReviewComment
bool w_oi8i8i8i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi8i8i8i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(int64_t p0, int64_t p1, int64_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[PlasticGui.WorkspaceWindow.CodeReview.ReviewChanges.Comments.CodeReviewCommentIndented] Reply(Int64, Int64, Int64, Int64, Codice.CM.Common.CodeReviewCommentType, Int32, Codice.CM.Common.SEID, System.Collections.Generic.List`1[Codice.CM.Common.CodeReviewCommentInfo]) declare in PlasticGui.WorkspaceWindow.CodeReview.ReviewChanges.Comments.NewCodeReviewComment
bool w_oi8i8i8i8u1i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi8i8i8i8u1i4oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp6 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(int64_t p0, int64_t p1, int64_t p2, int64_t p3, uint8_t p4, int32_t p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Client.Common.CmClientException BuildPurgedDataException(Int64, System.String) declare in Codice.Client.BaseCommands.Download.ExternalData
bool w_oi8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oi8s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(int64_t p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Microsoft.Win32.RegistryKey FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle) declare in Microsoft.Win32.RegistryKey
bool w_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.Nodes.JsonNode Parse(System.IO.Stream, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions], System.Text.Json.JsonDocumentOptions) declare in System.Text.Json.Nodes.JsonNode
bool w_ooDN_bS_b__DS_i4u1b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDN_bS_b__DS_i4u1b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal valuetype  with default
    S_i4u1b_ p2 = OptionalParameter<S_i4u1b_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct N_bS_b__ p1, struct S_i4u1b_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task`1[System.Text.Json.Nodes.JsonNode] ParseAsync(System.IO.Stream, System.Nullable`1[System.Text.Json.Nodes.JsonNodeOptions], System.Text.Json.JsonDocumentOptions, System.Threading.CancellationToken) declare in System.Text.Json.Nodes.JsonNode
bool w_ooDN_bS_b__DS_i4u1b_DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDN_bS_b__DS_i4u1b_DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal valuetype  with default
    N_bS_b__ p1 = OptionalParameter<N_bS_b__>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal valuetype  with default
    S_i4u1b_ p2 = OptionalParameter<S_i4u1b_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal valuetype  with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct N_bS_b__ p1, struct S_i4u1b_ p2, struct S_o_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.Json.JsonDocument Parse(System.IO.Stream, System.Text.Json.JsonDocumentOptions) declare in System.Text.Json.JsonDocument
bool w_ooDS_i4u1b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDS_i4u1b_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal valuetype  with default
    S_i4u1b_ p1 = OptionalParameter<S_i4u1b_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_i4u1b_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task`1[System.Text.Json.JsonDocument] ParseAsync(System.IO.Stream, System.Text.Json.JsonDocumentOptions, System.Threading.CancellationToken) declare in System.Text.Json.JsonDocument
bool w_ooDS_i4u1b_DS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDS_i4u1b_DS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal valuetype  with default
    S_i4u1b_ p1 = OptionalParameter<S_i4u1b_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal valuetype  with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_i4u1b_ p1, struct S_o_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Bee.BeeDriver.ActiveBuild BuildAsync(Bee.BeeDriver.BuildRequest, System.Threading.CancellationToken) declare in Bee.BeeDriver.BeeDriver
bool w_ooDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal valuetype  with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_o_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[UnityEditor.SceneManagement.ObjectOverride] GetObjectOverrides(UnityEngine.GameObject, Boolean) declare in UnityEditor.PrefabUtility
bool w_ooDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[NugetForUnity.Models.INugetPackage] GetUpdates(System.Collections.Generic.IEnumerable`1[NugetForUnity.Models.INugetPackage], Boolean, System.String, System.String, System.Threading.CancellationToken) declare in NugetForUnity.Configuration.ConfigurationManager
bool w_ooDbDsDsDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDbDsDsDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal string  with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal valuetype  with default
    S_o_ p4 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppString* p2, Il2CppString* p3, struct S_o_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Hash128[] GetArtifactHashes(System.String[], ImportSyncMode) declare in UnityEditor.Experimental.AssetDatabaseExperimental
bool w_ooDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.RTHandle Alloc(UnityEngine.Rendering.ScaleFunc, Int32, UnityEngine.Rendering.DepthBits, UnityEngine.Experimental.Rendering.GraphicsFormat, UnityEngine.FilterMode, UnityEngine.TextureWrapMode, UnityEngine.Rendering.TextureDimension, Boolean, Boolean, Boolean, Boolean, Int32, Single, UnityEngine.Rendering.MSAASamples, Boolean, Boolean, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage, System.String) declare in UnityEngine.Rendering.RTHandles
bool w_ooDi4Di4Di4Di4Di4Di4DbDbDbDbDi4Dr4Di4DbDbDi4Di4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDi4Di4Di4Di4Di4Di4DbDbDbDbDi4Dr4Di4DbDbDi4Di4Ds");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp18 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);
    pesapi_value _sv12 = apis->get_arg(info, 12);
    pesapi_value _sv13 = apis->get_arg(info, 13);
    pesapi_value _sv14 = apis->get_arg(info, 14);
    pesapi_value _sv15 = apis->get_arg(info, 15);
    pesapi_value _sv16 = apis->get_arg(info, 16);
    pesapi_value _sv17 = apis->get_arg(info, 17);
    pesapi_value _sv18 = apis->get_arg(info, 18);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (js_args_len > 8 && !converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (js_args_len > 9 && !converter::Converter<bool>::accept(apis, env, _sv9)) return false;
        if (js_args_len > 10 && !converter::Converter<bool>::accept(apis, env, _sv10)) return false;
        if (js_args_len > 11 && !converter::Converter<int32_t>::accept(apis, env, _sv11)) return false;
        if (js_args_len > 12 && !converter::Converter<float>::accept(apis, env, _sv12)) return false;
        if (js_args_len > 13 && !converter::Converter<int32_t>::accept(apis, env, _sv13)) return false;
        if (js_args_len > 14 && !converter::Converter<bool>::accept(apis, env, _sv14)) return false;
        if (js_args_len > 15 && !converter::Converter<bool>::accept(apis, env, _sv15)) return false;
        if (js_args_len > 16 && !converter::Converter<int32_t>::accept(apis, env, _sv16)) return false;
        if (js_args_len > 17 && !converter::Converter<int32_t>::accept(apis, env, _sv17)) return false;
        if (js_args_len > 18 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv18)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    bool p7 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                
    // JSValToCSVal primitive with default
    bool p8 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 8);
                
    // JSValToCSVal primitive with default
    bool p9 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 9);
                
    // JSValToCSVal primitive with default
    bool p10 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 10);
                
    // JSValToCSVal primitive with default
    int32_t p11 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 11);
                
    // JSValToCSVal primitive with default
    float p12 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 12);
                
    // JSValToCSVal primitive with default
    int32_t p13 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 13);
                
    // JSValToCSVal primitive with default
    bool p14 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 14);
                
    // JSValToCSVal primitive with default
    bool p15 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 15);
                
    // JSValToCSVal primitive with default
    int32_t p16 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 16);
                
    // JSValToCSVal primitive with default
    int32_t p17 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 17);
                
    // JSValToCSVal string  with default
    Il2CppString* p18 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 18);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, bool p7, bool p8, bool p9, bool p10, int32_t p11, float p12, int32_t p13, bool p14, bool p15, int32_t p16, int32_t p17, Il2CppString* p18, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Networking.PlayerConnection.IConnectionState GetConnectionState(UnityEditor.EditorWindow, System.Action`1[System.String]) declare in UnityEditor.Networking.PlayerConnection.PlayerConnectionGUIUtility
bool w_ooDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.TerrainUtils.TerrainMap CreateFromConnectedNeighbors(UnityEngine.Terrain, System.Predicate`1[UnityEngine.Terrain], Boolean) declare in UnityEngine.TerrainUtils.TerrainMap
bool w_ooDoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDoDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Net.HttpListener CreateHttpListener(System.Security.Cryptography.X509Certificates.X509Certificate, Mono.Security.Interface.MonoTlsProvider, Mono.Security.Interface.MonoTlsSettings) declare in Mono.Security.Interface.MonoTlsProviderFactory
bool w_ooDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDoDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Action CallDelayed(CallbackFunction, Double) declare in UnityEditor.Search.Dispatcher
bool w_ooDr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDr8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    double p1 = OptionalParameter<double>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, double p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GUIContent TrIconContent(UnityEngine.Texture, System.String) declare in UnityEditor.EditorGUIUtility
bool w_ooDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Search.SearchContext CreateContext(System.Collections.Generic.IEnumerable`1[System.String], System.String, UnityEditor.Search.SearchFlags) declare in UnityEditor.Search.SearchService
bool w_ooDsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDsDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Microsoft.Extensions.AI.AIFunction Create(System.Delegate, System.String, System.String, System.Text.Json.JsonSerializerOptions) declare in Microsoft.Extensions.AI.AIFunctionFactory
bool w_ooDsDsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooDsDsDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Dynamic.BindingRestrictions GetInstanceRestriction(System.Linq.Expressions.Expression, System.Object) declare in System.Dynamic.BindingRestrictions
bool w_ooO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Microsoft.Extensions.AI.AIFunction Create(System.Reflection.MethodInfo, System.Object, System.String, System.String, System.Text.Json.JsonSerializerOptions) declare in Microsoft.Extensions.AI.AIFunctionFactory
bool w_ooODsDsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooODsDsDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal string  with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Microsoft.Extensions.DependencyInjection.ServiceDescriptor KeyedSingleton(System.Type, System.Object, System.Object) declare in Microsoft.Extensions.DependencyInjection.ServiceDescriptor
bool w_ooOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooOO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.Reflection.MethodInfo) declare in System.Delegate
bool w_ooOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task SerializeAsync(System.IO.Stream, System.Object, System.Text.Json.Serialization.Metadata.JsonTypeInfo, System.Threading.CancellationToken) declare in System.Text.Json.JsonSerializer
bool w_ooOoDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooOoDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal valuetype  with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, struct S_o_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task SerializeAsync(System.IO.Stream, System.Object, System.Type, System.Text.Json.JsonSerializerOptions, System.Threading.CancellationToken) declare in System.Text.Json.JsonSerializer
bool w_ooOoDoDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooOoDoDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal valuetype  with default
    S_o_ p4 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, struct S_o_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.Reflection.MethodInfo, Boolean) declare in System.Delegate
bool w_ooOob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooOob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Microsoft.Extensions.DependencyInjection.ServiceDescriptor DescribeKeyed(System.Type, System.Object, System.Type, Microsoft.Extensions.DependencyInjection.ServiceLifetime) declare in Microsoft.Extensions.DependencyInjection.ServiceDescriptor
bool w_ooOoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooOoi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task SerializeAsync(System.IO.Stream, System.Object, System.Type, System.Text.Json.Serialization.JsonSerializerContext, System.Threading.CancellationToken) declare in System.Text.Json.JsonSerializer
bool w_ooOooDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooOooDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal valuetype  with default
    S_o_ p4 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, struct S_o_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.String) declare in System.Delegate
bool w_ooOs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooOs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.String, Boolean) declare in System.Delegate
bool w_ooOsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooOsb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.String, Boolean, Boolean) declare in System.Delegate
bool w_ooOsbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooOsbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, bool p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.RTHandle Alloc(UnityEngine.Rendering.ScaleFunc, UnityEngine.RenderTextureDescriptor ByRef, UnityEngine.FilterMode, UnityEngine.TextureWrapMode, Boolean, Int32, Single, System.String) declare in UnityEngine.Rendering.RTHandles
bool w_ooPS_i4i4i4i4i4i4i4i4i4i4i4i4i4_Di4Di4DbDi4Dr4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooPS_i4i4i4i4i4i4i4i4i4i4i4i4i4_Di4Di4DbDi4Dr4Ds");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* p1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i4i4i4i4i4i4i4i4i4i4i4i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    float p6 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal string  with default
    Il2CppString* p7 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 7);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* p1, int32_t p2, int32_t p3, bool p4, int32_t p5, float p6, Il2CppString* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.LocalKeyword[] GetPassKeywords(UnityEngine.Shader, UnityEngine.Rendering.PassIdentifier ByRef) declare in UnityEditor.ShaderUtil
bool w_ooPS_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooPS_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_u4u4_* p1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u4u4_));
        p1 = &up1;
    }
        

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_u4u4_* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.LocalKeyword[] GetPassKeywords(UnityEngine.Shader, UnityEngine.Rendering.PassIdentifier ByRef, UnityEditor.Rendering.ShaderType) declare in UnityEditor.ShaderUtil
bool w_ooPS_u4u4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooPS_u4u4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_u4u4_* p1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u4u4_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_u4u4_* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rendering.LocalKeyword[] GetPassKeywords(UnityEngine.Shader, UnityEngine.Rendering.PassIdentifier ByRef, UnityEditor.Rendering.ShaderType, UnityEditor.Rendering.ShaderCompilerPlatform) declare in UnityEditor.ShaderUtil
bool w_ooPS_u4u4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooPS_u4u4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_u4u4_* p1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u4u4_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_u4u4_* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject SavePrefabAsset(UnityEngine.GameObject, Boolean ByRef) declare in UnityEditor.PrefabUtility
bool w_ooPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooPb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Cysharp.Threading.Tasks.AutoResetUniTaskCompletionSource CreateFromException(System.Exception, Int16 ByRef) declare in Cysharp.Threading.Tasks.AutoResetUniTaskCompletionSource
bool w_ooPi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooPi2");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    int16_t up1 = converter::Converter<std::reference_wrapper<int16_t>>::toCpp(apis, env, _sv1);
    int16_t* p1 = &up1;

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int16_t* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int16_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Reflection.MemberInfo[] GetSerializableMembers(System.Type, System.Runtime.Serialization.StreamingContext) declare in System.Runtime.Serialization.FormatterServices
bool w_ooS_Oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_Oi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_Oi4_* pp1 = DataTransfer::GetPointer<S_Oi4_>(apis, env, _sv1);
    S_Oi4_ p1 = pp1 ? *pp1 : S_Oi4_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_Oi4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Int32[] Generate(UnityEngine.Mesh, UnityEngine.U2D.SpriteShapeParameters, UnityEngine.U2D.ShapeControlPoint[], UnityEngine.U2D.SpriteShapeMetaData[], UnityEngine.U2D.AngleRangeInfo[], UnityEngine.Sprite[], UnityEngine.Sprite[]) declare in UnityEngine.U2D.SpriteShapeUtility
bool w_ooS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_ooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_ooooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_>(apis, env, _sv1);
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ou4u4r4r4r4r4bbbbb_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.SceneManagement.Scene) declare in UnityEngine.Object
bool w_ooS_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_i4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// TMPro.TMP_SubMesh AddSubTextObject(TMPro.TextMeshPro, TMPro.MaterialReference) declare in TMPro.TMP_SubMesh
bool w_ooS_i4ooobbor4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_i4ooobbor4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i4ooobbor4i4_* pp1 = DataTransfer::GetPointer<S_i4ooobbor4i4_>(apis, env, _sv1);
    S_i4ooobbor4i4_ p1 = pp1 ? *pp1 : S_i4ooobbor4i4_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_i4ooobbor4i4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.AsyncOperation UpdateNavMeshDataAsync(UnityEngine.AI.NavMeshData, UnityEngine.AI.NavMeshBuildSettings, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildSource], UnityEngine.Bounds) declare in UnityEngine.AI.NavMeshBuilder
bool w_ooS_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__oS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__oS_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__* pp1 = DataTransfer::GetPointer<S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__>(apis, env, _sv1);
    S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ p1 = pp1 ? *pp1 : S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv3);
    S_S_r4r4r4_S_r4r4r4__ p3 = pp3 ? *pp3 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ p1, Il2CppObject* p2, struct S_S_r4r4r4_S_r4r4r4__ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task Run(System.Action, System.Threading.CancellationToken) declare in System.Threading.Tasks.Task
bool w_ooS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_o_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Avatar BuildHumanAvatar(UnityEngine.GameObject, UnityEngine.HumanDescription) declare in UnityEngine.AvatarBuilder
bool w_ooS_oor4r4r4r4r4r4r4r4sbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_oor4r4r4r4r4r4r4r4sbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_oor4r4r4r4r4r4r4r4sbbb_* pp1 = DataTransfer::GetPointer<S_oor4r4r4r4r4r4r4r4sbbb_>(apis, env, _sv1);
    S_oor4r4r4r4r4r4r4r4sbbb_ p1 = pp1 ? *pp1 : S_oor4r4r4r4r4r4r4r4sbbb_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_oor4r4r4r4r4r4r4r4sbbb_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.TerrainTools.PaintTreesDetailsContext Create(UnityEngine.Terrain, UnityEngine.Vector2) declare in UnityEditor.TerrainTools.PaintTreesDetailsContext
bool w_ooS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rect[] GenerateGridSpriteRectangles(UnityEngine.Texture2D, UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEditorInternal.InternalSpriteUtility
bool w_ooS_r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Rect[] GenerateGridSpriteRectangles(UnityEngine.Texture2D, UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2, Boolean) declare in UnityEditorInternal.InternalSpriteUtility
bool w_ooS_r4r4_S_r4r4_S_r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4_S_r4r4_S_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Texture2D GetSceneObjectPreview(UnityEngine.GameObject, UnityEngine.Vector2, UnityEditor.Search.FetchPreviewOptions, UnityEngine.Texture2D) declare in UnityEditor.Search.SearchUtils
bool w_ooS_r4r4_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4_i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.Object
bool w_ooS_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion, Int32) declare in UnityEngine.Network
bool w_ooS_r4r4r4_S_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4_S_r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Transform) declare in UnityEngine.Object
bool w_ooS_r4r4r4_S_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4_S_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.EditorWindow GetWindowWithRect(System.Type, UnityEngine.Rect) declare in UnityEditor.EditorWindow
bool w_ooS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.TerrainTools.PaintContext BeginPaintHeightmap(UnityEngine.Terrain, UnityEngine.Rect, Int32, Boolean) declare in UnityEngine.TerrainTools.TerrainPaintUtility
bool w_ooS_r4r4r4r4_Di4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_Di4Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, int32_t p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2) declare in UnityEngine.Sprite
bool w_ooS_r4r4r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2, Single) declare in UnityEngine.Sprite
bool w_ooS_r4r4r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2, Single, UInt32) declare in UnityEngine.Sprite
bool w_ooS_r4r4r4r4_S_r4r4_r4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_S_r4r4_r4u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, float p3, uint32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2, Single, UInt32, UnityEngine.SpriteMeshType) declare in UnityEngine.Sprite
bool w_ooS_r4r4r4r4_S_r4r4_r4u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_S_r4r4_r4u4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, float p3, uint32_t p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2, Single, UInt32, UnityEngine.SpriteMeshType, UnityEngine.Vector4) declare in UnityEngine.Sprite
bool w_ooS_r4r4r4r4_S_r4r4_r4u4i4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_S_r4r4_r4u4i4S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, float p3, uint32_t p4, int32_t p5, struct S_r4r4r4r4_ p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2, Single, UInt32, UnityEngine.SpriteMeshType, UnityEngine.Vector4, Boolean) declare in UnityEngine.Sprite
bool w_ooS_r4r4r4r4_S_r4r4_r4u4i4S_r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_S_r4r4_r4u4i4S_r4r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, float p3, uint32_t p4, int32_t p5, struct S_r4r4r4r4_ p6, bool p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2, Single, UInt32, UnityEngine.SpriteMeshType, UnityEngine.Vector4, Boolean, UnityEngine.SecondarySpriteTexture[]) declare in UnityEngine.Sprite
bool w_ooS_r4r4r4r4_S_r4r4_r4u4i4S_r4r4r4r4_bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_S_r4r4_r4u4i4S_r4r4r4r4_bo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp8 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal o/O
    Il2CppObject* p8 = JsValueToCSRef(apis, TIp8, env, _sv8);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, float p3, uint32_t p4, int32_t p5, struct S_r4r4r4r4_ p6, bool p7, Il2CppObject* p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.AnimationCurve CurveField(UnityEngine.AnimationCurve, UnityEngine.Color, UnityEngine.Rect, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_ooS_r4r4r4r4_S_r4r4r4r4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_S_r4r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, Il2CppArray* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.EditorWindow GetWindowWithRect(System.Type, UnityEngine.Rect, Boolean) declare in UnityEditor.EditorWindow
bool w_ooS_r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.EditorWindow GetWindowWithRect(System.Type, UnityEngine.Rect, Boolean, System.String) declare in UnityEditor.EditorWindow
bool w_ooS_r4r4r4r4_bs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_bs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, bool p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.TerrainTools.PaintContext CreateFromBounds(UnityEngine.Terrain, UnityEngine.Rect, Int32, Int32, Int32, Boolean, Boolean) declare in UnityEngine.TerrainTools.PaintContext
bool w_ooS_r4r4r4r4_i4i4Di4DbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_i4i4Di4DbDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<bool>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    bool p6 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, int32_t p2, int32_t p3, int32_t p4, bool p5, bool p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.TerrainTools.PaintContext BeginPaintTexture(UnityEngine.Terrain, UnityEngine.Rect, UnityEngine.TerrainLayer, Int32, Boolean) declare in UnityEngine.TerrainTools.TerrainPaintUtility
bool w_ooS_r4r4r4r4_oDi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_oDi4Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Vector2[] GeneratePerTriangleUV(UnityEngine.Mesh, UnityEditor.UnwrapParam) declare in UnityEditor.Unwrapping
bool w_ooS_r4r4r4r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4i4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4i4_>(apis, env, _sv1);
    S_r4r4r4r4i4_ p1 = pp1 ? *pp1 : S_r4r4r4r4i4_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4i4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Networking.UnityWebRequest GetAssetBundle(System.Uri, UnityEngine.CachedAssetBundle, UInt32) declare in UnityEngine.Networking.UnityWebRequestAssetBundle
bool w_ooS_sS_u8u8__Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_sS_u8u8__Du4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_sS_u8u8__* pp1 = DataTransfer::GetPointer<S_sS_u8u8__>(apis, env, _sv1);
    S_sS_u8u8__ p1 = pp1 ? *pp1 : S_sS_u8u8__ {};
    // JSValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_sS_u8u8__ p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Betalgo.Ranul.OpenAI.ObjectModels.RequestModels.MessageContent ImageBinaryContent(Byte[], Betalgo.Ranul.OpenAI.Contracts.Enums.Image.ImageFileType, System.Nullable`1[Betalgo.Ranul.OpenAI.Contracts.Enums.Image.ImageDetailType]) declare in Betalgo.Ranul.OpenAI.ObjectModels.RequestModels.MessageContent
bool w_ooS_s_N_bS_s__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_s_N_bS_s__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(apis, env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
    // JSValToCSVal struct
    N_bS_s__* pp2 = DataTransfer::GetPointer<N_bS_s__>(apis, env, _sv2);
    N_bS_s__ p2 = pp2 ? *pp2 : N_bS_s__ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_s_ p1, struct N_bS_s__ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Type GetEditorCurveValueType(UnityEngine.GameObject, UnityEditor.EditorCurveBinding) declare in UnityEditor.AnimationUtility
bool w_ooS_sosi4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_sosi4i4i4i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(apis, env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_sosi4i4i4i4i4i4i4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.ChildItem[] GetDirectoryRevisionData(Codice.CM.Interfaces.IItemHandler, Codice.CM.Common.RepId, Int64) declare in Codice.Client.BaseCommands.RevisionDataHandler
bool w_ooS_u4u4_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_u4u4_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_u4u4_ p1, int64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// PlasticGui.WorkspaceWindow.Merge.MergeChangesTree BuildForMergeView(PlasticGui.WorkspaceWindow.Merge.MergeViewCheckedStateManager, Codice.CM.Common.RepId, Codice.CM.Common.Merge.MergeTreeResult, IGetConflictResolution, Codice.CM.Common.Mount.MountPointWithPath, Boolean) declare in PlasticGui.WorkspaceWindow.Merge.MergeChangesTree
bool w_ooS_u4u4_ooob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_u4u4_ooob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_u4u4_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, bool p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Networking.UnityWebRequest GetAssetBundle(System.Uri, UnityEngine.Hash128, UInt32) declare in UnityEngine.Networking.UnityWebRequestAssetBundle
bool w_ooS_u8u8_Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_u8u8_Du4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};
    // JSValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, struct S_u8u8_ p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Array CreateInstance(System.Type, Int32[]) declare in System.Array
bool w_ooVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooVi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive params
    Il2CppArray* p1 = Params<int32_t>::PackPrimitive(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Array CreateInstance(System.Type, Int64[]) declare in System.Array
bool w_ooVi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooVi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive params
    Il2CppArray* p1 = Params<int64_t>::PackPrimitive(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Type MakeGenericSignatureType(System.Type, System.Type[]) declare in System.Type
bool w_ooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.StringComparer Create(System.Globalization.CultureInfo, Boolean) declare in System.StringComparer
bool w_oob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.SceneTemplate.InstantiationResult Instantiate(UnityEditor.SceneTemplate.SceneTemplateAsset, Boolean, System.String) declare in UnityEditor.SceneTemplate.SceneTemplateService
bool w_oobDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oobDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Linq.Expressions.LambdaExpression Lambda(System.Linq.Expressions.Expression, Boolean, System.Linq.Expressions.ParameterExpression[]) declare in System.Linq.Expressions.Expression
bool w_oobVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oobVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Puerts.Editor.Generator.DTS.TsMethodGenInfo FromMethodBase(System.Reflection.MethodBase, Boolean, Boolean) declare in Puerts.Editor.Generator.DTS.TsMethodGenInfo
bool w_oobb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oobb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Linq.Expressions.LambdaExpression Lambda(System.Linq.Expressions.Expression, Boolean, System.Collections.Generic.IEnumerable`1[System.Linq.Expressions.ParameterExpression]) declare in System.Linq.Expressions.Expression
bool w_oobo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oobo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Puerts.Editor.Generator.Wrapper.MethodGenInfo FromType(System.Type, Boolean, System.Collections.Generic.List`1[System.Reflection.MethodBase], System.Collections.Generic.List`1[System.Reflection.MethodBase]) declare in Puerts.Editor.Generator.Wrapper.MethodGenInfo
bool w_ooboDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooboDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Explorer.CalculatedStatus CalculateStatus(Codice.CM.Common.WorkspaceInfo, Boolean, Codice.Client.Common.FsReader, Codice.Utils.CancelToken) declare in GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.Explorer.StatusCalculator
bool w_ooboo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooboo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.EditorWindow GetWindow(System.Type, Boolean, System.String) declare in UnityEditor.EditorWindow
bool w_oobs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oobs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Net.WebSockets.WebSocket CreateFromStream(System.IO.Stream, Boolean, System.String, System.TimeSpan) declare in System.Net.WebSockets.WebSocket
bool w_oobsS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oobsS_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_i8_* pp3 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv3);
    S_i8_ p3 = pp3 ? *pp3 : S_i8_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppString* p2, struct S_i8_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.EditorWindow GetWindow(System.Type, Boolean, System.String, Boolean) declare in UnityEditor.EditorWindow
bool w_oobsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oobsb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// CodiceApp.EventTracking.EventSenderScheduler Configure(IRestApi, Codice.Client.Common.EventTracking.ApplicationIdentifier, CodiceApp.EventTracking.EventPlatform) declare in Codice.Client.Common.EventTracking.EventTracking
bool w_ooi2i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi2i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int16_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Microsoft.Win32.RegistryKey FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle, Microsoft.Win32.RegistryView) declare in Microsoft.Win32.RegistryKey
bool w_ooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Reflection.MemberInfo GetMethodInfoForComSlot(System.Type, Int32, System.Runtime.InteropServices.ComMemberType ByRef) declare in System.Runtime.InteropServices.Marshal
bool w_ooi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4Pi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task`1[System.Xml.Linq.XDocument] LoadAsync(System.IO.Stream, System.Xml.Linq.LoadOptions, System.Threading.CancellationToken) declare in System.Xml.Linq.XDocument
bool w_ooi4S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4S_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_o_* pp2 = DataTransfer::GetPointer<S_o_>(apis, env, _sv2);
    S_o_ p2 = pp2 ? *pp2 : S_o_ {};

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, struct S_o_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.GameObject PickClosestGameObject(UnityEngine.Camera, Int32, UnityEngine.Vector2, UnityEngine.GameObject[], UnityEngine.GameObject[], Int32 ByRef) declare in UnityEditor.PhysicsVisualizationSettings
bool w_ooi4S_r4r4_ooPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4S_r4r4_ooPi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P primitive
    int32_t up5 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv5);
    int32_t* p5 = &up5;

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, struct S_r4r4_ p2, Il2CppObject* p3, Il2CppObject* p4, int32_t* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv5, converter::Converter<int32_t>::toScript(apis, env, *p5));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Configuration.Configuration OpenMappedExeConfiguration(System.Configuration.ExeConfigurationFileMap, System.Configuration.ConfigurationUserLevel, Boolean) declare in System.Configuration.ConfigurationManager
bool w_ooi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// TMPro.TMP_SpriteAsset SearchForSpriteByHashCode(TMPro.TMP_SpriteAsset, Int32, Boolean, Int32 ByRef) declare in TMPro.TMP_SpriteAsset
bool w_ooi4bPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4bPi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, bool p2, int32_t* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.TextCore.Text.SpriteAsset SearchForSpriteByHashCode(UnityEngine.TextCore.Text.SpriteAsset, Int32, Boolean, Int32 ByRef, UnityEngine.TextCore.Text.TextSettings) declare in UnityEngine.TextCore.Text.SpriteAsset
bool w_ooi4bPi4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4bPi4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, bool p2, int32_t* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Byte[] FromBase64CharArray(Char[], Int32, Int32) declare in System.Convert
bool w_ooi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Array CreateInstance(System.Type, Int32, Int32, Int32) declare in System.Array
bool w_ooi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Linq.Expressions.DebugInfoExpression DebugInfo(System.Linq.Expressions.SymbolDocumentInfo, Int32, Int32, Int32, Int32) declare in System.Linq.Expressions.Expression
bool w_ooi4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.TextCore.Text.FontAsset CreateFontAsset(UnityEngine.Font, Int32, Int32, UnityEngine.TextCore.LowLevel.GlyphRenderMode, Int32, Int32, UnityEngine.TextCore.Text.AtlasPopulationMode, Boolean) declare in UnityEngine.TextCore.Text.FontAsset
bool w_ooi4i4i4i4i4Di4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4i4i4i4Di4Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (true) {
        if (js_args_len < 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<bool>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    bool p7 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, bool p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Material Add(UnityEngine.Material, Int32, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.CompareFunction, UnityEngine.Rendering.ColorWriteMask, Int32, Int32) declare in UnityEngine.UI.StencilMaterial
bool w_ooi4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.XmlDictionaryReader CreateBinaryReader(Byte[], Int32, Int32, System.Xml.XmlDictionaryReaderQuotas) declare in System.Xml.XmlDictionaryReader
bool w_ooi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.XmlDictionaryReader CreateBinaryReader(Byte[], Int32, Int32, System.Xml.IXmlDictionary, System.Xml.XmlDictionaryReaderQuotas) declare in System.Xml.XmlDictionaryReader
bool w_ooi4i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.XmlDictionaryReader CreateBinaryReader(Byte[], Int32, Int32, System.Xml.IXmlDictionary, System.Xml.XmlDictionaryReaderQuotas, System.Xml.XmlBinaryReaderSession) declare in System.Xml.XmlDictionaryReader
bool w_ooi4i4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.XmlDictionaryReader CreateBinaryReader(Byte[], Int32, Int32, System.Xml.IXmlDictionary, System.Xml.XmlDictionaryReaderQuotas, System.Xml.XmlBinaryReaderSession, System.Xml.OnXmlDictionaryReaderClose) declare in System.Xml.XmlDictionaryReader
bool w_ooi4i4oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4oooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.XmlDictionaryReader CreateMtomReader(Byte[], Int32, Int32, System.Text.Encoding[], System.String, System.Xml.XmlDictionaryReaderQuotas) declare in System.Xml.XmlDictionaryReader
bool w_ooi4i4oso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4oso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppString* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.XmlDictionaryReader CreateMtomReader(Byte[], Int32, Int32, System.Text.Encoding[], System.String, System.Xml.XmlDictionaryReaderQuotas, Int32, System.Xml.OnXmlDictionaryReaderClose) declare in System.Xml.XmlDictionaryReader
bool w_ooi4i4osoi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4osoi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppString* p4, Il2CppObject* p5, int32_t p6, Il2CppObject* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[PlasticGui.Help.Condition] Get(Codice.CM.Common.WorkspaceInfo, PlasticGui.ViewType, Int32, System.String, System.String) declare in PlasticGui.Help.Conditions.QueryViewConditions
bool w_ooi4i4ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName, System.Reflection.Emit.AssemblyBuilderAccess, System.Collections.Generic.IEnumerable`1[System.Reflection.Emit.CustomAttributeBuilder]) declare in System.Reflection.Emit.AssemblyBuilder
bool w_ooi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Build.Content.ObjectIdentifier[] GetPlayerDependenciesForObject(UnityEngine.Object, UnityEditor.BuildTarget, UnityEditor.Build.Player.TypeDB, UnityEditor.Build.Content.DependencyType) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_ooi4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4oi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Reflection.Emit.SignatureHelper GetPropertySigHelper(System.Reflection.Module, System.Reflection.CallingConventions, System.Type, System.Type[], System.Type[], System.Type[], System.Type[][], System.Type[][]) declare in System.Reflection.Emit.SignatureHelper
bool w_ooi4oooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4oooooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Text.StringBuilder fgets(System.Text.StringBuilder, Int32, IntPtr) declare in Mono.Unix.Native.Stdlib
bool w_ooi4p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4p");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, void* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.IList GetMoveInfo(System.Collections.IList, Codice.CM.Client.Differences.ComparisonMethodTypes, Double, Int32) declare in Codice.CM.Client.Differences.FileDiff
bool w_ooi4r8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4r8i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, double p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// PlasticPipe.Client.ReusableTcpClient ConnectTo(System.Net.IPAddress, Int32, System.String, Int32) declare in PlasticPipe.Client.ReusableTcpClient
bool w_ooi4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4si4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Byte[] EncodeArrayToTGA(System.Array, UnityEngine.Experimental.Rendering.GraphicsFormat, UInt32, UInt32, UInt32) declare in UnityEngine.ImageConversion
bool w_ooi4u4u4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4u4u4Du4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    uint32_t p4 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Byte[] EncodeArrayToJPG(System.Array, UnityEngine.Experimental.Rendering.GraphicsFormat, UInt32, UInt32, UInt32, Int32) declare in UnityEngine.ImageConversion
bool w_ooi4u4u4Du4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4u4u4Du4Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<uint32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    uint32_t p4 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.BranchInfo GetBranch(Codice.CM.Common.RepositorySpec, Int64) declare in PlasticGui.WorkspaceWindow.BranchInfoCache
bool w_ooi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.MarkerInfo RenameLabel(Codice.CM.Common.RepositoryInfo, Int64, System.String) declare in Codice.Client.BaseCommands.Labeler
bool w_ooi8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi8s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int64_t p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Client.Commands.TreeContent GetSelectorContent(Codice.CM.Common.RepositoryInfo, Int64, System.String, Boolean) declare in Codice.CM.WorkspaceServer.SelectorSolver
bool w_ooi8sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi8sb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int64_t p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[Codice.CM.Common.LockInfo] List(Codice.CM.Common.RepositoryInfo, Int64, Codice.CM.Common.ListLockOptions) declare in Codice.Client.BaseCommands.ListLocks
bool w_ooi8u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooi8u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, int64_t p1, uint8_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Runtime.Remoting.ObjectHandle CreateInstance(System.ActivationContext, System.String[]) declare in System.Activator
bool w_ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.Tasks.Task`1[Newtonsoft.Json.Linq.JArray] LoadAsync(Newtonsoft.Json.JsonReader, Newtonsoft.Json.Linq.JsonLoadSettings, System.Threading.CancellationToken) declare in Newtonsoft.Json.Linq.JArray
bool w_oooDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooDS_o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal valuetype  with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_o_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Net.HttpWebRequest CreateHttpsRequest(System.Uri, Mono.Security.Interface.MonoTlsProvider, Mono.Security.Interface.MonoTlsSettings) declare in Mono.Security.Interface.MonoTlsProviderFactory
bool w_oooDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEditor.Search.ISearchView ShowPicker(UnityEditor.Search.SearchContext, System.Action`2[UnityEditor.Search.SearchItem,System.Boolean], System.Action`1[UnityEditor.Search.SearchItem], System.Func`2[UnityEditor.Search.SearchItem,System.Boolean], System.Collections.Generic.IEnumerable`1[UnityEditor.Search.SearchItem], System.String, Single, Single, Single, UnityEditor.Search.SearchFlags) declare in UnityEditor.Search.SearchService
bool w_oooDoDoDoDsDr4Dr4Dr4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooDoDoDoDsDr4Dr4Dr4Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<float>::accept(apis, env, _sv7)) return false;
        if (js_args_len > 8 && !converter::Converter<float>::accept(apis, env, _sv8)) return false;
        if (js_args_len > 9 && !converter::Converter<int32_t>::accept(apis, env, _sv9)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                
    // JSValToCSVal string  with default
    Il2CppString* p5 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    float p6 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    float p7 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                
    // JSValToCSVal primitive with default
    float p8 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 8);
                
    // JSValToCSVal primitive with default
    int32_t p9 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 9);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppString* p5, float p6, float p7, float p8, int32_t p9, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Betalgo.Ranul.OpenAI.ObjectModels.SharedModels.PropertyDefinition DefineObject(System.Collections.Generic.IDictionary`2[System.String,Betalgo.Ranul.OpenAI.ObjectModels.SharedModels.PropertyDefinition], System.Collections.Generic.IList`1[System.String], System.Nullable`1[System.Boolean], System.String, System.Collections.Generic.IList`1[System.String]) declare in Betalgo.Ranul.OpenAI.ObjectModels.SharedModels.PropertyDefinition
bool w_oooN_bb_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooN_bb_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    N_bb_* pp2 = DataTransfer::GetPointer<N_bb_>(apis, env, _sv2);
    N_bb_ p2 = pp2 ? *pp2 : N_bb_ {};
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct N_bb_ p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.IAsyncResult BeginGetHostEntry(System.Net.IPAddress, System.AsyncCallback, System.Object) declare in System.Net.Dns
bool w_oooO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle, System.Threading.WaitOrTimerCallback, System.Object, System.TimeSpan, Boolean) declare in System.Threading.ThreadPool
bool w_oooOS_i8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooOS_i8_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal struct
    S_i8_* pp3 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv3);
    S_i8_ p3 = pp3 ? *pp3 : S_i8_ {};
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, struct S_i8_ p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle, System.Threading.WaitOrTimerCallback, System.Object, Int32, Boolean) declare in System.Threading.ThreadPool
bool w_oooOi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooOi4b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle, System.Threading.WaitOrTimerCallback, System.Object, Int64, Boolean) declare in System.Threading.ThreadPool
bool w_oooOi8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooOi8b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, int64_t p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle, System.Threading.WaitOrTimerCallback, System.Object, UInt32, Boolean) declare in System.Threading.ThreadPool
bool w_oooOu4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooOu4b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, uint32_t p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Type PropertyModificationToEditorCurveBinding(UnityEditor.PropertyModification, UnityEngine.GameObject, UnityEditor.EditorCurveBinding ByRef) declare in UnityEditor.AnimationUtility
bool w_oooPS_sosi4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooPS_sosi4i4i4i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Pstruct
    S_sosi4i4i4i4i4i4i4_* p2 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_sosi4i4i4i4i4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_sosi4i4i4i4i4i4i4_));
        p2 = &up2;
    }
        

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_sosi4i4i4i4i4i4i4_* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.Replication.ReplicationSourceInfo GetLatestReplicationSource(Codice.CM.Common.RepositorySpec, Codice.CM.Common.BranchInfo, System.String[] ByRef) declare in PlasticGui.WorkspaceWindow.Replication.ReplicationSourcesQuerier
bool w_oooPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooPo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject** p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.Serialization.DataPacket ReadDataPacket(Codice.CM.Common.Serialization.PlasticBinaryReader, System.IO.Stream, UInt32 ByRef) declare in Codice.Client.BaseCommands.ReplicateObjectDataStorer
bool w_oooPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooPu4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P primitive
    uint32_t up2 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv2);
    uint32_t* p2 = &up2;

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, uint32_t* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<uint32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.Core.TweenerCore`3[UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions] To(DG.Tweening.Core.DOGetter`1[UnityEngine.Vector2], DG.Tweening.Core.DOSetter`1[UnityEngine.Vector2], UnityEngine.Vector2, Single) declare in DG.Tweening.DOTween
bool w_oooS_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.Core.TweenerCore`3[UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions] To(DG.Tweening.Core.DOGetter`1[UnityEngine.Vector3], DG.Tweening.Core.DOSetter`1[UnityEngine.Vector3], UnityEngine.Vector3, Single) declare in DG.Tweening.DOTween
bool w_oooS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_r4r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.Core.TweenerCore`3[UnityEngine.Vector3,UnityEngine.Vector3[],DG.Tweening.Plugins.Options.Vector3ArrayOptions] Punch(DG.Tweening.Core.DOGetter`1[UnityEngine.Vector3], DG.Tweening.Core.DOSetter`1[UnityEngine.Vector3], UnityEngine.Vector3, Single, Int32, Single) declare in DG.Tweening.DOTween
bool w_oooS_r4r4r4_r4Di4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4r4_r4Di4Dr4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_r4r4r4_ p2, float p3, int32_t p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.AnimationCurve CurveField(UnityEngine.GUIContent, UnityEngine.AnimationCurve, UnityEngine.Color, UnityEngine.Rect, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_oooS_r4r4r4r4_S_r4r4r4r4_Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4r4r4_S_r4r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, Il2CppArray* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.Core.TweenerCore`3[UnityEngine.Vector4,UnityEngine.Vector4,DG.Tweening.Plugins.Options.VectorOptions] To(DG.Tweening.Core.DOGetter`1[UnityEngine.Vector4], DG.Tweening.Core.DOSetter`1[UnityEngine.Vector4], UnityEngine.Vector4, Single) declare in DG.Tweening.DOTween
bool w_oooS_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_r4r4r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[PlasticGui.Help.Condition] Get(PlasticGui.Help.GuiHelpEvents, Codice.Client.BaseCommands.BranchExplorer.ExplorerTree.BrExTree, System.DateTime, Int32, Boolean, PlasticGui.IPlasticAPI) declare in PlasticGui.Help.Conditions.BranchExplorerConditions
bool w_oooS_u8_i4bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_u8_i4bo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_u8_ p2, int32_t p3, bool p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumMaskField(System.Enum, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_oooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo, System.Type, Boolean) declare in System.Attribute
bool w_ooob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumFlagsField(UnityEngine.GUIContent, System.Enum, Boolean, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_ooobVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooobVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, Il2CppArray* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.XmlDictionaryWriter CreateJsonWriter(System.IO.Stream, System.Text.Encoding, Boolean, Boolean) declare in System.Runtime.Serialization.Json.JsonReaderWriterFactory
bool w_ooobb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooobb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[System.String] GetMatchingItems(Codice.Client.Common.FsReader, WildcardArgument, Boolean, Boolean, Boolean) declare in Codice.Client.Common.CommandLineArguments
bool w_ooobbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooobbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, bool p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.XmlDictionaryWriter CreateJsonWriter(System.IO.Stream, System.Text.Encoding, Boolean, Boolean, System.String) declare in System.Runtime.Serialization.Json.JsonReaderWriterFactory
bool w_ooobbs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooobbs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, bool p3, Il2CppString* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Linq.Expressions.BinaryExpression Equal(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, Boolean, System.Reflection.MethodInfo) declare in System.Linq.Expressions.Expression
bool w_ooobo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooobo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumFlagsField(UnityEngine.GUIContent, System.Enum, Boolean, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_oooboVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooboVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppArray* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.Dictionary`2[Codice.CM.Common.Mount.MountPointId,System.Collections.Generic.List`1[Codice.CM.Common.Merge.PendingMergeLink]] GetUncoInvolvedMerges(System.Collections.Generic.IList`1[System.String], Codice.Client.Commands.Tree.TreeChangedNode, Boolean, System.Collections.Generic.List`1[Codice.CM.WorkspaceServer.DataStore.Merge.MergeChangesInfo], Codice.CM.Common.Tree.IGetWorkspaceXlink) declare in Codice.Client.BaseCommands.UncoInvolvedMergesFinder
bool w_oooboo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooboo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[Codice.CM.Common.ErrorMessage] Apply(Codice.CM.Common.WorkspaceInfo, System.Collections.Generic.List`1[Codice.Client.GameUI.Shelve.ChangesByMount], Boolean, Codice.Client.BaseCommands.UpdateProgress, Codice.Client.Commands.IWorkspaceTreeHandler, Codice.Client.Commands.IOperationsHandler) declare in Codice.Client.GameUI.Shelve.ApplyPartialShelve
bool w_ooobooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooobooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Reflection.Assembly Load(Byte[], Byte[], System.Security.SecurityContextSource) declare in System.Reflection.Assembly
bool w_oooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[PlasticGui.WorkspaceWindow.ExternalTools.ExternalTool] GetAllConfiguredExternalTools(Codice.Client.BaseCommands.Config.IGlobalConfig, Codice.CM.Common.WorkspaceInfo, ExternalToolTarget, Boolean) declare in PlasticGui.WorkspaceWindow.ExternalTools.LoadExternalTools
bool w_oooi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi4b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[Codice.CM.Common.ItemError] DeleteFromWorkspace(Codice.CM.Common.WorkspaceInfo, System.Collections.Generic.List`1[System.String], Codice.Client.Commands.DeleteModifiers, Codice.Client.BaseCommands.DeleteProgress) declare in Codice.Client.BaseCommands.RmControlledCmdImpl
bool w_oooi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.Core.TweenerCore`3[System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions] To(DG.Tweening.Core.DOGetter`1[System.Int32], DG.Tweening.Core.DOSetter`1[System.Int32], Int32, Single) declare in DG.Tweening.DOTween
bool w_oooi4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.XmlDictionaryWriter CreateMtomWriter(System.IO.Stream, System.Text.Encoding, Int32, System.String) declare in System.Xml.XmlDictionaryWriter
bool w_oooi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.XmlDictionaryWriter CreateMtomWriter(System.IO.Stream, System.Text.Encoding, Int32, System.String, System.String, System.String, Boolean, Boolean) declare in System.Xml.XmlDictionaryWriter
bool w_oooi4sssbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi4sssbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, bool p6, bool p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// PlasticGui.WorkspaceWindow.History.SelectedHistoryGroupInfo BuildFromSelection(System.Collections.Generic.List`1[Codice.CM.Common.RepObjectInfo], System.Collections.Generic.List`1[Codice.CM.Common.HistoryRevision], Int64, Boolean) declare in PlasticGui.WorkspaceWindow.History.SelectedHistoryGroupInfo
bool w_oooi8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi8b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int64_t p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Client.BaseCommands.BranchExplorer.ExplorerData.BrExData GetBrExData(Codice.CM.Common.RepositoryInfo, System.Collections.Generic.List`1[Codice.CM.Common.RepositorySpec], Int64, Int64) declare in Codice.Client.BaseCommands.BranchExplorer.ExplorerData.BrExDataBuilder
bool w_oooi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi8i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int64_t p2, int64_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Client.GameUI.Checkin.CheckinTree BuildCheckinTree(Codice.CM.Common.RepositorySpec, Codice.CM.Common.BranchInfo, Int64, Codice.Client.Commands.Tree.TreeChangedNode, Codice.CM.Common.Checkin.Partial.ConfirmedMounts, Codice.Client.Commands.Xlinks.WorkspaceXlinkList, Codice.CM.Common.Checkin.Partial.ILocalCmPathResolver) declare in Codice.Client.GameUI.Checkin.CheckinTreeBuilder
bool w_oooi8oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi8oooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int64_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.Core.TweenerCore`3[System.Int64,System.Int64,DG.Tweening.Plugins.Options.NoOptions] To(DG.Tweening.Core.DOGetter`1[System.Int64], DG.Tweening.Core.DOSetter`1[System.Int64], Int64, Single) declare in DG.Tweening.DOTween
bool w_oooi8r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi8r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int64_t p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.WorkspaceServer.DataStore.Trees.MountTreeContent`1[Codice.CM.Common.Tree.TreeNode] LoadAsTreeNode(Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.Mount.MountPointId, Int64, System.String) declare in Codice.CM.WorkspaceServer.DataStore.Trees.LocalTreesStorage
bool w_oooi8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi8s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int64_t p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Client.Commands.TreeContent GetSelectorContent(Codice.CM.Common.Mount.MountPointWithPath, Codice.CM.Common.RepositoryInfo, Int64, System.String, Boolean, Codice.Client.Commands.ICloakedRulesLoader) declare in Codice.CM.WorkspaceServer.SelectorSolver
bool w_oooi8sbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi8sbo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int64_t p2, Il2CppString* p3, bool p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Client.BaseCommands.BranchExplorer.ExplorerTree.BrExTree Build(Codice.CM.Common.RepositoryInfo, Codice.Client.BaseCommands.BranchExplorer.ExplorerData.BrExData, Int64, System.String, Codice.Client.BaseCommands.BranchExplorer.BrExWorkspaceCheckoutInfo, System.Collections.Generic.List`1[Codice.CM.Common.Merge.PendingMergeLink], Codice.Client.BaseCommands.BranchExplorer.ExplorerTree.ReplicationSourceSelection, Codice.Client.BaseCommands.BranchExplorer.Layout.FilterCollection) declare in Codice.Client.BaseCommands.BranchExplorer.ExplorerData.BrExTreeBuilder
bool w_oooi8soooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooi8soooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int64_t p2, Il2CppString* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Array CreateInstance(System.Type, Int32[], Int32[]) declare in System.Array
bool w_oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[Codice.Client.Commands.Merge.FileConflictsPerMount] Walk(Codice.CM.Common.MergeSource, Codice.CM.Common.MergeResult, Codice.CM.Common.MergeResult, System.Collections.Generic.List`1[Codice.Client.Commands.Merge.FileConflictsPerMount] ByRef) declare in Codice.Client.BaseCommands.Merge.IncomingChanges.WalkMergeResultForFileConflicts
bool w_ooooPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooPo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv3)); // object ref
    Il2CppObject** p3 = &up3;
        

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject** p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, CSRefToJsValue(apis, env, TIp3, *p3));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumMaskField(UnityEngine.GUIContent, System.Enum, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_ooooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Xml.XmlDictionaryWriter CreateBinaryWriter(System.IO.Stream, System.Xml.IXmlDictionary, System.Xml.XmlBinaryWriterSession, Boolean) declare in System.Xml.XmlDictionaryWriter
bool w_oooob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumPopup(UnityEngine.GUIContent, System.Enum, System.Func`2[System.Enum,System.Boolean], Boolean, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_oooobVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooobVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, Il2CppArray* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// PlasticGui.WorkspaceWindow.PendingChanges.PendingChangesTree FromChanges(Codice.CM.Common.WorkspaceInfo, System.Collections.Generic.List`1[Codice.Client.BaseCommands.ChangeInfo], PlasticGui.WorkspaceWindow.PendingChanges.PendingChangesViewCheckedStateManager, Boolean, Boolean, Boolean) declare in PlasticGui.WorkspaceWindow.PendingChanges.BuildPendingChangesTree
bool w_oooobbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooobbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, bool p4, bool p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Enum EnumPopup(UnityEngine.GUIContent, System.Enum, System.Func`2[System.Enum,System.Boolean], Boolean, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_ooooboVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooboVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        auto TIp5_V = il2cpp::vm::Class::GetElementClass(TIp5);if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal ref params
    Il2CppArray* p5 = Params<void*>::PackRef(apis, env, info, TIp5, js_args_len, 5);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, Il2CppArray* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// PlasticPipe.PlasticProtocol.Client.ClientTransport Create(ISslSupportByServer, ICallCtxMsgVersionSupportedByServer, Codice.Utils.Buffers.FlexibleBufferPool, Boolean, INegotiateActiveDirectory, PlasticPipe.Client.DnsResolveNameToIp, Int32, IResolveCloudServer) declare in PlasticPipe.PlasticProtocol.Client.ClientTransport
bool w_oooobooi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooobooi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, Il2CppObject* p5, int32_t p6, Il2CppObject* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.CodeDom.Compiler.CompilerErrorCollection CompileToType(System.Xml.XmlReader, System.Xml.Xsl.XsltSettings, System.Xml.XmlResolver, Boolean, System.Reflection.Emit.TypeBuilder, System.String) declare in System.Xml.Xsl.XslCompiledTransform
bool w_oooobos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooobos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, Il2CppString* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.Checkin.Partial.CheckinConflict GetConflict(Codice.CM.Common.Mount.MountPointWithPath, Codice.CM.Common.Merge.Difference, Codice.CM.Common.Checkin.Partial.IHeadNodeFinder, System.StringComparison) declare in Codice.CM.Common.Checkin.Partial.ConflictCheckers.AddedConflictChecker
bool w_ooooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Byte[] Convert(System.Text.Encoding, System.Text.Encoding, Byte[], Int32, Int32) declare in System.Text.Encoding
bool w_ooooi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[PlasticGui.Help.Condition] Get(PlasticGui.Help.GuiHelpEvents, Codice.CM.Common.WorkspaceInfo, Codice.Client.BaseCommands.WorkspaceStatusResult, Codice.Client.Commands.WorkspaceStatusOptions, System.String, Int32) declare in PlasticGui.Gluon.Help.Conditions.CheckinViewConditions
bool w_ooooi4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooi4si4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, Il2CppString* p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.MergeSource BuildIncomingMergeSourceFromHeadChangesetId(Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.RepositoryInfo, Codice.CM.Common.Mount.MountPointWithPath, Int64) declare in PlasticGui.WorkspaceWindow.Merge.MergeSourceBuilder
bool w_ooooi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, int64_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.UIElements.ContextualMenuPopulateEvent GetPooled(UnityEngine.UIElements.EventBase, UnityEngine.UIElements.DropdownMenu, UnityEngine.UIElements.IEventHandler, UnityEngine.UIElements.ContextualMenuManager) declare in UnityEngine.UIElements.ContextualMenuPopulateEvent
bool w_ooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Security.PermissionSet ResolvePolicy(System.Security.Policy.Evidence, System.Security.PermissionSet, System.Security.PermissionSet, System.Security.PermissionSet, System.Security.PermissionSet ByRef) declare in System.Security.SecurityManager
bool w_oooooPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooooPo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv4)); // object ref
    Il2CppObject** p4 = &up4;
        

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject** p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv4, CSRefToJsValue(apis, env, TIp4, *p4));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// UnityEngine.Object ObjectField(UnityEngine.GUIContent, UnityEngine.Object, System.Type, UnityEngine.Object, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_oooooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooooVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppArray* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.RevisionInfo ReadRevisionInfo(Codice.CM.Common.Serialization.PlasticBinaryReader, Codice.CM.WorkspaceServer.IWorkspaceRevisionInfoCache, Codice.CM.Common.RepositorySpec, System.Collections.IList, Boolean) declare in Codice.CM.WorkspaceServer.RevisionInfoDataStore
bool w_ooooob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Client.GameUI.Status.CachedStatusSearcher Build(Codice.CM.Common.WorkspaceInfo, Codice.Client.Common.GameUI.ConfigurationTreeNode, Codice.Client.Common.GameUI.ConfigurationTreeNode, Codice.Client.GameUI.Status.StatusChangedCache, Boolean, Codice.Client.Common.FsReader, Codice.Client.BaseCommands.IIgnoredFilter, Codice.Utils.CancelToken) declare in Codice.Client.GameUI.Status.CachedStatusSearcher
bool w_ooooobooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooobooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Linq.Expressions.BlockExpression Block(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) declare in System.Linq.Expressions.Expression
bool w_oooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[PlasticGui.Help.Condition] Get(PlasticGui.Help.GuiHelpEvents, Codice.CM.Common.WorkspaceInfo, Codice.Client.BaseCommands.WorkspaceStatusResult, System.Collections.Generic.IDictionary`2[Codice.CM.Common.Mount.MountPoint,System.Collections.Generic.IList`1[Codice.CM.Common.Merge.PendingMergeLink]], Codice.CM.Common.Merge.PendingMergeLink, Boolean, Codice.Client.Commands.WorkspaceStatusOptions, System.String, Int32, PlasticGui.IPlasticAPI) declare in PlasticGui.Help.Conditions.PendingChangesConditions
bool w_oooooobi4si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooooobi4si4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];
    auto TIp9 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (checkJSArgument) {
        if (js_args_len != 10) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv9, TIp9, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal s
    Il2CppString* p7 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
    // JSValToCSVal o/O
    Il2CppObject* p9 = JsValueToCSRef(apis, TIp9, env, _sv9);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, bool p5, int32_t p6, Il2CppString* p7, int32_t p8, Il2CppObject* p9, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.MergeResult Find(Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.MergeSource, Codice.CM.Common.Mount.MountPoint, Codice.Client.Commands.Tree.TreeChangedNode, Codice.Client.BaseCommands.Merge.StoreMergeProgress, Boolean, Codice.Client.Commands.IOperationsHandler, Codice.Client.Commands.IWorkspaceTreeHandler, Codice.Client.Commands.ICloakedRulesLoader) declare in Codice.Client.BaseCommands.Merge.FindMerge
bool w_oooooobooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooooobooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal o/O
    Il2CppObject* p8 = JsValueToCSRef(apis, TIp8, env, _sv8);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, bool p5, Il2CppObject* p6, Il2CppObject* p7, Il2CppObject* p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.MergeSource BuildMergeSource(Codice.CM.Common.RepositoryInfo, Codice.CM.Common.WorkspaceInfo, Codice.Client.Common.ChangesetSpec, Codice.CM.Common.RepObjectSpec, Codice.Client.Common.BranchSpec, PlasticGui.WorkspaceWindow.Merge.EnumMergeType, Boolean, Boolean, Boolean, System.String, Codice.CM.Common.Mount.MountPointWithPath ByRef) declare in PlasticGui.WorkspaceWindow.Merge.MergeSourceBuilder
bool w_ooooooi4bbbsPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooooi4bbbsPo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp9 = wrapData->TypeInfos[6];
    auto TIp10 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);

    if (checkJSArgument) {
        if (js_args_len != 11) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv9)) return false;
        if (!apis->is_boxed_value(env, _sv10)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
    // JSValToCSVal s
    Il2CppString* p9 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv9);
    // JSValToCSVal Po/PO
    Il2CppObject* up10 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv10)); // object ref
    Il2CppObject** p10 = &up10;
        

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, int32_t p5, bool p6, bool p7, bool p8, Il2CppString* p9, Il2CppObject** p10, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    apis->update_boxed_value(env, _sv10, CSRefToJsValue(apis, env, TIp10, *p10));
    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Linq.Expressions.DynamicExpression Dynamic(System.Runtime.CompilerServices.CallSiteBinder, System.Type, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) declare in System.Linq.Expressions.Expression
bool w_ooooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.MergeResult FindWithSolvedConflicts(Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.MergeSource, Codice.CM.Common.Mount.MountPoint, Codice.Client.Commands.Tree.TreeChangedNode, Codice.Client.BaseCommands.Merge.StoreMergeProgress, Codice.CM.Common.Serialization.MergeConflictArray, Boolean, Codice.Client.Commands.IOperationsHandler, Codice.Client.Commands.IWorkspaceTreeHandler, Codice.Client.Commands.ICloakedRulesLoader) declare in Codice.Client.BaseCommands.Merge.FindMerge
bool w_ooooooobooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooooobooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];
    auto TIp9 = wrapData->TypeInfos[9];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (checkJSArgument) {
        if (js_args_len != 10) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv9, TIp9, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal o/O
    Il2CppObject* p8 = JsValueToCSRef(apis, TIp8, env, _sv8);
    // JSValToCSVal o/O
    Il2CppObject* p9 = JsValueToCSRef(apis, TIp9, env, _sv9);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, bool p6, Il2CppObject* p7, Il2CppObject* p8, Il2CppObject* p9, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.MergeSource BuildMergeSource(Codice.CM.Common.RepositoryInfo, Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.Mount.MountPointWithPath, Codice.Client.Common.ChangesetSpec, Codice.CM.Common.RepObjectSpec, Codice.Client.Common.BranchSpec, PlasticGui.WorkspaceWindow.Merge.EnumMergeType, Boolean, Boolean, Boolean) declare in PlasticGui.WorkspaceWindow.Merge.MergeSourceBuilder
bool w_oooooooi4bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooooooi4bbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (checkJSArgument) {
        if (js_args_len != 10) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, int32_t p6, bool p7, bool p8, bool p9, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Reflection.Emit.SignatureHelper GetPropertySigHelper(System.Reflection.Module, System.Type, System.Type[], System.Type[], System.Type[], System.Type[][], System.Type[][]) declare in System.Reflection.Emit.SignatureHelper
bool w_oooooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooooooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.CM.Common.Update.Partial.OutOfDateItems CalculateOutOfDateItemsWithTrees(Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.RepositorySpec, Codice.CM.Common.Tree.TreeNode, Codice.CM.Common.Tree.TreeNode, Codice.Client.Commands.Tree.TreeChangedNode, System.Collections.Generic.List`1[Codice.CM.Common.ErrorMessage], InvolvedChangedItems, Options) declare in GluonGui.WorkspaceWindow.Views.OutOfDateUpdater
bool w_ooooooooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooooooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, int32_t p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// PlasticGui.WorkspaceWindow.Diff.DiffWindowParameters Build(Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.RepositorySpec, PlasticGui.WorkspaceWindow.Diff.IRegisterDiffWindows, PlasticGui.WorkspaceWindow.IPendingChangesUpdater, PlasticGui.WorkspaceWindow.IIncomingChangesUpdater, PlasticGui.WorkspaceWindow.IShelvedChangesUpdater, PlasticGui.IWorkspaceWindow, Codice.CM.Common.BranchInfo) declare in PlasticGui.WorkspaceWindow.Diff.DiffWindowParametersBuilder
bool w_ooooooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooooooooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp7 = wrapData->TypeInfos[8];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Client.BaseCommands.BranchExplorer.Layout.BrExLayout Build(System.Collections.SortedList, System.Collections.Generic.List`1[Codice.Client.BaseCommands.BranchExplorer.ColumnDrawInfo], System.Collections.Generic.List`1[Codice.Client.BaseCommands.BranchExplorer.BranchDrawInfo], System.Collections.Generic.List`1[Codice.Client.BaseCommands.BranchExplorer.LinkDrawInfo], System.Collections.Generic.List`1[Codice.Client.BaseCommands.BranchExplorer.LabelDrawInfo], System.Collections.Generic.List`1[Codice.Client.BaseCommands.BranchExplorer.ChangesetDrawInfo], System.Collections.Generic.List`1[Codice.Client.BaseCommands.BranchExplorer.BrExChangeset], System.Collections.Generic.Dictionary`2[System.Guid,Codice.Client.BaseCommands.BranchExplorer.ChangesetDrawInfo], Int32) declare in Codice.Client.BaseCommands.BranchExplorer.Layout.BrExLayout
bool w_oooooooooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooooooooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp7 = wrapData->TypeInfos[8];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, int32_t p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// PlasticGui.WorkspaceWindow.Diff.DiffWindowParameters Build(Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.RepositorySpec, PlasticGui.WorkspaceWindow.Diff.IRegisterDiffWindows, PlasticGui.WorkspaceWindow.IPendingChangesUpdater, PlasticGui.WorkspaceWindow.IIncomingChangesUpdater, PlasticGui.WorkspaceWindow.IShelvedChangesUpdater, PlasticGui.IWorkspaceWindow, Codice.CM.Common.ChangesetInfo, Codice.CM.Common.ChangesetInfo) declare in PlasticGui.WorkspaceWindow.Diff.DiffWindowParametersBuilder
bool w_oooooooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooooooooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp7 = wrapData->TypeInfos[8];
    auto TIp8 = wrapData->TypeInfos[9];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal o/O
    Il2CppObject* p8 = JsValueToCSRef(apis, TIp8, env, _sv8);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, Il2CppObject* p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[Codice.Client.BaseCommands.ChangeInfo] GetChanges(Codice.Client.Common.FsNode, Codice.Client.Commands.WkTree.WorkspaceTreeNode, Codice.Client.Commands.Tree.TreeChangedNode, Codice.Client.BaseCommands.Config.IGlobalConfig, Codice.CM.Common.WorkspaceInfo, System.String, Codice.Client.Commands.IWorkspaceTreeHandler, Codice.Client.BaseCommands.CloakedFilesFilter, Codice.Client.BaseCommands.IIgnoredFilter, Codice.Client.BaseCommands.HiddenChangesFilesFilter, IFsNodeReader) declare in Codice.Client.BaseCommands.TestChangeMatchesSearcher
bool w_oooooosooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooooosooooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp7 = wrapData->TypeInfos[8];
    auto TIp8 = wrapData->TypeInfos[9];
    auto TIp9 = wrapData->TypeInfos[10];
    auto TIp10 = wrapData->TypeInfos[11];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);

    if (checkJSArgument) {
        if (js_args_len != 11) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv9, TIp9, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv10, TIp10, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal o/O
    Il2CppObject* p7 = JsValueToCSRef(apis, TIp7, env, _sv7);
    // JSValToCSVal o/O
    Il2CppObject* p8 = JsValueToCSRef(apis, TIp8, env, _sv8);
    // JSValToCSVal o/O
    Il2CppObject* p9 = JsValueToCSRef(apis, TIp9, env, _sv9);
    // JSValToCSVal o/O
    Il2CppObject* p10 = JsValueToCSRef(apis, TIp10, env, _sv10);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppString* p5, Il2CppObject* p6, Il2CppObject* p7, Il2CppObject* p8, Il2CppObject* p9, Il2CppObject* p10, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// DG.Tweening.Tweener To(DG.Tweening.Core.DOGetter`1[UnityEngine.RectOffset], DG.Tweening.Core.DOSetter`1[UnityEngine.RectOffset], UnityEngine.RectOffset, Single) declare in DG.Tweening.DOTween
bool w_oooor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooor4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.String[] CompileCSharp(System.String[], System.String[], System.String[], System.String) declare in UnityEditor.EditorUtility
bool w_oooos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Client.Commands.WkTree.WorkspaceTreeNode CreateNode(Codice.CM.Common.RepositorySpec, Codice.CM.Common.RevisionInfo, Codice.Client.Commands.FileLocalInfo, System.String, Int32) declare in Codice.Client.Common.WkTree.WorkspaceNodeBuilder
bool w_oooosi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooosi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Client.Commands.WkTree.WorkspaceTreeNode CreateNode(Codice.CM.Common.RepositorySpec, Codice.CM.Common.RevisionInfo, Codice.Client.Commands.FileLocalInfo, System.String, Int32, Codice.Client.Commands.Xlinks.ClientXlink) declare in Codice.Client.Common.WkTree.WorkspaceNodeBuilder
bool w_oooosi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooosi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, int32_t p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Codice.Client.BaseCommands.Merge.ClientMergeToResult ApplyMergeTo(Codice.CM.Common.MergeSource, Codice.CM.Common.MergeResult, Codice.CM.Common.Serialization.MergeConflictArray, System.String, Codice.Client.BaseCommands.Merge.MergeSolvedFileConflicts, Codice.Client.Commands.IOperationsHandler) declare in Codice.Client.BaseCommands.Merge.MergeTo.MergeToApplier
bool w_oooosoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_oooosoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// System.Collections.Generic.List`1[System.Single] GetAdaptiveSamples(TreeEditor.TreeGroup, TreeEditor.TreeNode, Single) declare in TreeEditor.TreeData
bool w_ooor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ooor4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

}

